<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Blog网络不稳定访问方法</title>
    <url>/2024/09/12/%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="Blog慢访问问题"><a href="#Blog慢访问问题" class="headerlink" title="Blog慢访问问题"></a>Blog慢访问问题</h1><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>由于本博客是搭建在github pages上的，所以国内访问难免会有访问慢的时候，对此我在云服务器也搭建了一个同步的博客，方便加速访问</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><a class="link"   href="https://blogback.overlordzj.cn/" >点击这个国内链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>即可访问</p>
<p>或者通过主页右上角<code>link</code>菜单下的<code>domestic</code>进行访问</p>
<h2 id="残留问题"><a href="#残留问题" class="headerlink" title="残留问题"></a>残留问题</h2><p>不知道为什么搭建在云服务器的博客没有评论的功能，留一个小坑等之后有时间和能力了来填坑</p>
]]></content>
      <tags>
        <tag>待填坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/09/09/example/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>example</category>
      </categories>
      <tags>
        <tag>example</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器</title>
    <url>/2024/09/10/%E5%A4%87%E5%BF%98%E5%BD%95/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[
<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="01623beed1f3152631c2404190b6f38ec45e5209015973c8234b812b3f302185">2c57a2851a68e9855f8788f6d6316468534e195ad74e87259f53b0c03bb99be47473a3f5f9e5e77c7fc153886505447ef95ba1bd306fe121bb7af72b2f151fe82083b308afa6edd9ad5ce1d9c755cfd176b9064c7f303d86dc65ef12eedeb23bcb2a5c88fe2baba53a67b1b7830cd243cd18dc10d2d19e3553e1ebee2a7aa63ec06a33ce56c2811fa97ec915d8b0228a04990e87e2b4e8504cbf1c1bb8a6056b1277c13a5515a0af51883ca0c09eae27608a5d5f7f1dbe54f8b358bc3720979fc1abc8e61f8e2b4061360ba191fe2abec8a119b1c51725c73c1a7817a3edbafe0a7f7fd2a23022cc11f79b0fc2fc430169b83ad498b6d47792c7edff4ad6eb52d680e5d318e91c91a754e71599631657f7c9e7d4b54d77b73a2ef3050e9df98a92068c863bebdd9de0c29b7b38cb6ddd72487e4081d782805d309c91e81466664a1d0c923ee6bb8bcabf8545dd8fda13de0fea1236d90ef8f80267f1fa8ca8ef953caec07faf4f1056bd1804b4c8aa1ccdc9c06980a0ccfa22ef6970211a9d56ed63dec6c95de3a9cf03eb83853b819a4060d8e92f9e3fd36840fd8e3ede22cd35a8800d4a38dcb81045f98c7b59f6e47d39f90754a887dc5b70f017382ff6040ab63a3a5663adb87ba6975176daa18251a8471bab979a737fa8517d3889f7b2af9d65c25b160056d99ec0728b3e4c742ae8c411f78a063f7a84bce14b4633141780db71813538e437ce3e16ecbe51375844ae6c9570b7516cf140904255c53a65fe7fb5c562a9b656038ead2c584e931e9cfb0b8abd01fbede4d66a441cc6f638a87ccbb4652ee8bd645402a0ab1c0214461bd3a306241f3ed0916af121f5e3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<link href="/css/hbe.style.css" rel="stylesheet" type="text/css"><script data-swup-reload-script type="module" src="/js/plugins/hbe.js"></script>
<script data-swup-reload-script type="module">
import {initHBE} from "/js/plugins/hbe.js";
  console.log("hexo-blog-encrypt: loaded.");
    initHBE();
</script>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的一些代码小技巧</title>
    <url>/2024/09/11/C%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="C语言中的代码小技巧"><a href="#C语言中的代码小技巧" class="headerlink" title="C语言中的代码小技巧"></a>C语言中的代码小技巧</h1><h2 id="1、输出一个回车符号"><a href="#1、输出一个回车符号" class="headerlink" title="1、输出一个回车符号"></a>1、输出一个回车符号</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(<span class="number">10</span>);	<span class="comment">//表示输出一个回车符号</span></span><br></pre></td></tr></table></figure></div>

<p>putchar()函数表示直接输出一个字符，（）内可以填写一个字符；也可以填写其ASCII码（一个整数），然后系统将其转化为字符输出</p>
<p>而ASCII中的10对应的是line feed(换行)，所以改语句才实现了换行功能</p>
<p>当然也可以直接</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>或者</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>();</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>解释</p>
</blockquote>
<p>putchar();输出的是字符，但不自带换行功能。</p>
<p>puts();自带换行功能，将结尾\0换成\n。</p>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>C语言</category>
        <category>基础部分</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>测试密码访问</title>
    <url>/2024/09/09/example/test-passwd/</url>
    <content><![CDATA[
<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9c29d2ae8c9408ebabfe5502d542763af69160ec81974d9abe486a1990c0affe">b7d6aa4f9b0e255d1a59a9e7f2b85d1b1ed944caf21c7e84e4e7408bbf88993cf0d430a5b6e273a1f7a43f8b32eac3de82b6eeb75f7c346696330f8d36f5692a27b30c478d7b56d48dc56572de233ad0130e4a303c4df72a9b15befccec21c02e2aee8df667ff0af8266638f6e91eb6a3bca9f45e4922c6488c20e619887cb0056428b759e3198e95d178adb6800981b0db62870df36f8b0da4a902b04d0e8a6ceee478426bcb36ac1e5b28ae924677481c37900a1de536d7efaa30eb218ef7f223fa63e35f0e1c354d920d7d66d0826589b951e4c6908266586755cf8f9cad0a22961a9c6178b098261f1393913ea36e8dd3cdaf6397b637cdc3d67c1ae5cfd403201d724a44cd364b76a4ef929d18f092b7fef6599a6793491e4d7d652bca7d80798504f5eb9ef3cdaf80f3ebcc23b0cf08d33e0ad7f7409b25bfd41104b9857be0e80a0e2089aea9fc7cd8dcaaeb8d0869460e91bedebc63c8e79916d498bab50676f513b39265bee8b113e4959f44ed3f26f0e91e21e3562751b6e630e5b93e64d69c5d3eaf9c3088c67c59713170f93d18d3d1ca720924fccd220caea295921dbcb25828a70e0948f12124c4995c8c91bbef13371aa993f48558f53d23bfb6859de37901a7215a4219876e9cdf076e340760604fff3a1f813762e132f6ebf866ae10b7d00ab9d795337e5cca897a58550889be251f1cb763a63aead731534794db2feb7da838808a864b7560602b9702ac2cd75230437c7aabf3eaa7178d2f053c482843b3512dbc29c56373ef0f2d94b217ac8b4d3a31f6cb6a104d4483f2da79a75e75d0b66ecc0652c4579d4de9f0c9035d270fccd8552e091cacaf453212de088d7e30e6dee84903441a54774e5f69ad6753498a66b405ed67fa6faff788fe48a27d913199d7f0bb2374c7ebebf999efa28c23e276f42eab52a149b148ae4fbd9a1d1d2ce4f160d26ab160195598371cbac8d56b1ddeafb1089a1a77252986eb69ad798915b056b473116bbf9fcd05009b444ccdeffffbd6b9427b7edc8381965716b9759f5abe789ed3daeca3fa03a06e05494cfd5e75abd767d49b166da24c3e1f1473b9e2038e31d3545745984dd5cca808379572584243128ce2e15ddbc5b85863a6c46c378056b847b577a2616abdccc1a07ee1e52a15dad9e9e747e18efda1be6f421ebbc8a3751d85c6ac4d69b9b18f292314caa2b2a197c75dca9f9e682c0ab35628d707350395c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<link href="/css/hbe.style.css" rel="stylesheet" type="text/css"><script data-swup-reload-script type="module" src="/js/plugins/hbe.js"></script>
<script data-swup-reload-script type="module">
import {initHBE} from "/js/plugins/hbe.js";
  console.log("hexo-blog-encrypt: loaded.");
    initHBE();
</script>
]]></content>
      <categories>
        <category>example</category>
      </categories>
      <tags>
        <tag>example</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文章时效性</title>
    <url>/2024/09/09/example/%E6%B5%8B%E8%AF%95%E6%97%B6%E6%95%88%E6%80%A7/</url>
    <content><![CDATA[<h1 id="这是测试文字"><a href="#这是测试文字" class="headerlink" title="这是测试文字"></a>这是测试文字</h1><h2 id="这是测试文字-1"><a href="#这是测试文字-1" class="headerlink" title="这是测试文字"></a>这是测试文字</h2><h3 id="这是测试文字-2"><a href="#这是测试文字-2" class="headerlink" title="这是测试文字"></a>这是测试文字</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是测试文字</span><br></pre></td></tr></table></figure></div>

<p>这是测试文字</p>
]]></content>
      <categories>
        <category>example</category>
      </categories>
      <tags>
        <tag>example</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C语言学习的部分遗漏问题解答</title>
    <url>/2024/09/10/C%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/</url>
    <content><![CDATA[<h1 id="遗漏问题解答"><a href="#遗漏问题解答" class="headerlink" title="遗漏问题解答"></a>遗漏问题解答</h1><p><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4">浮点数的数值范围</a></p>
<p><a href="#%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5">赋值表达式与赋值语句</a></p>
<p><a href="#%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95">基础排序方法</a></p>
<p><a href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98">汉诺塔问题</a></p>
<p><a href="#%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC">数组赋值</a></p>
<p><a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态内存分配</a></p>
<hr>
<h2 id="浮点数的数值范围"><a href="#浮点数的数值范围" class="headerlink" title="浮点数的数值范围"></a>浮点数的数值范围</h2><h3 id="浮点格式"><a href="#浮点格式" class="headerlink" title="浮点格式"></a>浮点格式</h3><p>精度和范围与数据的存储格式密切相关，所以我们先来看一看它们的存储格式：<br>对于float类型的变量，其底层的存储格式为：</p>
<table>
<thead>
<tr>
<th>符号位（S）</th>
<th>指数阶码（E）</th>
<th>尾数（F）</th>
</tr>
</thead>
<tbody><tr>
<td>1bit</td>
<td>8bit</td>
<td>23bit</td>
</tr>
</tbody></table>
<p>对于double类型的变量，底层的存储格式为：</p>
<table>
<thead>
<tr>
<th>符号位（S）</th>
<th>指数阶码（E）</th>
<th>尾数（F）</th>
</tr>
</thead>
<tbody><tr>
<td>1bit</td>
<td>11bit</td>
<td>52bit</td>
</tr>
</tbody></table>
<p>存储格式为 <code>(-1)^s * F * 2^E</code></p>
<h3 id="范围推导"><a href="#范围推导" class="headerlink" title="范围推导"></a>范围推导</h3><h4 id="float类型"><a href="#float类型" class="headerlink" title="float类型"></a>float类型</h4><p>首先看它的最大的情况，此时S&#x3D;0，F全部是0，指数域全部是1，此时32bit的值为：0111 1111 1000 0000 0000 0000 0000 0000。</p>
<p>它的精确值为：<code>+1.0*2^128</code>，对应的十进制约为：<code>3.4*10^38</code>。</p>
<p>负的无穷大就是当S&#x3D;1的时候，符号取负即可。</p>
<h4 id="double类型"><a href="#double类型" class="headerlink" title="double类型"></a>double类型</h4><p>直接给出的数表示的范围：<code>−1.7*10^308 ∼ +1.7*10^308</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>正常显示的只显示精度范围内的，但实际浮点类型可以存储相当大的数据，只是不会正常显示出来而已。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../source/images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/90c1d403d3c66315cc03416f9374711.png"
                      alt="90c1d403d3c66315cc03416f9374711"
                ></p>
<hr>
<h2 id="赋值表达式与赋值语句"><a href="#赋值表达式与赋值语句" class="headerlink" title="赋值表达式与赋值语句"></a>赋值表达式与赋值语句</h2><h3 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h3><p>简单赋值运算符和表达式:简单赋值运算符记为“&#x3D;”。</p>
<p>由“&#x3D; ”连接的式子称为赋值表达式。其一般形式为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量=表达式</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=a+b</span><br><span class="line">w=sin(a)+sin(b)</span><br><span class="line">y=i++</span><br></pre></td></tr></table></figure></div>

<p>赋值表达式的功能是计算表达式的值再赋予左边的变量。赋值运算符具有右结合性。<br>因此</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=b=c=5</span><br></pre></td></tr></table></figure></div>

<p>可理解为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=(b=(c=5))</span><br></pre></td></tr></table></figure></div>

<p>在其它高级语言中，赋值构成了一个语句，称为赋值语句。</p>
<p>而在 C 中，把“&#x3D;”定义为运算符，从而组成赋值表达式。 凡是表达式可以出现的地方均可出现赋值表达式。<br>例如，式子:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=(a=5)+(b=8)</span><br></pre></td></tr></table></figure></div>

<p>是合法的。它的意义是把 5 赋予 a，8 赋予 b，再把 a,b 相加，和赋予 x，故 x 应等于 13。<br>在Ｃ语言中也可以组成赋值语句，按照Ｃ语言规定，任何表达式在其未尾加上分号就构成为语句。<br>因此如<code>x=8;a=b=c=5；</code>都是赋值语句。</p>
<h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>赋值语句是由赋值表达式再加上分号构成的表达式语句。</p>
<p>其一般形式为： </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量=表达式;</span><br></pre></td></tr></table></figure></div>

<p>在赋值语句的使用中需要注意以下几点：</p>
<ol>
<li><p>由于在赋值符“&#x3D;”右边的表达式也可以又是一个赋值表达式， 因此，下述形式 变量&#x3D;(变量&#x3D;表达式); 是成立的，从而形成 嵌套的情形。 其展开之后的一般形式为：变量&#x3D;变量&#x3D;…&#x3D;表达式; 例如： a&#x3D;b&#x3D;c&#x3D;d&#x3D;e&#x3D;5; 按照赋值运算符的右接合性，因此实际上等效于： e&#x3D;5; d&#x3D;e; c&#x3D;d; b&#x3D;c; a&#x3D;b;</p>
</li>
<li><p>注意在变量说明中给变量赋初值和赋值语句的区别。 给变量赋初值是变量说明的一部分，赋初值后的变量与其后的其它同类变量之间仍必须用逗号间隔，而赋值语句则必须用分号结尾。 例如： int a&#x3D;5,b,c;</p>
</li>
<li><p>在变量说明中，不允许连续给多个变量赋初值。 如下述说明是错误的： int a&#x3D;b&#x3D;c&#x3D;5 必须写为 int a&#x3D;5,b&#x3D;5,c&#x3D;5; 而赋值语句允许连续赋值。</p>
</li>
<li><p>注意赋值表达式和赋值语句的区别。 赋值表达式是一种表达式，它可以出现在任何允许表达式出现的地方，而赋值语句则不能。</p>
</li>
</ol>
<p>下述语句是合法的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((x=y+5)&gt;0) z=x;</span><br></pre></td></tr></table></figure></div>

<p>这里(x&#x3D;y+5)是赋值表达式，语句的功能是，若表达式x&#x3D;y+5大于0则z&#x3D;x。</p>
<p>下述语句是非法的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((x=y+5;)&gt;0) z=x;</span><br></pre></td></tr></table></figure></div>

<p>因为x&#x3D;y+5;是语句，不能出现在表达式中。</p>
<hr>
<h2 id="基础排序方法"><a href="#基础排序方法" class="headerlink" title="基础排序方法"></a>基础排序方法</h2><h3 id="冒泡排序（两两互换）"><a href="#冒泡排序（两两互换）" class="headerlink" title="冒泡排序（两两互换）"></a>冒泡排序（两两互换）</h3><p>冒泡排序是交换排序中一种简单的排序方法。</p>
<p>它的基本思想是对所有相邻记录的关键字值进行比效，如果是逆顺（a[j]&gt;a[j+1]），则将其交换，最终达到有<br>序化;</p>
<p>其处理过程为： </p>
<p>（1）将整个待排序的记录序列划分成有序区和无序区，初始状态有序区为空，无序区包括所有待排序的记<br>录。 </p>
<p>（2）对无序区从前向后依次将相邻记录的关键字进行比较，若逆序将其交换，从而使得关键字值小的记录向<br>上”飘浮”（左移），关键字值大的记录好像石块，向下“堕落”（右移）。 每经过一趟冒泡排序，都使无序区中<br>关键字值最大的记录进入有序区，对于由n个记录组成的记录序列，最多经过n-1趟冒泡排序，就可以将这n个记<br>录重新按关键字顺序排列。</p>
<blockquote>
<p>原始的冒泡排序算法 对由n个记录组成的记录序列，最多经过（n-1）趟冒泡排序，就可以使记录序列成为<br>有序序列，第一趟定位<strong>第n个</strong>记录，此时有序区只有一个记录；第二趟定位<strong>第n-1个</strong>记录，此时有序区有两个记<br>录；以此类推，算法框架为： for（i&#x3D;n；i&gt;1；i—） { 定位第i个记录；}</p>
</blockquote>
<p>代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> data[<span class="number">5</span>];</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;请输入数据：\n&quot;</span>);</span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)</span><br><span class="line">   &#123;</span><br><span class="line">   	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data[i]);	<span class="comment">//输入数据 </span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)  <span class="comment">//采用双重循环 </span></span><br><span class="line">   &#123;</span><br><span class="line">   	<span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; <span class="number">5</span> - <span class="number">1</span> - i;j++)</span><br><span class="line">   	&#123;</span><br><span class="line">   	  <span class="keyword">if</span>(data[j] &gt; data[j+<span class="number">1</span>])     <span class="comment">//这里默认采用升序来排列 </span></span><br><span class="line">		 &#123;</span><br><span class="line">		 	<span class="type">int</span> temp;        <span class="comment">//定义一个临时值来存储数据，以此来达到交换数值的目的</span></span><br><span class="line">			temp = data[j];</span><br><span class="line">			data[j] = data[j+<span class="number">1</span>];</span><br><span class="line">			data[j+<span class="number">1</span>] = temp;</span><br><span class="line">		 &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;排序好的数组为：\n&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)    <span class="comment">//用for循环来遍历并输出排序完成的数组 </span></span><br><span class="line">   &#123;</span><br><span class="line">   	 <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,data[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="一、什么是选择排序？"><a href="#一、什么是选择排序？" class="headerlink" title="一、什么是选择排序？"></a>一、什么是选择排序？</h4><p> 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的中数据元素选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p>
<h4 id="二、选择排序思路"><a href="#二、选择排序思路" class="headerlink" title="二、选择排序思路"></a>二、选择排序思路</h4><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h4 id="三、排序过程"><a href="#三、排序过程" class="headerlink" title="三、排序过程"></a>三、排序过程</h4><p>例：定义一个数组 int a[8] &#x3D; {9，3，7，2，6，1，5，8}，要求利用选择排序的方法将数组从小到大排序。</p>
<p>排序的次数：因为每排好一个元素，那么所需要排的元素个数减一，直到排到倒数第二个元素停止，将倒数第二个元素也排好后，整体数组排序就完成了。<strong>所以排序的次数 &#x3D; 元素个数 - 1。(冒泡排序的排序次数与该排序的排序次数计算方法相同)</strong></p>
<blockquote>
<p>9，3，7，2，6，1，5，8</p>
</blockquote>
<p>第一次排序：假设首元素作为整体元素数据最小值，然后从该元素的后一个元素开始每个元素都与该最小值进行比较，假如有比该元素小的值，<strong>就用一个变量去记住下标值</strong>，最后比较完成后，把两个元素互换位置即可。</p>
<p>第一次排序结果：</p>
<blockquote>
<p>1，3，7，2，6，9，5，8</p>
</blockquote>
<p>第二次排序：因为第一次排序选择的是将首元素作为最小值，最终经过互换位置，首元素排序完成，第二次排序就不需要排序首元素，只需要排序除首元素以外的元素，然后在依照第一次排序的原理进行排序。</p>
<p>第二次排序结果：</p>
<blockquote>
<p>1，2，7，3，6，9，5，8</p>
</blockquote>
<p>然后根据第一次排序和第二次排序的原理，最终的排序结果为：{1，2，3，5，6，7，8，9}</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_out</span><span class="params">(<span class="type">int</span> a[<span class="number">8</span>])</span><span class="comment">//输出函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_sort</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)<span class="comment">//排序次数</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>;j &lt; n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j] &lt; p[min])</span><br><span class="line">            &#123;</span><br><span class="line">                min = j;<span class="comment">//记录交换的元素下标值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != min)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = p[i];</span><br><span class="line">            p[i] = p[min];</span><br><span class="line">            p[min] = temp;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">arr_sort(a,<span class="number">8</span>);<span class="comment">//排序函数</span></span><br><span class="line">arr_out(a);<span class="comment">//输出函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>&#x3D;&#x3D;（递归）&#x3D;&#x3D;</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../source/images/%E9%81%97%E6%BC%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/3962f9684ac18a8b980c9b2f2ce63bb6.png"
                      alt="3962f9684ac18a8b980c9b2f2ce63bb6"
                ></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>思路：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用的语言：C语言</span><br><span class="line">使用的编译器：vs2019</span><br><span class="line">参考书籍：谭浩强第四版</span><br><span class="line">主要使用的知识：函数的递归</span><br><span class="line">代码实现的思路主要分为三步：</span><br></pre></td></tr></table></figure></div>

<p>假设总共需要移动n个盘子</p>
<blockquote>
<p>F(n)&#x3D;2F(n-1)+1 可以推到出需要移动2^n-1^次</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">将A柱上的n-1个盘子借助C柱移向B柱</span><br><span class="line">将A柱上仅剩的最后一个盘子移向C柱</span><br><span class="line">将B柱上的n-1个盘子借助A柱移向C柱</span><br></pre></td></tr></table></figure></div>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c\n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		move(a, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		hanoi(n - <span class="number">1</span>, a, c, b);<span class="comment">//将A座上的n-1个盘子借助C座移向B座</span></span><br><span class="line">		move(a, c);<span class="comment">//将A座上最后一个盘子移向C座</span></span><br><span class="line">		hanoi(n - <span class="number">1</span>, b, a, c);<span class="comment">//将B座上的n-1个盘子借助A座移向C座</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//move中的实参与hanoi函数中的形参相对应，而hanoi函数中形参a，b，c所对应的值也是在有规律的变化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	hanoi(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h2><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><p>数组赋值可以在定义的时候直接赋值，例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[]=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="type">char</span> arr[<span class="number">10</span>]=<span class="string">&#x27;world&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="循环赋值"><a href="#循环赋值" class="headerlink" title="循环赋值"></a>循环赋值</h3><p>在定义数组后，用循环进行对数组中的值进行赋值，例：</p>
<h4 id="下标赋值"><a href="#下标赋值" class="headerlink" title="下标赋值"></a>下标赋值</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h4><p>指针赋值结束后定义的指针会出现偏移而不是最开始指向的数组头地址，用<code>p = &amp;a[0];</code>将指针改回去</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p=a;	<span class="comment">//int *p=&amp;a[0];</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,p++);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p><strong>（<a class="link"   href="https://blog.csdn.net/TheWhiteFox/article/details/108502906" >此处挪用CSDN博主的文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</strong></p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>malloc（）找到可用内存中一个大小适合的块。<br>内存是匿名的；</p>
<p>也就是说，malloc（）分配了内存，但没有为它指定名字。<br>然而，它却可以<code>返回那块内存第一个字节的地址</code>。<br>因此，可以把<code>那个地址赋值给一个指针变量</code>，并使用该指针来访问那块内存。<br>因为char代表一个字节，所以传统上曾将malloc（）定义为指向char的指针类型。</p>
<p>然而，ANSIC标准使用了一个新类型：指向void的指针。这一类型被用作“通用指针”。<br>函数malloc（）可用来返回数组指针、结构指针等等，因此一般需要把返回值的类型指派为适当的类型。</p>
<p>在ANSIC中，为了程序清晰应对指针进行类型指派，但将void 指针值赋值给其他类型的指针并不构成类型冲突。<br>如果malloc（）找不到所需的空间，它将返回空指针。<br>我们使用malloc（）来创建一个 数组。可以在程序运行时使用malloc（）请求一个存储块，另外还需要一个指针来存放该块在内存中的位置。</p>
<p>例如，如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> * ptd;</span><br><span class="line">ptd = (<span class="type">double</span> * ) <span class="built_in">malloc</span> (<span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br></pre></td></tr></table></figure></div>

<p><strong>这段代码请求30个double类型值的空间，并且把ptd指向该空间所在位置。</strong></p>
<blockquote>
<p>注意:ptd是作为指向一个double类型值的指针声明的，而不是指向30个double类型值的数据块的指针。</p>
</blockquote>
<blockquote>
<p>记住：数组的名字是它第一个元素的地址。</p>
</blockquote>
<p>因此，如果令ptd指向一个内存块的第一个元素，就可以像使用数组名一样使用它。<br>也就是说，可以使用表达式ptd[0]来访问内存块的第一个元素，pd[1]来访问第二个元素，依此类推。<br>正如前面所学，可以在指针符号中使用数组名，也可以在数组符号中使用指针。</p>
<p>现在，创建一个数组有三种方法：<br>1.声明一个<code>数组</code>，声明时用常量表达式指定数组维数，然后可以用数组名访问数组元素。<br>2.声明一个<code>变长数组</code>，声明时用变量表达式指定数组维数，然后用数组名来访问数组元素（这是C99的一个特性）。<br>3.声明一个<code>指针</code>，调用malloc（），然后使用该指针来访问数组元素。</p>
<p>使用第二种或第三种方法可以做一些用普通的数组声明做不到的事：</p>
<p>创建一个动态数组（dynamic array），即一个在程序运行时才分配内存并可在程序运行时选择大小的数组。</p>
<p>例如，假定n是一个整数量。在C99之前，不能这样做：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> item[n]：<span class="comment">/*如果n是一个变量，C99之前不允许这样做*/</span></span><br></pre></td></tr></table></figure></div>

<p>然而，即使在C99之前的编译器中，也可以这样做：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ptd =（<span class="type">double</span>*）<span class="built_in">malloc</span>（n*<span class="keyword">sizeof</span>（<span class="type">double</span>））；<span class="comment">/*可以*/</span></span><br></pre></td></tr></table></figure></div>

<p>这行得通，而且正如您将看到的那样，这样做比使用一个变长数组更灵活。</p>
<p>一般地，对应每个malloc（）调用，应该调用一次free（）。<br><code>函数free（）的参数是先前malloc（）返问的地址</code>，它释放先前分配的内存。</p>
<p>这样，所分配内存的持续时间从调用malloc（）分配内存开始，到调用free（）释放内存以供再使用为止。</p>
<p>设想malloc（）和free（）管理着一个内存池。<br>每次调用malloc（）分配内存给程序使用，每次调用free（）将内存归还到池中，使内存可被再次使用。</p>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>free（）的参数应是一指针，指向由malloc（）分配的内存块；</li>
<li>其他方式（例如声明一个数组）分配的内存是不能使用free（）去释放的。</li>
</ul>
<p>在头文件stdlib.h中有malloc（）和free（）的原型。（我不知道，哈哈）</p>
<p>通过使用malloc（），程序可以在运行时决定需要多大的数组并创建它。</p>
<p>程序清单12.14 举例证明了这可能。</p>
<p>它把内存块地址赋给指针ptd，接着以使用数组名的方式使用ptd。</p>
<p>程序还调用了exit（）函数。该函数的原型在 stdlib.h 中，用来在内存分配失败时结束程序。</p>
<ul>
<li><p>值 EXIT_FAILURE 也在这个头文件中定义。标准库提供了两个保证能够在所有操作系统下工作的返回值：</p>
<p>EXIT SUCCESS（或者，等同于0）指示程序正常终止;</p>
<p>EXIT_FAILURE指示程序异常终止。</p>
</li>
</ul>
<p>另外，有些操作系统，包括UNIX、Linux 和Windows，能够接受其他的整数值。</p>
<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>在编译程序时，静态变量的数量是固定的：在程序运行时也不改变。</p>
<p>自动变量使用的内存数量在程序执行时自动增加或者减少。<br>但被分配的内存所使用内存数量只会增加，除非您记得使用free（）。</p>
<blockquote>
<p>如果不适当使用，容易造成内存泄漏（memory leak）</p>
</blockquote>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><p>内存分配还可以使用calloc（）。</p>
<p>典型的应用如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> * newmen;</span><br><span class="line">newmen = (<span class="type">long</span> *) <span class="built_in">calloc</span> (<span class="number">100</span>, <span class="keyword">sizeof</span>( <span class="type">long</span>)); </span><br></pre></td></tr></table></figure></div>

<p>与 malloc（）类似，calloc（）在ANSI以前的版本中返回一个 char 指针，在ANSI中返回一个void指针。<br>如果要存储不同类型，应该使用类型指派运算符。<br>这个新函数接受两个参数，都应是无符号的整数（在ANSI中是size_t类型）。</p>
<p>第一个参数是<code>所需内存单元的数量</code>，第二个参数是<code>每个单元以字节计的大小</code>。</p>
<p>在这里，long使用4个字节，因此这一指令建立了100个4字节单元，总共使用400个字节来存储。</p>
<p>使用 sizeof（long）而不是 4 使代码更具可易移植性。<br>它可在其他系统中运行，这些系统中 long不是4字节而是别的大小。</p>
<p>函数calloc（）还有一个特性：相当于空数组初始化<br>它将块中的全部位都置为0（然而要注意，在某些硬件系统中，浮点值0不是用全部位为0来表示的）。</p>
<h3 id="动态内存分配与变长数组"><a href="#动态内存分配与变长数组" class="headerlink" title="动态内存分配与变长数组"></a>动态内存分配与变长数组</h3><p><code>变长数组（Variable-Length Array，VLA）</code>与<code>malloc（）</code>在功能上有些一致。例如，它们都可以用来创建一个大小在运行时决定的数组：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">valmal</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> * pi;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">pi = (<span class="type">int</span> *) <span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> ar[n];<span class="comment">//变长数组 </span></span><br><span class="line"></span><br><span class="line">pi[<span class="number">2</span>] = ar[<span class="number">2</span>] = <span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一个区别在于 VLA 是自动存储的。</p>
<p>自动存储的结果之一就是 VLA 所用内存空间在运行完定义部分之后会自动释放。</p>
<p>在本例中，就是函数 vlamal（）终止的时候。因此不必使用 free（）。</p>
<p>另一方面，使用由 malloc（）创建的数组不必局限在一个函数中。</p>
<p>例如，函数可以创建一个数组并返回指针，供调用该函数的函数访问。<br>接着，后者可以在它结束时调用 free（）。<br>free（）可以使用不同于 malloc（）指针的指针变量：必须一致的是指针中存储的地址。</p>
<p><code>VLA 对多维数组来说更方便。</code><br>您可以使用 malloc（）来定义一个二维数组，但语法很麻烦。<br>如果编译器不支持 VLA 特性，必须固定一维的大小，正如下面的函数调用：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> ar2[n][m];<span class="comment">//n*m 的变长数组 </span></span><br><span class="line"><span class="type">int</span>(* p2) [<span class="number">6</span>];<span class="comment">//在c99之前可以使用 </span></span><br><span class="line"><span class="type">int</span>(* p3) [m];<span class="comment">//要求变长数组支持 </span></span><br><span class="line"></span><br><span class="line">p2 = (<span class="type">int</span> (*)<span class="number">6</span>) <span class="built_in">malloc</span> (n * <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// n*6 数组 </span></span><br><span class="line">p3 = (<span class="type">int</span> (*)[m]) <span class="built_in">malloc</span> (n * m * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// n*m 数组 </span></span><br><span class="line"><span class="comment">//上面的表达式也要求变长数组支持 </span></span><br><span class="line"></span><br><span class="line">ar2[<span class="number">1</span>][<span class="number">2</span>] = p2[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></div>
<p>有必要查看一下指针声明。函数malloc（）返回一个指针，因此p2必须是适当类型的指针。<br>下面的声明：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>(* p2) [<span class="number">6</span>];<span class="comment">//在c99之前可以使用</span></span><br></pre></td></tr></table></figure></div>

<p> 表明p2指向一个包含6个int值的数组。<br>这意味着p2将被解释为一个由6个整数构成的元素，p2[ i ][ j ]将是一个int值。</p>
<p>第二个指针声明使用变量来指定p3所指数组的大小。<br>这意味着p3将被看作<code>一个指向 VLA 的指针</code>，这正是代码不能在C90标准中运行的原因。</p>
<h3 id="内存类与动态内存分配"><a href="#内存类与动态内存分配" class="headerlink" title="内存类与动态内存分配"></a>内存类与动态内存分配</h3><p>您可能正在为存储类和动态内存分配之间的联系感到疑惑。</p>
<p>我们来看一个理想模型。<br>可以认为程序将它的可用内存分成了三个独立的部分：<br>一个是具有外部链接的、具有内部链接的以及具有空链接的静态变量的：<br>一个是自动变量的：<br>另一个是动态分配的内存的。<br><code>(静态变量)：</code><br>在编译时就已经知道了静态存储时期存储类变量所需的内存数量，存储在这一部分的数据在整个程序运行期间都可用。</p>
<p>这一类型的每个变量在程序开始时就已存在，到程序结束时终止。</p>
<p><code>(动态变量)：</code><br>然而，一个自动变量在程序进入包含该变量定义的代码块时产生，在退出这一代码块时终止。</p>
<p>因此，伴随着程序对函数的调用和终止，自动变量使用的内存数量也在增加和减少。</p>
<p>典型地，将这一部分内存处理为一个堆栈。</p>
<p>这意味着在内存中，新变量在创建时按顺序加入，在消亡时按相反顺序移除。</p>
<p><code>(动态内存分配)：</code><br>动态分配的内存在调用malloc（）或相关函数时产生，在调用free（）时释放。</p>
<p>由程序员而不是一系列固定的规则控制内存持续时间，因此内存块可在一个函数中创建，而在另一个函数中释放。(malloc 可以跨函数调用)</p>
<p>由于这点，动态内存分配所用的内存部分可能变成碎片状，也就是说，在活动的内存块之间散布着未使用的字节片。</p>
<p>不管怎样，使用动态内存往往导致进程比使用堆栈内存慢。</p>
]]></content>
      <categories>
        <category>C语言</category>
        <category>基础部分</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF竞赛模式</title>
    <url>/2024/09/12/ctf/data/%E7%AB%9E%E8%B5%9B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="竞赛模式"><a href="#竞赛模式" class="headerlink" title="竞赛模式"></a>竞赛模式</h1><p>CTF竞赛模式具体分为以下几类：</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><p>理论题多见于国内比赛，通常为选择题。包含单选及多选，选手需要根据自己所学的相关理论知识进行作答。最终得出分数。理论部分通常多见于初赛或是初赛之前的海选</p>
<h3 id="Jeopardy-解题"><a href="#Jeopardy-解题" class="headerlink" title="Jeopardy-解题"></a>Jeopardy-解题</h3><p>参赛队伍可以通过互联网或者现场网络参与，参数队伍通过与在线环境交互或文件离线分析，解决网络安全技术挑战获取相应分值，类似于 ACM 编程竞赛、信息学奥林匹克赛，根据总分和时间来进行排名。</p>
<p>不同的是这个解题模式一般会设置 一血(First Blood) 、 二血(Second Blood) 、 三血(Third Blood) ，也即最先完成的前三支队伍会获得额外分值，所以这不仅是对首先解出题目的队伍的分值鼓励，也是一种团队能力的间接体现。</p>
<p>当然还有一种流行的计分规则是设置每道题目的初始分数后，根据该题的成功解答队伍数，来逐渐降低该题的分值，也就是说如果解答这道题的人数越多，那么这道题的分值就越低。最后会下降到一个保底分值后便不再下降。一般称之为<code>动态积分</code></p>
<p>题目类型主要包含 Web 网络攻防 、 RE 逆向工程 、 Pwn 二进制漏洞利用 、 Crypto 密码攻击以及 Misc 安全杂项 这五个类别，个别比赛会根据题目类型进行扩展。</p>
<h3 id="AwD-攻防模式"><a href="#AwD-攻防模式" class="headerlink" title="AwD-攻防模式"></a>AwD-攻防模式</h3><p><strong>A</strong>ttack <strong>w</strong>ith <strong>D</strong>efense(AwD)全称攻防模式，在攻防模式CTF赛制中，参赛队伍连接到同一个网络空间。主办方会预先为每个参赛队分配要防守的主机，该主机称之为<code>GameBox</code>，每个队伍之间的GameBox<code>配置及漏洞是完全一致</code>的，选手需要防护自己的GameBox不被攻击的同时挖掘漏洞并攻击对手服务来得分。在AwD中主办方会运行一个名为<code>Checker</code>的程序定时检测选手的GameBox的运行状态。若检测到状态不对则判定该GameBox宕机，按照规则扣除一定分数。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续24至48小时左右），同时也比团队之间的分工配合与合作。</p>
<p>AwD通常仅包含<code>Web</code>及<code>Pwn</code>两种类型的题目。每个队伍可能会分到多个GameBox，随着比赛的进行，最早的GameBox可能会下线，同时会上线新的GameBox。</p>
<h3 id="ADP-攻防增强"><a href="#ADP-攻防增强" class="headerlink" title="ADP-攻防增强"></a>ADP-攻防增强</h3><p><strong>A</strong>ttack <strong>D</strong>efense <strong>P</strong>lus(ADP)全称攻防增强模式，在该模式下中，参赛队伍连接到同一个网络空间。主办方会在平台上放置题目，选手需要登录到平台获得题目信息</p>
<p>攻击模式下，平台会给出题目的访问链接，选手按照解题模式做题提交flag即可完成攻击，当完成攻击后， 每轮计算分数时均会计算该题目的攻击得分。</p>
<p>防御模式下，选手需要自行挖掘题目的漏洞，并制作漏洞补丁包上传至平台，之后点击验证。验证时平台会新建一个完全干净的题目环境，使用预置的Exploit进行攻击，若攻击成功当验证通过之后（即已经完成修补），每轮计算分数均会认为该题目已防御。</p>
<p>也就是说，对于每个题目，仅需要攻击成功一次，防御成功一次，该题就可以认为已完成，后续无需进行关注。</p>
<p>ADP通常仅包含<code>Web</code>及<code>Pwn</code>两种类型的题目。随着比赛的进行，最早的题目可能会下线，后续也有可能会上线新的题目。</p>
<p>ADP相较于AwD来说，选手无须编写批量攻击脚本，也无需关注题目的环境是否被攻击，是否服务异常等等，要做的只是攻击一次，防御一次，选手可以有更多的时间聚焦于还未完成的题目。从主办方的角度来说，大大减轻了比赛的硬件成本和运维成本。</p>
<h3 id="RHG-自动化-AI自动化"><a href="#RHG-自动化-AI自动化" class="headerlink" title="RHG-自动化[AI自动化]"></a>RHG-自动化[AI自动化]</h3><p><strong>R</strong>obo <strong>H</strong>acking <strong>G</strong>ame(RHG)该利用人工智能或是AI或是自动化攻击程序来全自动的挖掘并利用漏洞，考验选手对于<code>漏洞理解</code>以及<code>工程化</code>能力。比赛开始前(一般为1-4周左右)主办方会给出测试环境以及相关接口文档。选手需要编写自动化程序来请求接口获取题目相关信息，该类程序通常称之为<code>bot</code>，在程序中<code>全自动</code>访问并挖掘目标漏洞，完成利用漏洞攻击并获取flag的过程。获取到的flag也由程序自动化提交。RHG因为是由bot全自动进行工作，所以比赛开始即可视为结束。剩下的一切全看参赛选手编写的自动化bot的工作情况。</p>
<p>比赛过程中不允许选手对bot进行任何的操作(包括debug&#x2F;patch等等)。选手仅能看到自己的bot完成了哪些题。目前的得分情况等等。</p>
<h3 id="RW-真实世界"><a href="#RW-真实世界" class="headerlink" title="RW-真实世界"></a>RW-真实世界</h3><p><strong>R</strong>eal <strong>W</strong>orld(RW) 首次于2018年<code>长亭科技</code>主办的RealWorldCTF中出现，该赛制着重考察选手在面对真实的环境下的漏洞挖掘与利用能力。通常RW模式出题也会围绕着能够应用于真实渗透攻击当中的漏洞，一般来说RW常见题型为VM&#x2F;Docker逃逸、针对浏览器的攻击、针对IoT&#x2F;Car等设备的攻击，Web类攻击等等<br>在RW赛制中会有一个<code>Show Time</code>，当选手认为自己已经可以完成题目时，选手可以在比赛平台上提交展示申请，由工作人员根据申请先后顺序进行展示排期。选手展示之前需要上台并连接相关网络，同时现场大屏会切换至目标的正常页面。选手确认连接并测试OK之后开始计时。一般情况下上台攻击的时间为<code>5分钟</code>，选手一旦完成攻击现场大屏幕会实时看到攻击的效果，此时裁判会根据效果是否符合题目要求来判定该题是否完成。如未在攻击时间内依然未能看到展示效果则认为本次攻击失败。现如今为了防止选手恶意排期。通常会有一个队伍总展示次数(例如在2019年数字经济云安全公测大赛中每个队伍只允许上台展示30次)，选手也需要尽可能保证上台之后攻击的成功率</p>
<p>举个例子。题目要求需要攻击位于比赛网络中的某个网站并将首页替换为包含队伍名称的页面。题目给出该网站的一些信息(源代码&#x2F;数据库等等)，选手经过本地挖掘漏洞之后，提交展示申请，排期到了之后进行上台展示。注意，因为RW模式是以展示效果来作为题目是否完成的准则，所以在RW模式中并<code>不存在Flag</code>。</p>
<h3 id="KoH-抢占山头"><a href="#KoH-抢占山头" class="headerlink" title="KoH-抢占山头"></a>KoH-抢占山头</h3><p><strong>K</strong>ing <strong>o</strong>f <strong>H</strong>ill(KoH)是近些年新衍生的一种赛制。该赛制有点类似于AwD，但是又和AwD有些不一样。选手面对的是一个黑盒的目标，需要先挖掘漏洞并利用漏洞控制目标。将自己的队伍标识(<code>队伍名称</code>或是<code>Token</code>之类)写入到指定文件。随后在该主机上进行加固等操作防止其他队伍攻击，主办方会定期去检查标识文件，根据文件中的队伍标识来判定本回合分数给予哪个队伍。可以看出KoH也是一种对抗极为激烈的赛制，同时考察选手的渗透能力及防御加固能力。</p>
<h3 id="Mix-混合"><a href="#Mix-混合" class="headerlink" title="Mix[混合]"></a>Mix[混合]</h3><p>混合模式结合了以上多种模式，现如今单一的赛制已经无法满足比赛及选手的参赛需求，所以大部分比赛会同时以多个模式进行比赛。例如参赛队伍通过解题(Jeopardy)可以获取一些初始分数，然后通过攻防对抗(AwD)进行得分增减的零和游戏，最终以得分高低分出胜负。</p>
<hr>
<p>搬迁自<a class="link"   href="https://www.wolai.com/ctfhub/mmJYyc569kAXHvfam4qont" >CTF官方指导 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>data</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>WriteUp</title>
    <url>/2024/09/12/ctf/writeup/writeup/</url>
    <content><![CDATA[<h1 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp"></a>WriteUp</h1><p>CTF题目传送门</p>
<ol>
<li><a href="/2024/09/12/ctf/writeup/web/catalogue/" title="web安全目录">web安全</a></li>
<li></li>
<li></li>
</ol>
<p>推荐在线靶场传送门</p>
<ol>
<li><a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里收录了我在做的CTF题目，题目可能来自不同靶场，会有标识的，目前还在持续更新中~</p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>本人是个大二学生，平时就是搞搞电脑，只要是和电脑有关的都感兴趣。</p>
<p>（不怎么会自我介绍，就将就看看吧(๑◕ܫ￩๑)b ）</p>
<p> 目前还属于CTF小白，略懂一二内网渗透。有了一点道行后听见学长们推荐写writeup来提升能力，所以就开始了我的wirteup之旅。写writeup文章时不时也会引用一些大佬的资料，希望大家能够一起共同进步，从入门到入土，或者你想从入门到入狱我也不拦你 ε&#x3D;ε&#x3D;ε&#x3D;ε&#x3D;ε&#x3D;ε&#x3D;┌(;￣◇￣)┘</p>
<blockquote>
<p>CTF在线靶场都是在线生成的动态flag，若要复现不要直接挪用flag哦，因为你是交不了的 ≖‿≖✧</p>
</blockquote>
<p>话不多说，去看看有没有你心动的WP吧٩(๑´0&#96;๑)۶ </p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>web安全目录</title>
    <url>/2024/09/12/ctf/writeup/web/catalogue/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>（根据上传顺序以及题目难度进行排序）</p>
<ol>
<li>buuctf<ol>
<li><a href="/2024/09/12/ctf/writeup/web/buuctf/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DHttp/" title="极客大挑战2019 Http">[极客大挑战 2019]Http</a></li>
<li><a href="/2024/09/12/ctf/writeup/web/buuctf/BUU-BURP-COURSE-1/" title="BUU BURP COURSE 1">BUU-BURP-COURSE-1</a></li>
<li></li>
</ol>
</li>
<li>ctfhub<ol>
<li><a href="/2024/09/12/ctf/writeup/web/ctfhub/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/" title="信息泄露-Git泄露-Log">信息泄露-Git泄露</a></li>
<li></li>
</ol>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU BURP COURSE 1</title>
    <url>/2024/09/12/ctf/writeup/web/buuctf/BUU-BURP-COURSE-1/</url>
    <content><![CDATA[<h1 id="BUU-BURP-COURSE-1"><a href="#BUU-BURP-COURSE-1" class="headerlink" title="BUU BURP COURSE 1"></a>BUU BURP COURSE 1</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>开启靶场后，只有一行文字，查看F12也没有东西，我们就抓包来看看，这里用的BP</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/BUU-BURP-COURSE-1/image-20240912212137491.png"
                      alt="image-20240912212137491"
                ></p>
<p>尝试使用<code>X-Forwarded-For</code>或者<code>X-Client</code>改包，返回这样的页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/BUU-BURP-COURSE-1/image-20240912212428190.png"
                      alt="image-20240912212428190"
                ></p>
<p>查看网页源码可以看到密码，但其实没有什么用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/BUU-BURP-COURSE-1/image-20240912212506652.png"
                      alt="image-20240912212506652"
                ></p>
<p>我们直接点击登录继续抓包，加上上一步的伪造本地请求，即可得到flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/BUU-BURP-COURSE-1/image-20240912212702328.png"
                      alt="image-20240912212702328"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>新手试水题，水~</p>
<p><a class="link"   href="https://buuoj.cn/challenges#BUU%20BURP%20COURSE%201" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>web入门-粗心的小李</title>
    <url>/2024/09/12/ctf/writeup/web/buuctf/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/</url>
    <content><![CDATA[<h1 id="web入门-粗心的小李"><a href="#web入门-粗心的小李" class="headerlink" title="[web入门]粗心的小李"></a>[web入门]粗心的小李</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开靶场看到是Git泄露，首先就是检测再还原找flag</p>
<p>会用到工具python2的<a class="link"   href="https://github.com/BugScanTeam/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和python3的<a class="link"   href="https://github.com/lijiejie/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，需要提前准备，别问为什么两个都要下，接下来你就知道了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/image-20240913013606873.png"
                      alt="image-20240913013606873"
                ></p>
<p>检测可以通过加&#x2F;.git&#x2F;，若返回是403则说明有可能存在源码泄露；或者通过目录扫描工具检测</p>
<p>检测出存在可能后使用工具python2的<a class="link"   href="https://github.com/BugScanTeam/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行恢复</p>
<p>需要用到python2，建议直接kali，kali自带有python2和很多库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python2 GitHack.py 目标地址/.git</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/image-20240913014316448.png"
                      alt="image-20240913014316448"
                ></p>
<p>执行后会多出一些文件，既然.git都出来了，那就好说了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/image-20240913014504812.png"
                      alt="image-20240913014504812"
                ></p>
<p>但其实这里是没有我们需要的flag的</p>
<p>对没错，又是一个坑，我的另一篇<a href="/2024/09/12/ctf/writeup/web/ctfhub/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/" title="信息泄露-Git泄露-Log">writeup</a>中，用的这个python2环境才能实现，而这道题要用python3环境的githack，所以之后还是两个都走一遍吧，谁知道呢</p>
<p>当我们用python3环境的githack时，目录中就有一些可以看得到的文件了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/image-20240913015133582.png"
                      alt="image-20240913015133582"
                ></p>
<p>进去看看，哦，一看我们的flag就出来了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5Bweb%E5%85%A5%E9%97%A8%5D%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E/image-20240913015202941.png"
                      alt="image-20240913015202941"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于文件使用后却和想要的结果完全不一样的时候，考虑一下版本问题以及查找资料，不要死磕（你又不是高手，啥都磕对身体不好๑乛◡乛๑）</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%80%E7%AB%A0%20web%E5%85%A5%E9%97%A8]%E7%B2%97%E5%BF%83%E7%9A%84%E5%B0%8F%E6%9D%8E" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>极客大挑战2019 Http</title>
    <url>/2024/09/12/ctf/writeup/web/buuctf/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DHttp/</url>
    <content><![CDATA[<h1 id="极客大挑战-2019-Http"><a href="#极客大挑战-2019-Http" class="headerlink" title="[极客大挑战 2019]Http"></a>[极客大挑战 2019]Http</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://buuoj.cn/" >BUUCTF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，也有相关的配套课本（我看的是《CTF实战 从入门到提升》，感觉还行，但有不少细节感觉还是得查资料才能懂）</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>开启靶场后，打开是一个普通页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912182741453.png"
                      alt="image-20240912182741453"
                ></p>
<p>上下翻找没有其他可利用的，直接上F12大法（或者crtl+U查看网页源代码）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912183001262.png"
                      alt="image-20240912183001262"
                ></p>
<p>这里我是直接查看源代码，找到需要的<code>Secret.php</code>文件</p>
<blockquote>
<p>但有一个坑，这里需要左右拖动才能看到我们需要的</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912183130513.png"
                      alt="image-20240912183130513"
                ></p>
<p>点击后可以看到需要从指定的网页<code>https://Sycsecret.buuoj.cn</code>打开</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912183337334.png"
                      alt="image-20240912183337334"
                ></p>
<p>根据题目来看也是一个HTTP改包，可以通过<code>BurpSuite</code>来抓包（工具不限）</p>
<p>根据提示抓包后，添加<code>Referer:https://Sycsecret.buuoj.cn</code>伪造访问来源</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912184441621.png"
                      alt="image-20240912184441621"
                ></p>
<p>Forward后看到还需要我们用<code>&quot;Syclover&quot;</code>浏览器，要有耐心，继续改包吧&#x3D;_&#x3D;，这次需要修改<code>User-Agent</code>来伪造访问，User-Agent协议表示的是用户访问的信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912184518595.png"
                      alt="image-20240912184518595"
                ></p>
<p>修改的位置随便，甚至可以把整个User-Agent删空再加一个Syclover，记得带上上一步修改的Referer协议</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912184844862.png"
                      alt="image-20240912184844862"
                ></p>
<p>然后会得到让我们用本地访问（127.0.0.1），可以添加<code>X-Forwarded-For:127.0.0.1</code>，也可以添加<code>X-Client</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912184941281.png"
                      alt="image-20240912184941281"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912185221699.png"
                      alt="image-20240912185221699"
                ></p>
<p>加上后再次返回，经过3次修改包，我们成功得到了flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DHttp/image-20240912185234356.png"
                      alt="image-20240912185234356"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇算是新手入门级别，成功水了一篇~</p>
<p><a class="link"   href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]Http" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web</category>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>信息泄露-SVN泄露</title>
    <url>/2024/09/12/ctf/writeup/web/ctfhub/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-SVN%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h1 id="信息泄露-SVN泄露"><a href="#信息泄露-SVN泄露" class="headerlink" title="信息泄露-SVN泄露"></a>信息泄露-SVN泄露</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://www.ctfhub.com/" >CTFHUB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，比较官方的一个大型练习靶场。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>当开发人员使用 SVN 进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。</p>
<p>根据题目需要提前准备工具<a class="link"   href="https://github.com/admintony/svnExploit.git" >SVNExploit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>打开靶场看到和题目提示一样，是一个SVN泄露</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-SVN%E6%B3%84%E9%9C%B2/image-20240913005004198.png"
                      alt="image-20240913005004198"
                ></p>
<p>使用工具检测目标是否存在SVN工具（例行检查）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python SvnExploit.py -u 目标地址/.svn</span><br></pre></td></tr></table></figure></div>

<p>初次使用会有报错，下载pip包就可以</p>
<blockquote>
<p>或者直接在kali里面使用工具，kali里面的py包很全面</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install prettytable -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-SVN%E6%B3%84%E9%9C%B2/image-20240913005735686.png"
                      alt="image-20240913005735686"
                ></p>
<p>再次运行之后可以看到有结果输出，证明有svn泄露</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-SVN%E6%B3%84%E9%9C%B2/image-20240913005921606.png"
                      alt="image-20240913005921606"
                ></p>
<p>在原来的命令后面加上<code>--dump</code>参数，把源码下载下来</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python SvnExploit.py -u 目标地址/.svn --dump</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-SVN%E6%B3%84%E9%9C%B2/image-20240913010130190.png"
                      alt="image-20240913010130190"
                ></p>
<p>恢复的文件有一个<code>wc.db</code>，是一个数据库文件，可以查看到文件索引</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-SVN%E6%B3%84%E9%9C%B2/image-20240913012737667.png"
                      alt="image-20240913012737667"
                ></p>
<p>使用curl命令访问可以文件检查网页源代码是否存在flag，检查均返回404</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://challenge-2465e7edfc335d47.sandbox.ctfhub.com:10800/index.html13523.txt</span><br><span class="line">curl http://challenge-2465e7edfc335d47.sandbox.ctfhub.com:10800/flag_135183523.txt</span><br></pre></td></tr></table></figure></div>

<p>根据上面所示，并没有flag文件，也确实没有直接被下载下来，毕竟题上也写了是在旧版本里面，所以使用其他工具进行还原</p>
<p><a class="link"   href="https://github.com/kost/dvcs-ripper" >dvsc-ripper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>这个工具需要很多环境和包，所以建议在kali里面执行</p>
<p>进入kali，安装工具所需依赖库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install perl libio-socket-ssl-perl libdbd-sqlite3-perl libclass-dbi-perl libio-all-lwp-perl</span><br></pre></td></tr></table></figure></div>

<p>安装完后，进入到工具目录，执行</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./rip-svn.pl -v -u 目标地址/.svn </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-SVN%E6%B3%84%E9%9C%B2/image-20240913011925973.png"
                      alt="image-20240913011925973"
                ></p>
<p>既然是svn文件，那就会在.svn目录下面，低版本SVN具体路径为text-base目录，高版本SVN为pristine目录，然后层层往下查找，中途肯定会有找不到的时候，可以将文件放到实体机，用文件内容搜索工具搜索flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-SVN%E6%B3%84%E9%9C%B2/image-20240913012313165.png"
                      alt="image-20240913012313165"
                ></p>
<p>最后flag被找出来，又解决了一道题</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个题目虽然与git泄露类似，但因为是svn，所以恢复起来没那么常见，这个文件我也是在CSDN上面的writeup找到的，初学者遇到完全没思路或者已经行不通的时候就多去网上找找资料，慢慢培养能力</p>
<p><a class="link"   href="https://www.ctfhub.com/#/skilltree" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>路径为web-&gt;信息泄露-&gt;svn泄露</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web</category>
        <category>ctfhub</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>信息泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>信息泄露-Git泄露-Log</title>
    <url>/2024/09/12/ctf/writeup/web/ctfhub/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h1 id="信息泄露-Git泄露"><a href="#信息泄露-Git泄露" class="headerlink" title="信息泄露-Git泄露"></a>信息泄露-Git泄露</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出自<a class="link"   href="https://www.ctfhub.com/" >CTFHUB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>练习场，比较官方的一个大型练习靶场。</p>
<h2 id="题目-Log"><a href="#题目-Log" class="headerlink" title="题目-Log"></a>题目-Log</h2><p>当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。请尝试使用BugScanTeam的GitHack完成本题。</p>
<p>根据题目提示，提前准备工具需要用到<a class="link"   href="https://github.com/BugScanTeam/GitHack" >GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>打开靶场，页面上很空白，根据题目进行.git文件泄露的恢复操作</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2-Log/image-20240912213108044.png"
                      alt="image-20240912213108044"
                ></p>
<p>尝试在网址后面添加&#x2F;.git&#x2F;，查看是否网页403或者其他特殊情况，方便我们直接用工具恢复，显然这道题没那么简单</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2-Log/image-20240912213235037.png"
                      alt="image-20240912213235037"
                ></p>
<p>接下来用网站目录扫描工具，这里用的<a class="link"   href="https://github.com/maurosoria/dirsearch" >dirsearch <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（可以用御剑等等）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u 目标地址</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2-Log/image-20240912213718118.png"
                      alt="image-20240912213718118"
                ></p>
<p>不用扫描完，扫描到确实有.git的存在，我们就可以试试用工具恢复</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2-Log/image-20240912213911928.png"
                      alt="image-20240912213911928"
                ></p>
<p>在工具包目录下面生成了一些文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2-Log/image-20240912213948091.png"
                      alt="image-20240912213948091"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2-Log/image-20240912214334276.png"
                      alt="image-20240912214334276"
                ></p>
<p>但是并没有什么有价值的文件，也没有.git文件</p>
<blockquote>
<p>这是一个坑，要用另一个GitHack.py，并且在python2的环境才可以，建议在kali下运行</p>
<p><a class="link"   href="https://github.com/lijiejie/GitHack" >https://github.com/lijiejie/GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 用于python3，但恢复效果一般</p>
<p><a class="link"   href="https://github.com/BugScanTeam/GitHack" >https://github.com/BugScanTeam/GitHack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 用于python2，效果不错</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 GitHack.py 目标地址/.git</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/image-20240912215937518.png"
                      alt="image-20240912215937518"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2-Log/image-20240912220043425.png"
                      alt="image-20240912220043425"
                ></p>
<p>既然有.git，根据题目来看，可以通过查看日志获得一些信息，kali环境自带git，其他没有git环境的需要自己下载</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2-Log/image-20240912220103402.png"
                      alt="image-20240912220103402"
                ></p>
<p>通过观察上面的日志信息，可以发生在第二次修改时<code>add flag</code>，说明我们所要的flag就在第二次修改时加入文件中，使用<code>git reset</code>版本回退命令来查看flag</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 对应版本的commit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../../../../../images/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2-Log/image-20240912220806774.png"
                      alt="image-20240912220806774"
                ></p>
<p>最终我们通过.git文件泄露，回退版本得到了flag</p>
<h2 id="题目-Stash"><a href="#题目-Stash" class="headerlink" title="题目-Stash"></a>题目-Stash</h2><h2 id="题目-Index"><a href="#题目-Index" class="headerlink" title="题目-Index"></a>题目-Index</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做题时要根据题目来做题，半做半猜，不要盲目乱入手</p>
<p>在实际做题时会遇到各种坑，需要多花耐心慢慢琢磨（由于本人也是新手，也花了好些时间搞这节。。。）</p>
<p><a class="link"   href="https://www.ctfhub.com/#/skilltree" >题目在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>路径为web-&gt;信息泄露-&gt;git泄露</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>writeup</category>
        <category>web</category>
        <category>ctfhub</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>信息泄露</tag>
      </tags>
  </entry>
</search>
